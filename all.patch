diff --git a/Makefile b/Makefile
index b974afb..12c4531 100644
--- a/Makefile
+++ b/Makefile
@@ -94,11 +94,11 @@ DEFINES += HAVE_BAGL_FONT_OPEN_SANS_LIGHT_16PX
 DEFINES += HAVE_UX_FLOW
 endif
 
-DEFINES += RESET_ON_CRASH
+#DEFINES += RESET_ON_CRASH
 
 ## Use developer build
-#DEVEL = 1
-#DEFINES += HEADLESS
+DEVEL = 1
+DEFINES += HEADLESS
 
 # Enabling debug PRINTF
 ifeq ($(DEVEL), 1)
diff --git a/src/auxDataHashBuilder.c b/src/auxDataHashBuilder.c
index 2de2d13..f4340a5 100644
--- a/src/auxDataHashBuilder.c
+++ b/src/auxDataHashBuilder.c
@@ -1,265 +1,265 @@
-#include "common.h"
-#include "auxDataHashBuilder.h"
-#include "hash.h"
-#include "cbor.h"
-#include "cardano.h"
-#include "bufView.h"
-
-// this tracing is rarely needed
-// so we want to keep it turned off to avoid polluting the trace log
-
-//#define TRACE_AUX_DATA_HASH_BUILDER
-
-#ifdef TRACE_AUX_DATA_HASH_BUILDER
-#define _TRACE(...) TRACE(__VA_ARGS__)
-#else
-#define _TRACE(...)
-#endif // DEVEL
-
-enum {
-	HC_AUX_DATA =         (1u << 0), // aux data hash context
-	HC_CATALYST_PAYLOAD = (1u << 1)  // catalyst voting registration payload hash context
-};
-
-/*
-The following macros and functions have dual purpose:
-1. syntactic sugar for neat recording of hash computations;
-2. tracing of hash computations (allows to reconstruct bytestrings we are hashing via usbtool).
-*/
-
-#define APPEND_CBOR(hashContexts, type, value) \
-	if (hashContexts & HC_AUX_DATA) { \
-		blake2b_256_append_cbor_aux_data(&builder->auxDataHash, type, value, true); \
-	} \
-	if (hashContexts & HC_CATALYST_PAYLOAD) { \
-		blake2b_256_append_cbor_aux_data(&builder->catalystRegistrationData.payloadHash, type, value, false); \
-	}
-
-#define APPEND_DATA(hashContexts, buffer, bufferSize) \
-	if (hashContexts & HC_AUX_DATA) { \
-		blake2b_256_append_buffer_aux_data(&builder->auxDataHash, buffer, bufferSize, true); \
-	} \
-	if (hashContexts & HC_CATALYST_PAYLOAD) { \
-		blake2b_256_append_buffer_aux_data(&builder->catalystRegistrationData.payloadHash, buffer, bufferSize, false); \
-	}
-
-
-__noinline_due_to_stack__
-static void blake2b_256_append_cbor_aux_data(
-        blake2b_256_context_t* hashCtx,
-        uint8_t type, uint64_t value,
-        bool trace
-)
-{
-	uint8_t buffer[10] = {0};
-	size_t size = cbor_writeToken(type, value, buffer, SIZEOF(buffer));
-	if (trace) {
-		TRACE_BUFFER(buffer, size);
-	}
-	blake2b_256_append(hashCtx, buffer, size);
-}
-
-static void blake2b_256_append_buffer_aux_data(
-        blake2b_256_context_t* hashCtx,
-        const uint8_t* buffer, size_t bufferSize,
-        bool trace
-)
-{
-	ASSERT(bufferSize < BUFFER_SIZE_PARANOIA);
-
-	// keeping tracing within a function to be able to extract the serialized data
-	// by matching the function name where the tracing is invoked
-	if (trace) {
-		TRACE_BUFFER(buffer, bufferSize);
-	}
-	blake2b_256_append(hashCtx, buffer, bufferSize);
-}
-
-/* End of hash computation utilities. */
-
-void auxDataHashBuilder_init(
-        aux_data_hash_builder_t* builder
-)
-{
-	TRACE("Serializing tx auxiliary data");
-	blake2b_256_init(&builder->auxDataHash);
-	blake2b_256_init(&builder->catalystRegistrationData.payloadHash);
-
-	{
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 2);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_INIT;
-}
-
-void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_INIT);
-	{
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 2);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT;
-}
-
-void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT);
-	{
-		// map {61284: <payload>} is being hashed and signed in the catalyst voting registration
-		// this instruction introduces the beginning of this single-key dictionary
-		// the remainder of the payload serialization shares the tokens with the overall auxiliary data CBOR
-		APPEND_CBOR(HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 1)
-
-		// Enter the Catalyst voting key registration payload inner map
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD);
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 4);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT;
-}
-
-void auxDataHashBuilder_catalystRegistration_addVotingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(votingPubKeySize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY);
-		{
-			ASSERT(votingPubKeySize == PUBLIC_KEY_SIZE);
-			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, votingPubKeySize);
-			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, votingPubKeyBuffer, votingPubKeySize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY;
-}
-
-void auxDataHashBuilder_catalystRegistration_addStakingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(stakingPubKeySize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY);
-		{
-			ASSERT(stakingPubKeySize == PUBLIC_KEY_SIZE);
-			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, stakingPubKeySize);
-			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, stakingPubKeyBuffer, stakingPubKeySize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY;
-}
-
-void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* addressBuffer, size_t addressSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY);
-	ASSERT(addressSize <= BUFFER_SIZE_PARANOIA);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS);
-		{
-			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, addressSize);
-			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, addressBuffer, addressSize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS;
-}
-
-void auxDataHashBuilder_catalystRegistration_addNonce(
-        aux_data_hash_builder_t* builder,
-        uint64_t nonce
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE);
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, nonce);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE;
-}
-
-void auxDataHashBuilder_catalystRegistration_finalizePayload(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
-
-	ASSERT(outSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
-	{
-		blake2b_256_finalize(&builder->catalystRegistrationData.payloadHash, outBuffer, outSize);
-	}
-}
-
-void auxDataHashBuilder_catalystRegistration_addSignature(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* signatureBuffer, size_t signatureSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(signatureSize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
-	{
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_SIGNATURE);
-		{
-			ASSERT(signatureSize == ED25519_SIGNATURE_LENGTH);
-			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 1);
-			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, CATALYST_SIGNATURE_KEY);
-			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_BYTES, signatureSize);
-			APPEND_DATA(HC_AUX_DATA, signatureBuffer, signatureSize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE;
-}
-
-void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(
-        aux_data_hash_builder_t* builder
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE);
-	{
-		// auxiliary scripts currently hard-coded to an empty list
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 0);
-	}
-
-	builder->state = AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS;
-}
-
-void auxDataHashBuilder_finalize(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS);
-
-	ASSERT(outSize == AUX_DATA_HASH_LENGTH);
-	{
-		blake2b_256_finalize(&builder->auxDataHash, outBuffer, outSize);
-	}
-
-	builder->state = AUX_DATA_HASH_BUILDER_FINISHED;
-}
+// #include "common.h"
+// #include "auxDataHashBuilder.h"
+// #include "hash.h"
+// #include "cbor.h"
+// #include "cardano.h"
+// #include "bufView.h"
+
+// // this tracing is rarely needed
+// // so we want to keep it turned off to avoid polluting the trace log
+
+// //#define TRACE_AUX_DATA_HASH_BUILDER
+
+// #ifdef TRACE_AUX_DATA_HASH_BUILDER
+// #define _TRACE(...) TRACE(__VA_ARGS__)
+// #else
+// #define _TRACE(...)
+// #endif // DEVEL
+
+// enum {
+// 	HC_AUX_DATA =         (1u << 0), // aux data hash context
+// 	HC_CATALYST_PAYLOAD = (1u << 1)  // catalyst voting registration payload hash context
+// };
+
+// /*
+// The following macros and functions have dual purpose:
+// 1. syntactic sugar for neat recording of hash computations;
+// 2. tracing of hash computations (allows to reconstruct bytestrings we are hashing via usbtool).
+// */
+
+// #define APPEND_CBOR(hashContexts, type, value) \
+// 	if (hashContexts & HC_AUX_DATA) { \
+// 		blake2b_256_append_cbor_aux_data(&builder->auxDataHash, type, value, true); \
+// 	} \
+// 	if (hashContexts & HC_CATALYST_PAYLOAD) { \
+// 		blake2b_256_append_cbor_aux_data(&builder->catalystRegistrationData.payloadHash, type, value, false); \
+// 	}
+
+// #define APPEND_DATA(hashContexts, buffer, bufferSize) \
+// 	if (hashContexts & HC_AUX_DATA) { \
+// 		blake2b_256_append_buffer_aux_data(&builder->auxDataHash, buffer, bufferSize, true); \
+// 	} \
+// 	if (hashContexts & HC_CATALYST_PAYLOAD) { \
+// 		blake2b_256_append_buffer_aux_data(&builder->catalystRegistrationData.payloadHash, buffer, bufferSize, false); \
+// 	}
+
+
+// __noinline_due_to_stack__
+// static void blake2b_256_append_cbor_aux_data(
+//         blake2b_256_context_t* hashCtx,
+//         uint8_t type, uint64_t value,
+//         bool trace
+// )
+// {
+// 	uint8_t buffer[10] = {0};
+// 	size_t size = cbor_writeToken(type, value, buffer, SIZEOF(buffer));
+// 	if (trace) {
+// 		TRACE_BUFFER(buffer, size);
+// 	}
+// 	blake2b_256_append(hashCtx, buffer, size);
+// }
+
+// static void blake2b_256_append_buffer_aux_data(
+//         blake2b_256_context_t* hashCtx,
+//         const uint8_t* buffer, size_t bufferSize,
+//         bool trace
+// )
+// {
+// 	ASSERT(bufferSize < BUFFER_SIZE_PARANOIA);
+
+// 	// keeping tracing within a function to be able to extract the serialized data
+// 	// by matching the function name where the tracing is invoked
+// 	if (trace) {
+// 		TRACE_BUFFER(buffer, bufferSize);
+// 	}
+// 	blake2b_256_append(hashCtx, buffer, bufferSize);
+// }
+
+// /* End of hash computation utilities. */
+
+// void auxDataHashBuilder_init(
+//         aux_data_hash_builder_t* builder
+// )
+// {
+// 	TRACE("Serializing tx auxiliary data");
+// 	blake2b_256_init(&builder->auxDataHash);
+// 	blake2b_256_init(&builder->catalystRegistrationData.payloadHash);
+
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 2);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_INIT;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_INIT);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 2);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT);
+// 	{
+// 		// map {61284: <payload>} is being hashed and signed in the catalyst voting registration
+// 		// this instruction introduces the beginning of this single-key dictionary
+// 		// the remainder of the payload serialization shares the tokens with the overall auxiliary data CBOR
+// 		APPEND_CBOR(HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 1)
+
+// 		// Enter the Catalyst voting key registration payload inner map
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD);
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 4);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addVotingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(votingPubKeySize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY);
+// 		{
+// 			ASSERT(votingPubKeySize == PUBLIC_KEY_SIZE);
+// 			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, votingPubKeySize);
+// 			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, votingPubKeyBuffer, votingPubKeySize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addStakingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(stakingPubKeySize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY);
+// 		{
+// 			ASSERT(stakingPubKeySize == PUBLIC_KEY_SIZE);
+// 			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, stakingPubKeySize);
+// 			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, stakingPubKeyBuffer, stakingPubKeySize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* addressBuffer, size_t addressSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY);
+// 	ASSERT(addressSize <= BUFFER_SIZE_PARANOIA);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS);
+// 		{
+// 			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, addressSize);
+// 			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, addressBuffer, addressSize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addNonce(
+//         aux_data_hash_builder_t* builder,
+//         uint64_t nonce
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE);
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, nonce);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_finalizePayload(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
+
+// 	ASSERT(outSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
+// 	{
+// 		blake2b_256_finalize(&builder->catalystRegistrationData.payloadHash, outBuffer, outSize);
+// 	}
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addSignature(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* signatureBuffer, size_t signatureSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(signatureSize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_SIGNATURE);
+// 		{
+// 			ASSERT(signatureSize == ED25519_SIGNATURE_LENGTH);
+// 			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 1);
+// 			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, CATALYST_SIGNATURE_KEY);
+// 			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_BYTES, signatureSize);
+// 			APPEND_DATA(HC_AUX_DATA, signatureBuffer, signatureSize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(
+//         aux_data_hash_builder_t* builder
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE);
+// 	{
+// 		// auxiliary scripts currently hard-coded to an empty list
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 0);
+// 	}
+
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS;
+// }
+
+// void auxDataHashBuilder_finalize(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS);
+
+// 	ASSERT(outSize == AUX_DATA_HASH_LENGTH);
+// 	{
+// 		blake2b_256_finalize(&builder->auxDataHash, outBuffer, outSize);
+// 	}
+
+// 	builder->state = AUX_DATA_HASH_BUILDER_FINISHED;
+// }
diff --git a/src/auxDataHashBuilder.h b/src/auxDataHashBuilder.h
index e32710d..e0270e7 100644
--- a/src/auxDataHashBuilder.h
+++ b/src/auxDataHashBuilder.h
@@ -1,87 +1,87 @@
-#ifndef H_CARDANO_APP_AUX_DATA_HASH_BUILDER
-#define H_CARDANO_APP_AUX_DATA_HASH_BUILDER
+// #ifndef H_CARDANO_APP_AUX_DATA_HASH_BUILDER
+// #define H_CARDANO_APP_AUX_DATA_HASH_BUILDER
 
-#include "cardano.h"
-#include "hash.h"
-#include "keyDerivation.h"
+// #include "cardano.h"
+// #include "hash.h"
+// #include "keyDerivation.h"
 
-enum {
-	METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD = 61284,
-	METADATA_KEY_CATALYST_SIGNATURE = 61285,
-};
+// enum {
+// 	METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD = 61284,
+// 	METADATA_KEY_CATALYST_SIGNATURE = 61285,
+// };
 
-enum {
-	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY = 1,
-	CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY = 2,
-	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS = 3,
-	CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE = 4,
-};
+// enum {
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY = 1,
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY = 2,
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS = 3,
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE = 4,
+// };
 
-enum {
-	CATALYST_SIGNATURE_KEY = 1,
-};
+// enum {
+// 	CATALYST_SIGNATURE_KEY = 1,
+// };
 
-typedef enum {
-	AUX_DATA_HASH_BUILDER_INIT = 100,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT = 200,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT = 210,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY = 211,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY = 212,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS = 213,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE = 214,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE = 220,
-	AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS = 300,
-	AUX_DATA_HASH_BUILDER_FINISHED = 400,
-} aux_data_hash_builder_state_t;
+// typedef enum {
+// 	AUX_DATA_HASH_BUILDER_INIT = 100,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT = 200,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT = 210,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY = 211,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY = 212,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS = 213,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE = 214,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE = 220,
+// 	AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS = 300,
+// 	AUX_DATA_HASH_BUILDER_FINISHED = 400,
+// } aux_data_hash_builder_state_t;
 
-typedef struct {
-	struct {
-		blake2b_256_context_t payloadHash;
-	} catalystRegistrationData;
+// typedef struct {
+// 	struct {
+// 		blake2b_256_context_t payloadHash;
+// 	} catalystRegistrationData;
 
-	aux_data_hash_builder_state_t state;
-	blake2b_256_context_t auxDataHash;
-} aux_data_hash_builder_t;
+// 	aux_data_hash_builder_state_t state;
+// 	blake2b_256_context_t auxDataHash;
+// } aux_data_hash_builder_t;
 
 
-void auxDataHashBuilder_init(
-        aux_data_hash_builder_t* builder
-);
+// void auxDataHashBuilder_init(
+//         aux_data_hash_builder_t* builder
+// );
 
-void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder);
-void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder);
-void auxDataHashBuilder_catalystRegistration_addVotingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
-);
-void auxDataHashBuilder_catalystRegistration_addStakingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
-);
-void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* addressBuffer, size_t addressSize
-);
-void auxDataHashBuilder_catalystRegistration_addNonce(aux_data_hash_builder_t* builder, uint64_t nonce);
-void auxDataHashBuilder_catalystRegistration_finalizePayload(
-        aux_data_hash_builder_t* builder,
-        uint8_t* outBuffer, size_t outSize
-);
+// void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder);
+// void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder);
+// void auxDataHashBuilder_catalystRegistration_addVotingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
+// );
+// void auxDataHashBuilder_catalystRegistration_addStakingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
+// );
+// void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* addressBuffer, size_t addressSize
+// );
+// void auxDataHashBuilder_catalystRegistration_addNonce(aux_data_hash_builder_t* builder, uint64_t nonce);
+// void auxDataHashBuilder_catalystRegistration_finalizePayload(
+//         aux_data_hash_builder_t* builder,
+//         uint8_t* outBuffer, size_t outSize
+// );
 
-void auxDataHashBuilder_catalystRegistration_addSignature(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* signatureBuffer, size_t signatureSize
-);
+// void auxDataHashBuilder_catalystRegistration_addSignature(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* signatureBuffer, size_t signatureSize
+// );
 
-void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(aux_data_hash_builder_t* builder);
+// void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(aux_data_hash_builder_t* builder);
 
-void auxDataHashBuilder_finalize(
-        aux_data_hash_builder_t* builder,
-        uint8_t* outBuffer, size_t outSize
-);
+// void auxDataHashBuilder_finalize(
+//         aux_data_hash_builder_t* builder,
+//         uint8_t* outBuffer, size_t outSize
+// );
 
-#ifdef DEVEL
-void run_auxDataHashBuilder_test();
-#endif // DEVEL
+// #ifdef DEVEL
+// void run_auxDataHashBuilder_test();
+// #endif // DEVEL
 
-#endif // H_CARDANO_APP_AUX_DATA_HASH_BUILDER
+// #endif // H_CARDANO_APP_AUX_DATA_HASH_BUILDER
diff --git a/src/auxDataHashBuilder_test.c b/src/auxDataHashBuilder_test.c
index f402f04..2f874a9 100644
--- a/src/auxDataHashBuilder_test.c
+++ b/src/auxDataHashBuilder_test.c
@@ -1,96 +1,96 @@
-#ifdef DEVEL
-
-#include "auxDataHashBuilder.h"
-#include "cardano.h"
-#include "hexUtils.h"
-#include "textUtils.h"
-#include "testUtils.h"
-
-
-static const char* votingKey = "3B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7";
-static const char* stakingKey = "BC65BE1B0B9D7531778A1317C2AA6DE936963C3F9AC7D5EE9E9EDA25E0C97C5E";
-static const char* votingRewardsAddress = "0180F9E2C88E6C817008F3A812ED889B4A4DA8E0BD103F86E7335422AA122A946B9AD3D2DDF029D3A828F0468AECE76895F15C9EFBD69B4277";
-static uint64_t nonce = 22634813;
-
-static const char* catalystRegistrationSignature = "0EA4A424522DD485F16466CD5A754F3C8DBD4D1976C912624E3465C540B1D0776C92633FC64BE057F947AAC561012FE55ACD3C54EF7BECE0DA0B90CF02DC760D";
-
-static const char* expectedCatalystVotingRegistrationPayloadHashHex = "2EEA6A5168066BDA411F80BE10B50646378616C3414C711A61D363C7879B5CBC";
-static const char* expectedAuxDataHashHex = "07cdec3a795626019739f275582433eabe32da80f82aeb74e4916b547c01a589";
-
-void run_auxDataHashBuilder_test()
-{
-	PRINTF("auxDataHashBuilder test\n");
-	aux_data_hash_builder_t builder;
-
-	auxDataHashBuilder_init(&builder);
-	auxDataHashBuilder_catalystRegistration_enter(&builder);
-	auxDataHashBuilder_catalystRegistration_enterPayload(&builder);
-
-	{
-		uint8_t tmp[32] = {0};
-		size_t tmpSize = decode_hex(votingKey, tmp, SIZEOF(tmp));
-		auxDataHashBuilder_catalystRegistration_addVotingKey(
-		        &builder,
-		        tmp, tmpSize
-		);
-	}
-
-	{
-		uint8_t tmp[32] = {0};
-		size_t tmpSize = decode_hex(stakingKey, tmp, SIZEOF(tmp));
-		auxDataHashBuilder_catalystRegistration_addStakingKey(
-		        &builder,
-		        tmp, tmpSize
-		);
-	}
-
-	{
-		uint8_t tmp[57] = {0};
-		size_t tmpSize = decode_hex(votingRewardsAddress, tmp, SIZEOF(tmp));
-		auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
-		        &builder,
-		        tmp, tmpSize
-		);
-	}
-
-	auxDataHashBuilder_catalystRegistration_addNonce(&builder, nonce);
-
-	{
-		uint8_t result[AUX_DATA_HASH_LENGTH] = {0};
-		auxDataHashBuilder_catalystRegistration_finalizePayload(&builder, result, SIZEOF(result));
-
-		uint8_t expected[AUX_DATA_HASH_LENGTH] = {0};
-		decode_hex(expectedCatalystVotingRegistrationPayloadHashHex, expected, SIZEOF(expected));
-
-		PRINTF("Catalyst registration payload hash hex\n");
-		PRINTF("%.*h\n", 32, result);
-
-		EXPECT_EQ_BYTES(result, expected, 32);
-	}
-
-	{
-		uint8_t tmp[64] = {0};
-		size_t tmpSize = decode_hex(catalystRegistrationSignature, tmp, SIZEOF(tmp));
-		auxDataHashBuilder_catalystRegistration_addSignature(
-		        &builder,
-		        tmp, tmpSize
-		);
-	}
-
-	auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(&builder);
-
-	{
-		uint8_t result[AUX_DATA_HASH_LENGTH] = {0};
-		auxDataHashBuilder_finalize(&builder, result, SIZEOF(result));
-
-		uint8_t expected[AUX_DATA_HASH_LENGTH] = {0};
-		decode_hex(expectedAuxDataHashHex, expected, SIZEOF(expected));
-
-		PRINTF("Transaction auxiliary data hash hex\n");
-		PRINTF("%.*h\n", 32, result);
-
-		EXPECT_EQ_BYTES(result, expected, 32);
-	}
-}
-
-#endif // DEVEL
+// #ifdef DEVEL
+
+// #include "auxDataHashBuilder.h"
+// #include "cardano.h"
+// #include "hexUtils.h"
+// #include "textUtils.h"
+// #include "testUtils.h"
+
+
+// static const char* votingKey = "3B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7";
+// static const char* stakingKey = "BC65BE1B0B9D7531778A1317C2AA6DE936963C3F9AC7D5EE9E9EDA25E0C97C5E";
+// static const char* votingRewardsAddress = "0180F9E2C88E6C817008F3A812ED889B4A4DA8E0BD103F86E7335422AA122A946B9AD3D2DDF029D3A828F0468AECE76895F15C9EFBD69B4277";
+// static uint64_t nonce = 22634813;
+
+// static const char* catalystRegistrationSignature = "0EA4A424522DD485F16466CD5A754F3C8DBD4D1976C912624E3465C540B1D0776C92633FC64BE057F947AAC561012FE55ACD3C54EF7BECE0DA0B90CF02DC760D";
+
+// static const char* expectedCatalystVotingRegistrationPayloadHashHex = "2EEA6A5168066BDA411F80BE10B50646378616C3414C711A61D363C7879B5CBC";
+// static const char* expectedAuxDataHashHex = "07cdec3a795626019739f275582433eabe32da80f82aeb74e4916b547c01a589";
+
+// void run_auxDataHashBuilder_test()
+// {
+// 	PRINTF("auxDataHashBuilder test\n");
+// 	aux_data_hash_builder_t builder;
+
+// 	auxDataHashBuilder_init(&builder);
+// 	auxDataHashBuilder_catalystRegistration_enter(&builder);
+// 	auxDataHashBuilder_catalystRegistration_enterPayload(&builder);
+
+// 	{
+// 		uint8_t tmp[32] = {0};
+// 		size_t tmpSize = decode_hex(votingKey, tmp, SIZEOF(tmp));
+// 		auxDataHashBuilder_catalystRegistration_addVotingKey(
+// 		        &builder,
+// 		        tmp, tmpSize
+// 		);
+// 	}
+
+// 	{
+// 		uint8_t tmp[32] = {0};
+// 		size_t tmpSize = decode_hex(stakingKey, tmp, SIZEOF(tmp));
+// 		auxDataHashBuilder_catalystRegistration_addStakingKey(
+// 		        &builder,
+// 		        tmp, tmpSize
+// 		);
+// 	}
+
+// 	{
+// 		uint8_t tmp[57] = {0};
+// 		size_t tmpSize = decode_hex(votingRewardsAddress, tmp, SIZEOF(tmp));
+// 		auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
+// 		        &builder,
+// 		        tmp, tmpSize
+// 		);
+// 	}
+
+// 	auxDataHashBuilder_catalystRegistration_addNonce(&builder, nonce);
+
+// 	{
+// 		uint8_t result[AUX_DATA_HASH_LENGTH] = {0};
+// 		auxDataHashBuilder_catalystRegistration_finalizePayload(&builder, result, SIZEOF(result));
+
+// 		uint8_t expected[AUX_DATA_HASH_LENGTH] = {0};
+// 		decode_hex(expectedCatalystVotingRegistrationPayloadHashHex, expected, SIZEOF(expected));
+
+// 		PRINTF("Catalyst registration payload hash hex\n");
+// 		PRINTF("%.*h\n", 32, result);
+
+// 		EXPECT_EQ_BYTES(result, expected, 32);
+// 	}
+
+// 	{
+// 		uint8_t tmp[64] = {0};
+// 		size_t tmpSize = decode_hex(catalystRegistrationSignature, tmp, SIZEOF(tmp));
+// 		auxDataHashBuilder_catalystRegistration_addSignature(
+// 		        &builder,
+// 		        tmp, tmpSize
+// 		);
+// 	}
+
+// 	auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(&builder);
+
+// 	{
+// 		uint8_t result[AUX_DATA_HASH_LENGTH] = {0};
+// 		auxDataHashBuilder_finalize(&builder, result, SIZEOF(result));
+
+// 		uint8_t expected[AUX_DATA_HASH_LENGTH] = {0};
+// 		decode_hex(expectedAuxDataHashHex, expected, SIZEOF(expected));
+
+// 		PRINTF("Transaction auxiliary data hash hex\n");
+// 		PRINTF("%.*h\n", 32, result);
+
+// 		EXPECT_EQ_BYTES(result, expected, 32);
+// 	}
+// }
+
+// #endif // DEVEL
diff --git a/src/bip44.c b/src/bip44.c
index 8099ac0..954c465 100644
--- a/src/bip44.c
+++ b/src/bip44.c
@@ -11,8 +11,8 @@ static const uint32_t CARDANO_CHAIN_STAKING_KEY = 2;
 static const uint32_t MAX_REASONABLE_ACCOUNT = 100;
 static const uint32_t MAX_REASONABLE_ADDRESS = 1000000;
 
-static const uint32_t MAX_REASONABLE_COLD_KEY_INDEX = 1000000;
-static const uint32_t MAX_REASONABLE_MINT_POLICY_INDEX = 1000000;
+// static const uint32_t MAX_REASONABLE_COLD_KEY_INDEX = 1000000;
+// static const uint32_t MAX_REASONABLE_MINT_POLICY_INDEX = 1000000;
 
 
 size_t bip44_parseFromWire(
@@ -80,37 +80,37 @@ bool bip44_hasOrdinaryWalletKeyPrefix(const bip44_path_t* pathSpec)
 }
 
 // /1854'/1815'
-bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
-	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MULTISIG | HARDENED_BIP32));
-	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
-	return true;
-#undef CHECK
-}
+// bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
+// 	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MULTISIG | HARDENED_BIP32));
+// 	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
+// 	return true;
+// #undef CHECK
+// }
 
 // /1855'/1815'
-bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
-	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MINT | HARDENED_BIP32));
-	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
-	return true;
-#undef CHECK
-}
+// bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
+// 	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MINT | HARDENED_BIP32));
+// 	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
+// 	return true;
+// #undef CHECK
+// }
 
 // /1853'/1815'
-bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
-	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_POOL_COLD_KEY | HARDENED_BIP32));
-	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
-	return true;
-#undef CHECK
-}
+// bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
+// 	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_POOL_COLD_KEY | HARDENED_BIP32));
+// 	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
+// 	return true;
+// #undef CHECK
+// }
 
 // Account
 
@@ -125,17 +125,17 @@ uint32_t bip44_getAccount(const bip44_path_t* pathSpec)
 	return pathSpec->path[BIP44_I_ACCOUNT];
 }
 
-uint32_t bip44_getMintPolicy(const bip44_path_t* pathSpec)
-{
-	ASSERT(pathSpec->length > BIP44_I_MINT_POLICY);
-	return pathSpec->path[BIP44_I_MINT_POLICY];
-}
+// uint32_t bip44_getMintPolicy(const bip44_path_t* pathSpec)
+// {
+// 	ASSERT(pathSpec->length > BIP44_I_MINT_POLICY);
+// 	return pathSpec->path[BIP44_I_MINT_POLICY];
+// }
 
-uint32_t bip44_getColdKeyIndex(const bip44_path_t* pathSpec)
-{
-	ASSERT(pathSpec->length > BIP44_I_POOL_COLD_KEY);
-	return pathSpec->path[BIP44_I_POOL_COLD_KEY];
-}
+// uint32_t bip44_getColdKeyIndex(const bip44_path_t* pathSpec)
+// {
+// 	ASSERT(pathSpec->length > BIP44_I_POOL_COLD_KEY);
+// 	return pathSpec->path[BIP44_I_POOL_COLD_KEY];
+// }
 
 bool bip44_hasReasonableAccount(const bip44_path_t* pathSpec)
 {
@@ -145,23 +145,23 @@ bool bip44_hasReasonableAccount(const bip44_path_t* pathSpec)
 	return unharden(account) <= MAX_REASONABLE_ACCOUNT;
 }
 
-bool bip44_hasReasonableMintPolicy(const bip44_path_t* pathSpec)
-{
-	if (!bip44_isMintKeyPath(pathSpec)) return false;
-	uint32_t mintPolicyIndex = bip44_getMintPolicy(pathSpec);
+// bool bip44_hasReasonableMintPolicy(const bip44_path_t* pathSpec)
+// {
+// 	if (!bip44_isMintKeyPath(pathSpec)) return false;
+// 	uint32_t mintPolicyIndex = bip44_getMintPolicy(pathSpec);
 
-	if (!isHardened(mintPolicyIndex)) return false;
-	return unharden(mintPolicyIndex) <= MAX_REASONABLE_MINT_POLICY_INDEX;
-}
+// 	if (!isHardened(mintPolicyIndex)) return false;
+// 	return unharden(mintPolicyIndex) <= MAX_REASONABLE_MINT_POLICY_INDEX;
+// }
 
-bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec)
-{
-	if (!bip44_isPoolColdKeyPath(pathSpec)) return false;
-	uint32_t coldKeyIndex = bip44_getColdKeyIndex(pathSpec);
+// bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec)
+// {
+// 	if (!bip44_isPoolColdKeyPath(pathSpec)) return false;
+// 	uint32_t coldKeyIndex = bip44_getColdKeyIndex(pathSpec);
 
-	if (!isHardened(coldKeyIndex)) return false;
-	return unharden(coldKeyIndex) <= MAX_REASONABLE_COLD_KEY_INDEX;
-}
+// 	if (!isHardened(coldKeyIndex)) return false;
+// 	return unharden(coldKeyIndex) <= MAX_REASONABLE_COLD_KEY_INDEX;
+// }
 
 // ChainType
 
@@ -212,12 +212,12 @@ bool bip44_isOrdinarySpendingKeyPath(const bip44_path_t* pathSpec)
 	       bip44_containsAddress(pathSpec);
 }
 
-bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec)
-{
-	return bip44_hasMultisigWalletKeyPrefix(pathSpec) &&
-	       bip44_hasValidChainTypeForAddress(pathSpec) &&
-	       bip44_containsAddress(pathSpec);
-}
+// bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec)
+// {
+// 	return bip44_hasMultisigWalletKeyPrefix(pathSpec) &&
+// 	       bip44_hasValidChainTypeForAddress(pathSpec) &&
+// 	       bip44_containsAddress(pathSpec);
+// }
 
 // staking keys (one per account, should end with /2/0 after account)
 bool bip44_isOrdinaryStakingKeyPath(const bip44_path_t* pathSpec)
@@ -233,38 +233,38 @@ bool bip44_isOrdinaryStakingKeyPath(const bip44_path_t* pathSpec)
 }
 
 // multisig staking keys
-bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec)
-{
-	if (!bip44_containsAddress(pathSpec)) return false;
-	if (bip44_containsMoreThanAddress(pathSpec)) return false;
-	if (!bip44_hasMultisigWalletKeyPrefix(pathSpec)) return false;
-
-	const uint32_t chainType = bip44_getChainTypeValue(pathSpec);
-	if (chainType != CARDANO_CHAIN_STAKING_KEY) return false;
-
-	return true;
-}
-
-bool bip44_isMintKeyPath(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length == BIP44_I_MINT_POLICY + 1);
-	CHECK(bip44_hasMintKeyPrefix(pathSpec));
-	CHECK(pathSpec->path[BIP44_I_MINT_POLICY] >= HARDENED_BIP32);
-	return true;
-#undef CHECK
-}
-
-bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length == BIP44_I_POOL_COLD_KEY + 1);
-	CHECK(bip44_hasPoolColdKeyPrefix(pathSpec));
-	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY_USECASE] == 0 + HARDENED_BIP32);
-	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY] >= HARDENED_BIP32);
-	return true;
-#undef CHECK
-}
+// bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec)
+// {
+// 	if (!bip44_containsAddress(pathSpec)) return false;
+// 	if (bip44_containsMoreThanAddress(pathSpec)) return false;
+// 	if (!bip44_hasMultisigWalletKeyPrefix(pathSpec)) return false;
+
+// 	const uint32_t chainType = bip44_getChainTypeValue(pathSpec);
+// 	if (chainType != CARDANO_CHAIN_STAKING_KEY) return false;
+
+// 	return true;
+// }
+
+// bool bip44_isMintKeyPath(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length == BIP44_I_MINT_POLICY + 1);
+// 	CHECK(bip44_hasMintKeyPrefix(pathSpec));
+// 	CHECK(pathSpec->path[BIP44_I_MINT_POLICY] >= HARDENED_BIP32);
+// 	return true;
+// #undef CHECK
+// }
+
+// bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length == BIP44_I_POOL_COLD_KEY + 1);
+// 	CHECK(bip44_hasPoolColdKeyPrefix(pathSpec));
+// 	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY_USECASE] == 0 + HARDENED_BIP32);
+// 	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY] >= HARDENED_BIP32);
+// 	return true;
+// #undef CHECK
+// }
 
 bool bip44_containsMoreThanAddress(const bip44_path_t* pathSpec)
 {
@@ -362,46 +362,46 @@ static bip44_path_type_t bip44_classifyOrdinaryWalletPath(const bip44_path_t* pa
 	}
 }
 
-static bip44_path_type_t bip44_classifyMultisigWalletPath(const bip44_path_t* pathSpec)
-{
-	ASSERT(bip44_hasMultisigWalletKeyPrefix(pathSpec));
-
-	// account must be hardened
-	if (!bip44_containsAccount(pathSpec)) {
-		return PATH_INVALID;
-	}
-	if (!isHardened(bip44_getAccount(pathSpec))) {
-		return PATH_INVALID;
-	}
-
-	switch (pathSpec->length) {
-	case 3: {
-		return PATH_MULTISIG_ACCOUNT;
-	}
-	case 5: {
-		const uint8_t chainType = bip44_getChainTypeValue(pathSpec);
-		switch (chainType) {
-
-		case CARDANO_CHAIN_EXTERNAL:
-			if (isHardened(bip44_getAddressValue(pathSpec))) {
-				// address index must not be hardened (CIP 1854)
-				return PATH_INVALID;
-			}
-			return PATH_MULTISIG_SPENDING_KEY;
-
-		case CARDANO_CHAIN_STAKING_KEY:
-			return bip44_isMultisigStakingKeyPath(pathSpec) ?
-			       PATH_MULTISIG_STAKING_KEY :
-			       PATH_INVALID;
-
-		default:
-			return PATH_INVALID;
-		}
-	}
-	default:
-		return PATH_INVALID;
-	}
-}
+// static bip44_path_type_t bip44_classifyMultisigWalletPath(const bip44_path_t* pathSpec)
+// {
+// 	ASSERT(bip44_hasMultisigWalletKeyPrefix(pathSpec));
+
+// 	// account must be hardened
+// 	if (!bip44_containsAccount(pathSpec)) {
+// 		return PATH_INVALID;
+// 	}
+// 	if (!isHardened(bip44_getAccount(pathSpec))) {
+// 		return PATH_INVALID;
+// 	}
+
+// 	switch (pathSpec->length) {
+// 	case 3: {
+// 		return PATH_MULTISIG_ACCOUNT;
+// 	}
+// 	case 5: {
+// 		const uint8_t chainType = bip44_getChainTypeValue(pathSpec);
+// 		switch (chainType) {
+
+// 		case CARDANO_CHAIN_EXTERNAL:
+// 			if (isHardened(bip44_getAddressValue(pathSpec))) {
+// 				// address index must not be hardened (CIP 1854)
+// 				return PATH_INVALID;
+// 			}
+// 			return PATH_MULTISIG_SPENDING_KEY;
+
+// 		case CARDANO_CHAIN_STAKING_KEY:
+// 			return bip44_isMultisigStakingKeyPath(pathSpec) ?
+// 			       PATH_MULTISIG_STAKING_KEY :
+// 			       PATH_INVALID;
+
+// 		default:
+// 			return PATH_INVALID;
+// 		}
+// 	}
+// 	default:
+// 		return PATH_INVALID;
+// 	}
+// }
 
 bip44_path_type_t bip44_classifyPath(const bip44_path_t* pathSpec)
 {
@@ -409,25 +409,25 @@ bip44_path_type_t bip44_classifyPath(const bip44_path_t* pathSpec)
 		return bip44_classifyOrdinaryWalletPath(pathSpec);
 	}
 
-	if (bip44_hasMultisigWalletKeyPrefix(pathSpec)) {
-		return bip44_classifyMultisigWalletPath(pathSpec);
-	}
-
-	if (bip44_hasMintKeyPrefix(pathSpec)) {
-		if (bip44_isMintKeyPath(pathSpec)) {
-			return PATH_MINT_KEY;
-		} else {
-			return PATH_INVALID;
-		}
-	}
-
-	if (bip44_hasPoolColdKeyPrefix(pathSpec)) {
-		if (bip44_isPoolColdKeyPath(pathSpec)) {
-			return PATH_POOL_COLD_KEY;
-		} else {
-			return PATH_INVALID;
-		}
-	}
+	// if (bip44_hasMultisigWalletKeyPrefix(pathSpec)) {
+	// 	return bip44_classifyMultisigWalletPath(pathSpec);
+	// }
+
+	// if (bip44_hasMintKeyPrefix(pathSpec)) {
+	// 	if (bip44_isMintKeyPath(pathSpec)) {
+	// 		return PATH_MINT_KEY;
+	// 	} else {
+	// 		return PATH_INVALID;
+	// 	}
+	// }
+
+	// if (bip44_hasPoolColdKeyPrefix(pathSpec)) {
+	// 	if (bip44_isPoolColdKeyPath(pathSpec)) {
+	// 		return PATH_POOL_COLD_KEY;
+	// 	} else {
+	// 		return PATH_INVALID;
+	// 	}
+	// }
 
 	return PATH_INVALID;
 }
@@ -437,24 +437,24 @@ bool bip44_isPathReasonable(const bip44_path_t* pathSpec)
 	switch (bip44_classifyPath(pathSpec)) {
 
 	case PATH_ORDINARY_ACCOUNT:
-	case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_ACCOUNT:
 		return bip44_hasReasonableAccount(pathSpec);
 
 	case PATH_ORDINARY_SPENDING_KEY:
-	case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_SPENDING_KEY:
 		return bip44_hasReasonableAccount(pathSpec) && bip44_hasReasonableAddress(pathSpec);
 
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
 		// we are checking the 5th item too (to avoid breaking this code
 		// if more than 1 staking key per account is allowed in the future)
 		return bip44_hasReasonableAccount(pathSpec) && bip44_hasReasonableAddress(pathSpec);
 
-	case PATH_MINT_KEY:
-		return bip44_hasReasonableMintPolicy(pathSpec);
+	// case PATH_MINT_KEY:
+	// 	return bip44_hasReasonableMintPolicy(pathSpec);
 
-	case PATH_POOL_COLD_KEY:
-		return bip44_hasReasonablePoolColdKeyIndex(pathSpec);
+	// case PATH_POOL_COLD_KEY:
+	// 	return bip44_hasReasonablePoolColdKeyIndex(pathSpec);
 
 	default:
 		// we are not supposed to call this for invalid paths
diff --git a/src/bip44.h b/src/bip44.h
index daff51f..dfc9b13 100644
--- a/src/bip44.h
+++ b/src/bip44.h
@@ -16,11 +16,11 @@ typedef struct {
 
 static const uint32_t PURPOSE_BYRON = 44;
 static const uint32_t PURPOSE_SHELLEY = 1852;
-static const uint32_t PURPOSE_MULTISIG = 1854;
+// static const uint32_t PURPOSE_MULTISIG = 1854;
 
-static const uint32_t PURPOSE_MINT = 1855;
+// static const uint32_t PURPOSE_MINT = 1855;
 
-static const uint32_t PURPOSE_POOL_COLD_KEY = 1853;
+// static const uint32_t PURPOSE_POOL_COLD_KEY = 1853;
 
 static const uint32_t ADA_COIN_TYPE = 1815;
 
@@ -45,20 +45,20 @@ enum {
 	BIP44_I_REST = 5,
 
 	// mint keys https://cips.cardano.org/cips/cip1855/
-	BIP44_I_MINT_POLICY = 2,
+	// BIP44_I_MINT_POLICY = 2,
 
 	// pool cold keys https://cips.cardano.org/cips/cip1853/
-	BIP44_I_POOL_COLD_KEY_USECASE = 2,
-	BIP44_I_POOL_COLD_KEY = 3,
+	// BIP44_I_POOL_COLD_KEY_USECASE = 2,
+	// BIP44_I_POOL_COLD_KEY = 3,
 };
 
 
 bool bip44_hasByronPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasShelleyPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasOrdinaryWalletKeyPrefix(const bip44_path_t* pathSpec);
-bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec);
-bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec);
-bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec);
+// bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec);
+// bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec);
+// bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec);
 
 bool bip44_containsAccount(const bip44_path_t* pathSpec);
 uint32_t bip44_getAccount(const bip44_path_t* pathSpec);
@@ -68,18 +68,18 @@ bool bip44_containsChainType(const bip44_path_t* pathSpec);
 
 bool bip44_containsAddress(const bip44_path_t* pathSpec);
 bool bip44_isOrdinarySpendingKeyPath(const bip44_path_t* pathSpec);
-bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec);
 bool bip44_hasReasonableAddress(const bip44_path_t* pathSpec);
 
 bool bip44_isOrdinaryStakingKeyPath(const bip44_path_t* pathSpec);
-bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec);
 
 bool bip44_containsMoreThanAddress(const bip44_path_t* pathSpec);
 
-bool bip44_isMintKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_isMintKeyPath(const bip44_path_t* pathSpec);
 
-bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec);
-bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec);
+// bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec);
 
 bool isHardened(uint32_t value);
 uint32_t unharden(uint32_t value);
@@ -90,21 +90,21 @@ size_t bip44_printToStr(const bip44_path_t*, char* out, size_t outSize);
 typedef enum {
 	// hd wallet account
 	PATH_ORDINARY_ACCOUNT,
-	PATH_MULTISIG_ACCOUNT,
+	// PATH_MULTISIG_ACCOUNT,
 
 	// hd wallet address (payment part in shelley)
 	PATH_ORDINARY_SPENDING_KEY,
-	PATH_MULTISIG_SPENDING_KEY,
+	// PATH_MULTISIG_SPENDING_KEY,
 
 	// hd wallet reward adress, withdrawal witness, pool owner
 	PATH_ORDINARY_STAKING_KEY,
-	PATH_MULTISIG_STAKING_KEY,
+	// PATH_MULTISIG_STAKING_KEY,
 
 	// native token minting/burning
-	PATH_MINT_KEY,
+	// PATH_MINT_KEY,
 
 	// pool cold key in pool registrations and retirements
-	PATH_POOL_COLD_KEY,
+	// PATH_POOL_COLD_KEY,
 
 	// none of the above
 	PATH_INVALID,
diff --git a/src/cardano.h b/src/cardano.h
index a314f72..b1677e1 100644
--- a/src/cardano.h
+++ b/src/cardano.h
@@ -18,8 +18,8 @@ STATIC_ASSERT(LOVELACE_MAX_SUPPLY < LOVELACE_INVALID, "bad LOVELACE_INVALID");
 #define VRF_KEY_HASH_LENGTH 32
 #define TX_HASH_LENGTH 32
 #define AUX_DATA_HASH_LENGTH 32
-#define POOL_METADATA_HASH_LENGTH 32
-#define CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH 32
+// #define POOL_METADATA_HASH_LENGTH 32
+// #define CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH 32
 #define ED25519_SIGNATURE_LENGTH 64
 #define SCRIPT_HASH_LENGTH 28
 #define SCRIPT_DATA_HASH_LENGTH 32
@@ -91,14 +91,14 @@ typedef struct {
 
 // ==============================  CERTIFICATES  ==============================
 
-#define POOL_METADATA_URL_LENGTH_MAX 64
-#define DNS_NAME_SIZE_MAX 64
+// #define POOL_METADATA_URL_LENGTH_MAX 64
+// #define DNS_NAME_SIZE_MAX 64
 
-#define IPV4_SIZE 4
-#define IPV6_SIZE 16
+// #define IPV4_SIZE 4
+// #define IPV6_SIZE 16
 
 // see the calculation in ui_displayMarginScreen() in uiScreens.c
-#define MARGIN_DENOMINATOR_MAX 1000000000000000ul // 10^15
+// #define MARGIN_DENOMINATOR_MAX 1000000000000000ul // 10^15
 
 // there may be other types we do not support
 typedef enum {
@@ -116,38 +116,38 @@ typedef enum {
 	STAKE_CREDENTIAL_SCRIPT_HASH = 1,
 } stake_credential_type_t;
 
-typedef enum {
-	RELAY_SINGLE_HOST_IP = 0,
-	RELAY_SINGLE_HOST_NAME = 1,
-	RELAY_MULTIPLE_HOST_NAME = 2
-} relay_format_t;
+// typedef enum {
+// 	RELAY_SINGLE_HOST_IP = 0,
+// 	RELAY_SINGLE_HOST_NAME = 1,
+// 	RELAY_MULTIPLE_HOST_NAME = 2
+// } relay_format_t;
 
-typedef struct {
-	bool isNull;
-	uint8_t ip[IPV4_SIZE];
-} ipv4_t;
+// typedef struct {
+// 	bool isNull;
+// 	uint8_t ip[IPV4_SIZE];
+// } ipv4_t;
 
-typedef struct {
-	bool isNull;
-	uint8_t ip[IPV6_SIZE];
-} ipv6_t;
+// typedef struct {
+// 	bool isNull;
+// 	uint8_t ip[IPV6_SIZE];
+// } ipv6_t;
 
-typedef struct {
-	bool isNull;
-	uint16_t number;
-} ipport_t;
+// typedef struct {
+// 	bool isNull;
+// 	uint16_t number;
+// } ipport_t;
 
-typedef struct {
-	relay_format_t format;
+// typedef struct {
+// 	relay_format_t format;
 
-	ipport_t port;
+// 	ipport_t port;
 
-	ipv4_t ipv4;
-	ipv6_t ipv6;
+// 	ipv4_t ipv4;
+// 	ipv6_t ipv6;
 
-	size_t dnsNameSize;
-	uint8_t dnsName[DNS_NAME_SIZE_MAX];
-} pool_relay_t;
+// 	size_t dnsNameSize;
+// 	uint8_t dnsName[DNS_NAME_SIZE_MAX];
+// } pool_relay_t;
 
 // ==============================  NATIVE SCRIPTS  ==============================
 
diff --git a/src/deriveNativeScriptHash.c b/src/deriveNativeScriptHash.c
index f47ea19..91c192d 100644
--- a/src/deriveNativeScriptHash.c
+++ b/src/deriveNativeScriptHash.c
@@ -1,498 +1,498 @@
-#include "deriveNativeScriptHash.h"
-#include "state.h"
-#include "textUtils.h"
-#include "uiScreens.h"
-
-static ins_derive_native_script_hash_context_t* ctx = &(instructionState.deriveNativeScriptHashContext);
-
-// Helper functions
-
-#define TRACE_WITH_CTX(message, ...) TRACE(message "level = %u, remaining scripts = %u", ##__VA_ARGS__, ctx->level, ctx->complexScripts[ctx->level].remainingScripts)
-
-static inline bool areMoreScriptsExpected()
-{
-	// if the number of remaining scripts is not bigger than 0, then this request
-	// is invalid in the current context, as Ledger was not expecting another
-	// script to be parsed
-	return ctx->complexScripts[ctx->level].remainingScripts > 0;
-}
-
-static inline bool isComplexScriptFinished()
-{
-	return ctx->level > 0 && ctx->complexScripts[ctx->level].remainingScripts == 0;
-}
-
-static inline void complexScriptFinished()
-{
-	while (isComplexScriptFinished()) {
-		ASSERT(ctx->level > 0);
-		ctx->level--;
-
-		ASSERT(ctx->complexScripts[ctx->level].remainingScripts > 0);
-		ctx->complexScripts[ctx->level].remainingScripts--;
-
-		TRACE_WITH_CTX("complex script finished, ");
-	}
-}
-
-static inline void simpleScriptFinished()
-{
-	ASSERT(ctx->complexScripts[ctx->level].remainingScripts > 0);
-	ctx->complexScripts[ctx->level].remainingScripts--;
-
-	TRACE_WITH_CTX("simple script finished, ");
-
-	if (isComplexScriptFinished()) {
-		complexScriptFinished();
-	}
-}
-
-// UI
-typedef char* charPtr;
-const charPtr ui_native_script_header[7] = {"Script - key path", "Script - key", "Script - ALL", "Script - ANY", "Script - N of K", "Script - invalid before", "Script - invalid hereafter"};
-
-#define ASSERT_UI_SCRIPT_TYPE_SANITY() ASSERT(ctx->ui_scriptType >= UI_SCRIPT_PUBKEY_PATH && ctx->ui_scriptType <= UI_SCRIPT_INVALID_HEREAFTER)
-#define HEADER ((const char*)PIC(ui_native_script_header[ctx->ui_scriptType]))
-
-static uint8_t _getScriptLevelForPosition()
-{
-	// For complex scripts we reduce the current level by 1
-	// Because they already have the level increased by 1
-	uint8_t levelOffset = ctx->ui_scriptType == UI_SCRIPT_ALL
-	                      || ctx->ui_scriptType == UI_SCRIPT_ANY
-	                      || ctx->ui_scriptType == UI_SCRIPT_N_OF_K
-	                      ? 1 : 0;
-	ASSERT(levelOffset == 0 || ctx->level > 0);
-	return ctx->level - levelOffset;
-}
-
-static void deriveScriptHash_display_ui_position(uint8_t level, ui_callback_fn_t* callback)
-{
-	ASSERT_UI_SCRIPT_TYPE_SANITY();
-	ASSERT(level > 0);
-	TRACE();
-
-	// 10 - length of the leading prefix: "Position: "
-	// 11 - max length for the position information for one level: "x."
-	//      where x is 2^32-1
-	// 2  - the ending null byte + 1B for checking if all text has been printed
-	char positionDescription[10 + 11 * (MAX_SCRIPT_DEPTH - 1) + 2] = {0};
-	explicit_bzero(positionDescription, SIZEOF(positionDescription));
-	char* ptr = BEGIN(positionDescription);
-	char* end = END(positionDescription);
-
-	snprintf(ptr, (end - ptr), "Position: ");
-	// snprintf returns 0, https://github.com/LedgerHQ/nanos-secure-sdk/issues/28
-	// so we need to check the number of written characters by `strlen`
-	ptr += strlen(ptr);
-
-	for (size_t i = 1; i <= level; i++) {
-		ASSERT(i < MAX_SCRIPT_DEPTH);
-		uint32_t position = ctx->complexScripts[i].totalScripts - ctx->complexScripts[i].remainingScripts + 1;
-		STATIC_ASSERT(sizeof(position) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(position), "signed type for %u");
-		snprintf(ptr, (end - ptr), "%u.", position);
-		ASSERT(strlen(positionDescription) + 1 < SIZEOF(positionDescription));
-		ptr += strlen(ptr);
-	}
-
-	// remove any trailing '.'
-	ASSERT(ptr > BEGIN(positionDescription));
-	*(ptr - 1) = '\0';
-
-	ASSERT(strlen(positionDescription) + 1 < SIZEOF(positionDescription));
-
-	VALIDATE(uiPaginatedText_canFitStringIntoFullText(positionDescription), ERR_INVALID_DATA);
-
-	ui_displayPaginatedText(
-	        HEADER,
-	        positionDescription,
-	        callback
-	);
-}
-
-enum {
-	DISPLAY_UI_STEP_POSITION = 200,
-	DISPLAY_UI_STEP_SCRIPT_CONTENT,
-	DISPLAY_UI_STEP_RESPOND,
-	DISPLAY_UI_STEP_INVALID
-};
-
-static void deriveScriptHash_display_ui_runStep()
-{
-	TRACE("ui_step = %d", ctx->ui_step);
-	ASSERT_UI_SCRIPT_TYPE_SANITY();
-
-	ui_callback_fn_t* this_fn = deriveScriptHash_display_ui_runStep;
-	UI_STEP_BEGIN(ctx->ui_step, this_fn);
-
-	UI_STEP(DISPLAY_UI_STEP_POSITION) {
-		uint8_t level = _getScriptLevelForPosition();
-		if (level == 0) {
-			TRACE("Skip showing position");
-			UI_STEP_JUMP(DISPLAY_UI_STEP_SCRIPT_CONTENT);
-		}
-		deriveScriptHash_display_ui_position(level, this_fn);
-	}
-
-	UI_STEP(DISPLAY_UI_STEP_SCRIPT_CONTENT) {
-		TRACE("ui_scriptType = %d", ctx->ui_scriptType);
-		switch (ctx->ui_scriptType) {
-		case UI_SCRIPT_PUBKEY_PATH: {
-			ui_displayPathScreen(
-			        HEADER,
-			        &ctx->scriptContent.pubkeyPath,
-			        this_fn
-			);
-			break;
-		}
-		case UI_SCRIPT_PUBKEY_HASH: {
-			ui_displayBech32Screen(
-			        HEADER,
-			        "addr_shared_vkh",
-			        ctx->scriptContent.pubkeyHash,
-			        ADDRESS_KEY_HASH_LENGTH,
-			        this_fn
-			);
-			break;
-		}
-		case UI_SCRIPT_ALL:
-		case UI_SCRIPT_ANY: {
-			// max possible length 35: "Contains n nested scripts."
-			// where n is 2^32-1
-			char text[37] = {0};
-			explicit_bzero(text, SIZEOF(text));
-			STATIC_ASSERT(sizeof(ctx->complexScripts[ctx->level].remainingScripts) <= sizeof(unsigned), "oversized type for %u");
-			STATIC_ASSERT(!IS_SIGNED(ctx->complexScripts[ctx->level].remainingScripts), "signed type for %u");
-			snprintf(text, SIZEOF(text), "Contains %u nested scripts.", ctx->complexScripts[ctx->level].remainingScripts);
-			// make sure all the information is displayed to the user
-			ASSERT(strlen(text) + 1 < SIZEOF(text));
-
-			ui_displayPaginatedText(
-			        HEADER,
-			        text,
-			        this_fn
-			);
-			break;
-		}
-		case UI_SCRIPT_N_OF_K: {
-			// max possible length 85: "Requires n out of k signatures. Contains k nested scripts."
-			// where n and k is 2^32-1
-			char text[87] = {0};
-			explicit_bzero(text, SIZEOF(text));
-			STATIC_ASSERT(sizeof(ctx->scriptContent.requiredScripts) <= sizeof(unsigned), "oversized type for %u");
-			STATIC_ASSERT(!IS_SIGNED(ctx->scriptContent.requiredScripts), "signed type for %u");
-			STATIC_ASSERT(sizeof(ctx->complexScripts[ctx->level].remainingScripts) <= sizeof(unsigned), "oversized type for %u");
-			STATIC_ASSERT(!IS_SIGNED(ctx->complexScripts[ctx->level].remainingScripts), "signed type for %u");
-			snprintf(text, SIZEOF(text), "Requires %u out of %u signatures. Contains %u nested scripts", ctx->scriptContent.requiredScripts, ctx->complexScripts[ctx->level].remainingScripts, ctx->complexScripts[ctx->level].remainingScripts);
-			// make sure all the information is displayed to the user
-			ASSERT(strlen(text) + 1 < SIZEOF(text));
-
-			ui_displayPaginatedText(
-			        HEADER,
-			        text,
-			        this_fn
-			);
-			break;
-		}
-		case UI_SCRIPT_INVALID_BEFORE:
-		case UI_SCRIPT_INVALID_HEREAFTER: {
-			ui_displayUint64Screen(
-			        HEADER,
-			        ctx->scriptContent.timelock,
-			        this_fn
-			);
-			break;
-		}
-		default:
-			THROW(ERR_INVALID_STATE);
-		}
-	}
-
-	UI_STEP(DISPLAY_UI_STEP_RESPOND) {
-		io_send_buf(SUCCESS, NULL, 0);
-		ui_displayBusy(); // displays dots, called after I/O to avoid freezing
-	}
-
-	UI_STEP_END(DISPLAY_UI_STEP_INVALID);
-}
-#undef HEADER
-#undef ASSERT_UI_SCRIPT_TYPE_SANITY
-
-#define UI_DISPLAY_SCRIPT(UI_TYPE) {\
-		ctx->ui_scriptType = UI_TYPE;\
-		ctx->ui_step = DISPLAY_UI_STEP_POSITION;\
-		deriveScriptHash_display_ui_runStep();\
-	}
-
-// Start complex native script
-
-static void deriveNativeScriptHash_handleAll(read_view_t* view)
-{
-	TRACE_WITH_CTX("");
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	nativeScriptHashBuilder_startComplexScript_all(&ctx->hashBuilder, ctx->complexScripts[ctx->level].remainingScripts);
-
-	UI_DISPLAY_SCRIPT(UI_SCRIPT_ALL);
-}
-
-static void deriveNativeScriptHash_handleAny(read_view_t* view)
-{
-	TRACE_WITH_CTX("");
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	nativeScriptHashBuilder_startComplexScript_any(&ctx->hashBuilder, ctx->complexScripts[ctx->level].remainingScripts);
-
-	UI_DISPLAY_SCRIPT(UI_SCRIPT_ANY);
-}
-
-static void deriveNativeScriptHash_handleNofK(read_view_t* view)
-{
-	// parse data
-	ctx->scriptContent.requiredScripts = parse_u4be(view);
-	TRACE_WITH_CTX("required scripts = %u, ", ctx->scriptContent.requiredScripts);
-
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	// validate that the received requiredScripts count makes sense
-	VALIDATE(ctx->complexScripts[ctx->level].remainingScripts >= ctx->scriptContent.requiredScripts, ERR_INVALID_DATA);
-
-	nativeScriptHashBuilder_startComplexScript_n_of_k(&ctx->hashBuilder, ctx->scriptContent.requiredScripts, ctx->complexScripts[ctx->level].remainingScripts);
-
-	UI_DISPLAY_SCRIPT(UI_SCRIPT_N_OF_K);
-}
-
-static void deriveNativeScriptHash_handleComplexScriptStart(read_view_t* view)
-{
-	VALIDATE(areMoreScriptsExpected(), ERR_INVALID_STATE);
-
-	// check if we can increase the level without breaking the MAX_SCRIPT_DEPTH constraint
-	VALIDATE(ctx->level + 1 < MAX_SCRIPT_DEPTH, ERR_INVALID_DATA);
-	ctx->level++;
-
-	// the nativeScriptType is validated below, in the switch statement
-	uint8_t nativeScriptType = parse_u1be(view);
-	TRACE("native complex script type = %u", nativeScriptType);
-
-	ctx->complexScripts[ctx->level].remainingScripts = parse_u4be(view);
-	ctx->complexScripts[ctx->level].totalScripts = ctx->complexScripts[ctx->level].remainingScripts;
-
-	// these handlers might read additional data from the view
-	switch (nativeScriptType) {
-#define  CASE(TYPE, HANDLER) case TYPE: HANDLER(view); break;
-		CASE(NATIVE_SCRIPT_ALL, deriveNativeScriptHash_handleAll);
-		CASE(NATIVE_SCRIPT_ANY, deriveNativeScriptHash_handleAny);
-		CASE(NATIVE_SCRIPT_N_OF_K, deriveNativeScriptHash_handleNofK);
-#undef   CASE
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-
-	if (isComplexScriptFinished()) {
-		complexScriptFinished();
-	}
-}
-
-// Simple native scripts
-
-static void deriveNativeScriptHash_handleDeviceOwnedPubkey(read_view_t* view)
-{
-	view_skipBytes(view, bip44_parseFromWire(&ctx->scriptContent.pubkeyPath, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
-	TRACE("pubkey given by path:");
-	BIP44_PRINTF(&ctx->scriptContent.pubkeyPath);
-	PRINTF("\n");
-
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	uint8_t pubkeyHash[ADDRESS_KEY_HASH_LENGTH] = {0};
-	bip44_pathToKeyHash(&ctx->scriptContent.pubkeyPath, pubkeyHash, ADDRESS_KEY_HASH_LENGTH);
-	nativeScriptHashBuilder_addScript_pubkey(&ctx->hashBuilder, pubkeyHash, SIZEOF(pubkeyHash));
-
-	UI_DISPLAY_SCRIPT(UI_SCRIPT_PUBKEY_PATH);
-}
-
-static void deriveNativeScriptHash_handleThirdPartyPubkey(read_view_t* view)
-{
-	STATIC_ASSERT(SIZEOF(ctx->scriptContent.pubkeyHash) == ADDRESS_KEY_HASH_LENGTH, "incorrect key hash size in script");
-	view_parseBuffer(ctx->scriptContent.pubkeyHash, view, ADDRESS_KEY_HASH_LENGTH);
-	TRACE_BUFFER(ctx->scriptContent.pubkeyHash, ADDRESS_KEY_HASH_LENGTH);
-
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	nativeScriptHashBuilder_addScript_pubkey(&ctx->hashBuilder, ctx->scriptContent.pubkeyHash, SIZEOF(ctx->scriptContent.pubkeyHash));
-
-	UI_DISPLAY_SCRIPT(UI_SCRIPT_PUBKEY_HASH);
-}
-
-static void deriveNativeScriptHash_handlePubkey(read_view_t* view)
-{
-	uint8_t pubkeyType = parse_u1be(view);
-	TRACE("pubkey type = %u", pubkeyType);
-
-	switch (pubkeyType) {
-	case KEY_REFERENCE_PATH:
-		deriveNativeScriptHash_handleDeviceOwnedPubkey(view);
-		return;
-	case KEY_REFERENCE_HASH:
-		deriveNativeScriptHash_handleThirdPartyPubkey(view);
-		return;
-	// any other value for the pubkey type is invalid
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-}
-
-static void deriveNativeScriptHash_handleInvalidBefore(read_view_t* view)
-{
-	ctx->scriptContent.timelock = parse_u8be(view);
-	TRACE("invalid_before timelock");
-	TRACE_UINT64(ctx->scriptContent.timelock);
-
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	nativeScriptHashBuilder_addScript_invalidBefore(&ctx->hashBuilder, ctx->scriptContent.timelock);
-
-	UI_DISPLAY_SCRIPT(UI_SCRIPT_INVALID_BEFORE);
-}
-
-static void deriveNativeScriptHash_handleInvalidHereafter(read_view_t* view)
-{
-	ctx->scriptContent.timelock = parse_u8be(view);
-	TRACE("invalid_hereafter timelock");
-	TRACE_UINT64(ctx->scriptContent.timelock);
-
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	nativeScriptHashBuilder_addScript_invalidHereafter(&ctx->hashBuilder, ctx->scriptContent.timelock);
-
-	UI_DISPLAY_SCRIPT(UI_SCRIPT_INVALID_HEREAFTER);
-}
-
-#undef UI_DISPLAY_SCRIPT
-
-static void deriveNativeScriptHash_handleSimpleScript(read_view_t* view)
-{
-	VALIDATE(areMoreScriptsExpected(), ERR_INVALID_STATE);
-
-	uint8_t nativeScriptType = parse_u1be(view);
-	TRACE("native simple script type = %u", nativeScriptType);
-
-	// parse data
-	switch (nativeScriptType) {
-#define  CASE(TYPE, HANDLER) case TYPE: HANDLER(view); break;
-		CASE(NATIVE_SCRIPT_PUBKEY, deriveNativeScriptHash_handlePubkey);
-		CASE(NATIVE_SCRIPT_INVALID_BEFORE, deriveNativeScriptHash_handleInvalidBefore);
-		CASE(NATIVE_SCRIPT_INVALID_HEREAFTER, deriveNativeScriptHash_handleInvalidHereafter);
-#undef   CASE
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-
-	simpleScriptFinished();
-}
-
-// Whole native script finish
-
-typedef enum {
-	DISPLAY_NATIVE_SCRIPT_HASH_BECH32 = 1,
-	DISPLAY_NATIVE_SCRIPT_HASH_POLICY_ID = 2,
-} display_format;
-
-static void deriveNativeScriptHash_displayNativeScriptHash_callback()
-{
-	io_send_buf(SUCCESS, ctx->scriptHashBuffer, SCRIPT_HASH_LENGTH);
-	ui_idle();
-}
-
-static void deriveNativeScriptHash_displayNativeScriptHash_bech32()
-{
-	ui_displayBech32Screen(
-	        "Script hash",
-	        "script",
-	        ctx->scriptHashBuffer,
-	        SCRIPT_HASH_LENGTH,
-	        deriveNativeScriptHash_displayNativeScriptHash_callback
-	);
-}
-
-static void deriveNativeScriptHash_displayNativeScriptHash_policyId()
-{
-	ui_displayHexBufferScreen(
-	        "Policy ID",
-	        ctx->scriptHashBuffer,
-	        SCRIPT_HASH_LENGTH,
-	        deriveNativeScriptHash_displayNativeScriptHash_callback
-	);
-}
-
-static void deriveNativeScriptHash_handleWholeNativeScriptFinish(read_view_t* view)
-{
-	// we finish only if there are no more scripts to be processed
-	VALIDATE(ctx->level == 0 && ctx->complexScripts[0].remainingScripts == 0, ERR_INVALID_STATE);
-
-	uint8_t displayFormat = parse_u1be(view);
-	TRACE("whole native script received, display format = %u", displayFormat);
-
-	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
-
-	switch (displayFormat) {
-#define  CASE(FORMAT, DISPLAY_FN) case FORMAT: nativeScriptHashBuilder_finalize(&ctx->hashBuilder, ctx->scriptHashBuffer, SCRIPT_HASH_LENGTH); DISPLAY_FN(); break;
-		CASE(DISPLAY_NATIVE_SCRIPT_HASH_BECH32, deriveNativeScriptHash_displayNativeScriptHash_bech32);
-		CASE(DISPLAY_NATIVE_SCRIPT_HASH_POLICY_ID, deriveNativeScriptHash_displayNativeScriptHash_policyId);
-#undef	CASE
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-}
-
-typedef void subhandler_fn_t(read_view_t* view);
-
-enum {
-	STAGE_COMPLEX_SCRIPT_START = 0x01,
-	STAGE_ADD_SIMPLE_SCRIPT = 0x02,
-	STAGE_WHOLE_NATIVE_SCRIPT_FINISH = 0x03,
-};
-
-static subhandler_fn_t* lookup_subhandler(uint8_t p1)
-{
-	switch (p1) {
-#define  CASE(P1, HANDLER) case P1: return HANDLER;
-#define  DEFAULT(HANDLER)  default: return HANDLER;
-		CASE(STAGE_COMPLEX_SCRIPT_START, deriveNativeScriptHash_handleComplexScriptStart);
-		CASE(STAGE_ADD_SIMPLE_SCRIPT, deriveNativeScriptHash_handleSimpleScript);
-		CASE(STAGE_WHOLE_NATIVE_SCRIPT_FINISH, deriveNativeScriptHash_handleWholeNativeScriptFinish)
-		DEFAULT(NULL);
-#undef   CASE
-#undef   DEFAULT
-	}
-}
-
-void deriveNativeScriptHash_handleAPDU(
-        uint8_t p1,
-        uint8_t p2,
-        uint8_t *wireDataBuffer,
-        size_t wireDataSize,
-        bool isNewCall
-)
-{
-	TRACE("P1 = 0x%x, P2 = 0x%x, isNewCall = %u", p1, p2, isNewCall);
-	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
-	TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-	// initialize state
-	if (isNewCall) {
-		explicit_bzero(ctx, SIZEOF(*ctx));
-		ctx->level = 0;
-		ctx->complexScripts[ctx->level].remainingScripts = 1;
-		nativeScriptHashBuilder_init(&ctx->hashBuilder);
-	}
-
-	read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-	subhandler_fn_t* subhandler = lookup_subhandler(p1);
-	VALIDATE(subhandler != NULL, ERR_INVALID_REQUEST_PARAMETERS);
-	subhandler(&view);
-}
-
-#undef TRACE_WITH_CTX
+// #include "deriveNativeScriptHash.h"
+// #include "state.h"
+// #include "textUtils.h"
+// #include "uiScreens.h"
+
+// static ins_derive_native_script_hash_context_t* ctx = &(instructionState.deriveNativeScriptHashContext);
+
+// // Helper functions
+
+// #define TRACE_WITH_CTX(message, ...) TRACE(message "level = %u, remaining scripts = %u", ##__VA_ARGS__, ctx->level, ctx->complexScripts[ctx->level].remainingScripts)
+
+// static inline bool areMoreScriptsExpected()
+// {
+// 	// if the number of remaining scripts is not bigger than 0, then this request
+// 	// is invalid in the current context, as Ledger was not expecting another
+// 	// script to be parsed
+// 	return ctx->complexScripts[ctx->level].remainingScripts > 0;
+// }
+
+// static inline bool isComplexScriptFinished()
+// {
+// 	return ctx->level > 0 && ctx->complexScripts[ctx->level].remainingScripts == 0;
+// }
+
+// static inline void complexScriptFinished()
+// {
+// 	while (isComplexScriptFinished()) {
+// 		ASSERT(ctx->level > 0);
+// 		ctx->level--;
+
+// 		ASSERT(ctx->complexScripts[ctx->level].remainingScripts > 0);
+// 		ctx->complexScripts[ctx->level].remainingScripts--;
+
+// 		TRACE_WITH_CTX("complex script finished, ");
+// 	}
+// }
+
+// static inline void simpleScriptFinished()
+// {
+// 	ASSERT(ctx->complexScripts[ctx->level].remainingScripts > 0);
+// 	ctx->complexScripts[ctx->level].remainingScripts--;
+
+// 	TRACE_WITH_CTX("simple script finished, ");
+
+// 	if (isComplexScriptFinished()) {
+// 		complexScriptFinished();
+// 	}
+// }
+
+// // UI
+// typedef char* charPtr;
+// const charPtr ui_native_script_header[7] = {"Script - key path", "Script - key", "Script - ALL", "Script - ANY", "Script - N of K", "Script - invalid before", "Script - invalid hereafter"};
+
+// #define ASSERT_UI_SCRIPT_TYPE_SANITY() ASSERT(ctx->ui_scriptType >= UI_SCRIPT_PUBKEY_PATH && ctx->ui_scriptType <= UI_SCRIPT_INVALID_HEREAFTER)
+// #define HEADER ((const char*)PIC(ui_native_script_header[ctx->ui_scriptType]))
+
+// static uint8_t _getScriptLevelForPosition()
+// {
+// 	// For complex scripts we reduce the current level by 1
+// 	// Because they already have the level increased by 1
+// 	uint8_t levelOffset = ctx->ui_scriptType == UI_SCRIPT_ALL
+// 	                      || ctx->ui_scriptType == UI_SCRIPT_ANY
+// 	                      || ctx->ui_scriptType == UI_SCRIPT_N_OF_K
+// 	                      ? 1 : 0;
+// 	ASSERT(levelOffset == 0 || ctx->level > 0);
+// 	return ctx->level - levelOffset;
+// }
+
+// static void deriveScriptHash_display_ui_position(uint8_t level, ui_callback_fn_t* callback)
+// {
+// 	ASSERT_UI_SCRIPT_TYPE_SANITY();
+// 	ASSERT(level > 0);
+// 	TRACE();
+
+// 	// 10 - length of the leading prefix: "Position: "
+// 	// 11 - max length for the position information for one level: "x."
+// 	//      where x is 2^32-1
+// 	// 2  - the ending null byte + 1B for checking if all text has been printed
+// 	char positionDescription[10 + 11 * (MAX_SCRIPT_DEPTH - 1) + 2] = {0};
+// 	explicit_bzero(positionDescription, SIZEOF(positionDescription));
+// 	char* ptr = BEGIN(positionDescription);
+// 	char* end = END(positionDescription);
+
+// 	snprintf(ptr, (end - ptr), "Position: ");
+// 	// snprintf returns 0, https://github.com/LedgerHQ/nanos-secure-sdk/issues/28
+// 	// so we need to check the number of written characters by `strlen`
+// 	ptr += strlen(ptr);
+
+// 	for (size_t i = 1; i <= level; i++) {
+// 		ASSERT(i < MAX_SCRIPT_DEPTH);
+// 		uint32_t position = ctx->complexScripts[i].totalScripts - ctx->complexScripts[i].remainingScripts + 1;
+// 		STATIC_ASSERT(sizeof(position) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(position), "signed type for %u");
+// 		snprintf(ptr, (end - ptr), "%u.", position);
+// 		ASSERT(strlen(positionDescription) + 1 < SIZEOF(positionDescription));
+// 		ptr += strlen(ptr);
+// 	}
+
+// 	// remove any trailing '.'
+// 	ASSERT(ptr > BEGIN(positionDescription));
+// 	*(ptr - 1) = '\0';
+
+// 	ASSERT(strlen(positionDescription) + 1 < SIZEOF(positionDescription));
+
+// 	VALIDATE(uiPaginatedText_canFitStringIntoFullText(positionDescription), ERR_INVALID_DATA);
+
+// 	ui_displayPaginatedText(
+// 	        HEADER,
+// 	        positionDescription,
+// 	        callback
+// 	);
+// }
+
+// enum {
+// 	DISPLAY_UI_STEP_POSITION = 200,
+// 	DISPLAY_UI_STEP_SCRIPT_CONTENT,
+// 	DISPLAY_UI_STEP_RESPOND,
+// 	DISPLAY_UI_STEP_INVALID
+// };
+
+// static void deriveScriptHash_display_ui_runStep()
+// {
+// 	TRACE("ui_step = %d", ctx->ui_step);
+// 	ASSERT_UI_SCRIPT_TYPE_SANITY();
+
+// 	ui_callback_fn_t* this_fn = deriveScriptHash_display_ui_runStep;
+// 	UI_STEP_BEGIN(ctx->ui_step, this_fn);
+
+// 	UI_STEP(DISPLAY_UI_STEP_POSITION) {
+// 		uint8_t level = _getScriptLevelForPosition();
+// 		if (level == 0) {
+// 			TRACE("Skip showing position");
+// 			UI_STEP_JUMP(DISPLAY_UI_STEP_SCRIPT_CONTENT);
+// 		}
+// 		deriveScriptHash_display_ui_position(level, this_fn);
+// 	}
+
+// 	UI_STEP(DISPLAY_UI_STEP_SCRIPT_CONTENT) {
+// 		TRACE("ui_scriptType = %d", ctx->ui_scriptType);
+// 		switch (ctx->ui_scriptType) {
+// 		case UI_SCRIPT_PUBKEY_PATH: {
+// 			ui_displayPathScreen(
+// 			        HEADER,
+// 			        &ctx->scriptContent.pubkeyPath,
+// 			        this_fn
+// 			);
+// 			break;
+// 		}
+// 		case UI_SCRIPT_PUBKEY_HASH: {
+// 			ui_displayBech32Screen(
+// 			        HEADER,
+// 			        "addr_shared_vkh",
+// 			        ctx->scriptContent.pubkeyHash,
+// 			        ADDRESS_KEY_HASH_LENGTH,
+// 			        this_fn
+// 			);
+// 			break;
+// 		}
+// 		case UI_SCRIPT_ALL:
+// 		case UI_SCRIPT_ANY: {
+// 			// max possible length 35: "Contains n nested scripts."
+// 			// where n is 2^32-1
+// 			char text[37] = {0};
+// 			explicit_bzero(text, SIZEOF(text));
+// 			STATIC_ASSERT(sizeof(ctx->complexScripts[ctx->level].remainingScripts) <= sizeof(unsigned), "oversized type for %u");
+// 			STATIC_ASSERT(!IS_SIGNED(ctx->complexScripts[ctx->level].remainingScripts), "signed type for %u");
+// 			snprintf(text, SIZEOF(text), "Contains %u nested scripts.", ctx->complexScripts[ctx->level].remainingScripts);
+// 			// make sure all the information is displayed to the user
+// 			ASSERT(strlen(text) + 1 < SIZEOF(text));
+
+// 			ui_displayPaginatedText(
+// 			        HEADER,
+// 			        text,
+// 			        this_fn
+// 			);
+// 			break;
+// 		}
+// 		case UI_SCRIPT_N_OF_K: {
+// 			// max possible length 85: "Requires n out of k signatures. Contains k nested scripts."
+// 			// where n and k is 2^32-1
+// 			char text[87] = {0};
+// 			explicit_bzero(text, SIZEOF(text));
+// 			STATIC_ASSERT(sizeof(ctx->scriptContent.requiredScripts) <= sizeof(unsigned), "oversized type for %u");
+// 			STATIC_ASSERT(!IS_SIGNED(ctx->scriptContent.requiredScripts), "signed type for %u");
+// 			STATIC_ASSERT(sizeof(ctx->complexScripts[ctx->level].remainingScripts) <= sizeof(unsigned), "oversized type for %u");
+// 			STATIC_ASSERT(!IS_SIGNED(ctx->complexScripts[ctx->level].remainingScripts), "signed type for %u");
+// 			snprintf(text, SIZEOF(text), "Requires %u out of %u signatures. Contains %u nested scripts", ctx->scriptContent.requiredScripts, ctx->complexScripts[ctx->level].remainingScripts, ctx->complexScripts[ctx->level].remainingScripts);
+// 			// make sure all the information is displayed to the user
+// 			ASSERT(strlen(text) + 1 < SIZEOF(text));
+
+// 			ui_displayPaginatedText(
+// 			        HEADER,
+// 			        text,
+// 			        this_fn
+// 			);
+// 			break;
+// 		}
+// 		case UI_SCRIPT_INVALID_BEFORE:
+// 		case UI_SCRIPT_INVALID_HEREAFTER: {
+// 			ui_displayUint64Screen(
+// 			        HEADER,
+// 			        ctx->scriptContent.timelock,
+// 			        this_fn
+// 			);
+// 			break;
+// 		}
+// 		default:
+// 			THROW(ERR_INVALID_STATE);
+// 		}
+// 	}
+
+// 	UI_STEP(DISPLAY_UI_STEP_RESPOND) {
+// 		io_send_buf(SUCCESS, NULL, 0);
+// 		ui_displayBusy(); // displays dots, called after I/O to avoid freezing
+// 	}
+
+// 	UI_STEP_END(DISPLAY_UI_STEP_INVALID);
+// }
+// #undef HEADER
+// #undef ASSERT_UI_SCRIPT_TYPE_SANITY
+
+// #define UI_DISPLAY_SCRIPT(UI_TYPE) {\
+// 		ctx->ui_scriptType = UI_TYPE;\
+// 		ctx->ui_step = DISPLAY_UI_STEP_POSITION;\
+// 		deriveScriptHash_display_ui_runStep();\
+// 	}
+
+// // Start complex native script
+
+// static void deriveNativeScriptHash_handleAll(read_view_t* view)
+// {
+// 	TRACE_WITH_CTX("");
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	nativeScriptHashBuilder_startComplexScript_all(&ctx->hashBuilder, ctx->complexScripts[ctx->level].remainingScripts);
+
+// 	UI_DISPLAY_SCRIPT(UI_SCRIPT_ALL);
+// }
+
+// static void deriveNativeScriptHash_handleAny(read_view_t* view)
+// {
+// 	TRACE_WITH_CTX("");
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	nativeScriptHashBuilder_startComplexScript_any(&ctx->hashBuilder, ctx->complexScripts[ctx->level].remainingScripts);
+
+// 	UI_DISPLAY_SCRIPT(UI_SCRIPT_ANY);
+// }
+
+// static void deriveNativeScriptHash_handleNofK(read_view_t* view)
+// {
+// 	// parse data
+// 	ctx->scriptContent.requiredScripts = parse_u4be(view);
+// 	TRACE_WITH_CTX("required scripts = %u, ", ctx->scriptContent.requiredScripts);
+
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	// validate that the received requiredScripts count makes sense
+// 	VALIDATE(ctx->complexScripts[ctx->level].remainingScripts >= ctx->scriptContent.requiredScripts, ERR_INVALID_DATA);
+
+// 	nativeScriptHashBuilder_startComplexScript_n_of_k(&ctx->hashBuilder, ctx->scriptContent.requiredScripts, ctx->complexScripts[ctx->level].remainingScripts);
+
+// 	UI_DISPLAY_SCRIPT(UI_SCRIPT_N_OF_K);
+// }
+
+// static void deriveNativeScriptHash_handleComplexScriptStart(read_view_t* view)
+// {
+// 	VALIDATE(areMoreScriptsExpected(), ERR_INVALID_STATE);
+
+// 	// check if we can increase the level without breaking the MAX_SCRIPT_DEPTH constraint
+// 	VALIDATE(ctx->level + 1 < MAX_SCRIPT_DEPTH, ERR_INVALID_DATA);
+// 	ctx->level++;
+
+// 	// the nativeScriptType is validated below, in the switch statement
+// 	uint8_t nativeScriptType = parse_u1be(view);
+// 	TRACE("native complex script type = %u", nativeScriptType);
+
+// 	ctx->complexScripts[ctx->level].remainingScripts = parse_u4be(view);
+// 	ctx->complexScripts[ctx->level].totalScripts = ctx->complexScripts[ctx->level].remainingScripts;
+
+// 	// these handlers might read additional data from the view
+// 	switch (nativeScriptType) {
+// #define  CASE(TYPE, HANDLER) case TYPE: HANDLER(view); break;
+// 		CASE(NATIVE_SCRIPT_ALL, deriveNativeScriptHash_handleAll);
+// 		CASE(NATIVE_SCRIPT_ANY, deriveNativeScriptHash_handleAny);
+// 		CASE(NATIVE_SCRIPT_N_OF_K, deriveNativeScriptHash_handleNofK);
+// #undef   CASE
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+
+// 	if (isComplexScriptFinished()) {
+// 		complexScriptFinished();
+// 	}
+// }
+
+// // Simple native scripts
+
+// static void deriveNativeScriptHash_handleDeviceOwnedPubkey(read_view_t* view)
+// {
+// 	view_skipBytes(view, bip44_parseFromWire(&ctx->scriptContent.pubkeyPath, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
+// 	TRACE("pubkey given by path:");
+// 	BIP44_PRINTF(&ctx->scriptContent.pubkeyPath);
+// 	PRINTF("\n");
+
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	uint8_t pubkeyHash[ADDRESS_KEY_HASH_LENGTH] = {0};
+// 	bip44_pathToKeyHash(&ctx->scriptContent.pubkeyPath, pubkeyHash, ADDRESS_KEY_HASH_LENGTH);
+// 	nativeScriptHashBuilder_addScript_pubkey(&ctx->hashBuilder, pubkeyHash, SIZEOF(pubkeyHash));
+
+// 	UI_DISPLAY_SCRIPT(UI_SCRIPT_PUBKEY_PATH);
+// }
+
+// static void deriveNativeScriptHash_handleThirdPartyPubkey(read_view_t* view)
+// {
+// 	STATIC_ASSERT(SIZEOF(ctx->scriptContent.pubkeyHash) == ADDRESS_KEY_HASH_LENGTH, "incorrect key hash size in script");
+// 	view_parseBuffer(ctx->scriptContent.pubkeyHash, view, ADDRESS_KEY_HASH_LENGTH);
+// 	TRACE_BUFFER(ctx->scriptContent.pubkeyHash, ADDRESS_KEY_HASH_LENGTH);
+
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	nativeScriptHashBuilder_addScript_pubkey(&ctx->hashBuilder, ctx->scriptContent.pubkeyHash, SIZEOF(ctx->scriptContent.pubkeyHash));
+
+// 	UI_DISPLAY_SCRIPT(UI_SCRIPT_PUBKEY_HASH);
+// }
+
+// static void deriveNativeScriptHash_handlePubkey(read_view_t* view)
+// {
+// 	uint8_t pubkeyType = parse_u1be(view);
+// 	TRACE("pubkey type = %u", pubkeyType);
+
+// 	switch (pubkeyType) {
+// 	case KEY_REFERENCE_PATH:
+// 		deriveNativeScriptHash_handleDeviceOwnedPubkey(view);
+// 		return;
+// 	case KEY_REFERENCE_HASH:
+// 		deriveNativeScriptHash_handleThirdPartyPubkey(view);
+// 		return;
+// 	// any other value for the pubkey type is invalid
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+// }
+
+// static void deriveNativeScriptHash_handleInvalidBefore(read_view_t* view)
+// {
+// 	ctx->scriptContent.timelock = parse_u8be(view);
+// 	TRACE("invalid_before timelock");
+// 	TRACE_UINT64(ctx->scriptContent.timelock);
+
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	nativeScriptHashBuilder_addScript_invalidBefore(&ctx->hashBuilder, ctx->scriptContent.timelock);
+
+// 	UI_DISPLAY_SCRIPT(UI_SCRIPT_INVALID_BEFORE);
+// }
+
+// static void deriveNativeScriptHash_handleInvalidHereafter(read_view_t* view)
+// {
+// 	ctx->scriptContent.timelock = parse_u8be(view);
+// 	TRACE("invalid_hereafter timelock");
+// 	TRACE_UINT64(ctx->scriptContent.timelock);
+
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	nativeScriptHashBuilder_addScript_invalidHereafter(&ctx->hashBuilder, ctx->scriptContent.timelock);
+
+// 	UI_DISPLAY_SCRIPT(UI_SCRIPT_INVALID_HEREAFTER);
+// }
+
+// #undef UI_DISPLAY_SCRIPT
+
+// static void deriveNativeScriptHash_handleSimpleScript(read_view_t* view)
+// {
+// 	VALIDATE(areMoreScriptsExpected(), ERR_INVALID_STATE);
+
+// 	uint8_t nativeScriptType = parse_u1be(view);
+// 	TRACE("native simple script type = %u", nativeScriptType);
+
+// 	// parse data
+// 	switch (nativeScriptType) {
+// #define  CASE(TYPE, HANDLER) case TYPE: HANDLER(view); break;
+// 		CASE(NATIVE_SCRIPT_PUBKEY, deriveNativeScriptHash_handlePubkey);
+// 		CASE(NATIVE_SCRIPT_INVALID_BEFORE, deriveNativeScriptHash_handleInvalidBefore);
+// 		CASE(NATIVE_SCRIPT_INVALID_HEREAFTER, deriveNativeScriptHash_handleInvalidHereafter);
+// #undef   CASE
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+
+// 	simpleScriptFinished();
+// }
+
+// // Whole native script finish
+
+// typedef enum {
+// 	DISPLAY_NATIVE_SCRIPT_HASH_BECH32 = 1,
+// 	DISPLAY_NATIVE_SCRIPT_HASH_POLICY_ID = 2,
+// } display_format;
+
+// static void deriveNativeScriptHash_displayNativeScriptHash_callback()
+// {
+// 	io_send_buf(SUCCESS, ctx->scriptHashBuffer, SCRIPT_HASH_LENGTH);
+// 	ui_idle();
+// }
+
+// static void deriveNativeScriptHash_displayNativeScriptHash_bech32()
+// {
+// 	ui_displayBech32Screen(
+// 	        "Script hash",
+// 	        "script",
+// 	        ctx->scriptHashBuffer,
+// 	        SCRIPT_HASH_LENGTH,
+// 	        deriveNativeScriptHash_displayNativeScriptHash_callback
+// 	);
+// }
+
+// static void deriveNativeScriptHash_displayNativeScriptHash_policyId()
+// {
+// 	ui_displayHexBufferScreen(
+// 	        "Policy ID",
+// 	        ctx->scriptHashBuffer,
+// 	        SCRIPT_HASH_LENGTH,
+// 	        deriveNativeScriptHash_displayNativeScriptHash_callback
+// 	);
+// }
+
+// static void deriveNativeScriptHash_handleWholeNativeScriptFinish(read_view_t* view)
+// {
+// 	// we finish only if there are no more scripts to be processed
+// 	VALIDATE(ctx->level == 0 && ctx->complexScripts[0].remainingScripts == 0, ERR_INVALID_STATE);
+
+// 	uint8_t displayFormat = parse_u1be(view);
+// 	TRACE("whole native script received, display format = %u", displayFormat);
+
+// 	VALIDATE(view_remainingSize(view) == 0, ERR_INVALID_DATA);
+
+// 	switch (displayFormat) {
+// #define  CASE(FORMAT, DISPLAY_FN) case FORMAT: nativeScriptHashBuilder_finalize(&ctx->hashBuilder, ctx->scriptHashBuffer, SCRIPT_HASH_LENGTH); DISPLAY_FN(); break;
+// 		CASE(DISPLAY_NATIVE_SCRIPT_HASH_BECH32, deriveNativeScriptHash_displayNativeScriptHash_bech32);
+// 		CASE(DISPLAY_NATIVE_SCRIPT_HASH_POLICY_ID, deriveNativeScriptHash_displayNativeScriptHash_policyId);
+// #undef	CASE
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+// }
+
+// typedef void subhandler_fn_t(read_view_t* view);
+
+// enum {
+// 	STAGE_COMPLEX_SCRIPT_START = 0x01,
+// 	STAGE_ADD_SIMPLE_SCRIPT = 0x02,
+// 	STAGE_WHOLE_NATIVE_SCRIPT_FINISH = 0x03,
+// };
+
+// static subhandler_fn_t* lookup_subhandler(uint8_t p1)
+// {
+// 	switch (p1) {
+// #define  CASE(P1, HANDLER) case P1: return HANDLER;
+// #define  DEFAULT(HANDLER)  default: return HANDLER;
+// 		CASE(STAGE_COMPLEX_SCRIPT_START, deriveNativeScriptHash_handleComplexScriptStart);
+// 		CASE(STAGE_ADD_SIMPLE_SCRIPT, deriveNativeScriptHash_handleSimpleScript);
+// 		CASE(STAGE_WHOLE_NATIVE_SCRIPT_FINISH, deriveNativeScriptHash_handleWholeNativeScriptFinish)
+// 		DEFAULT(NULL);
+// #undef   CASE
+// #undef   DEFAULT
+// 	}
+// }
+
+// void deriveNativeScriptHash_handleAPDU(
+//         uint8_t p1,
+//         uint8_t p2,
+//         uint8_t *wireDataBuffer,
+//         size_t wireDataSize,
+//         bool isNewCall
+// )
+// {
+// 	TRACE("P1 = 0x%x, P2 = 0x%x, isNewCall = %u", p1, p2, isNewCall);
+// 	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
+// 	TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 	// initialize state
+// 	if (isNewCall) {
+// 		explicit_bzero(ctx, SIZEOF(*ctx));
+// 		ctx->level = 0;
+// 		ctx->complexScripts[ctx->level].remainingScripts = 1;
+// 		nativeScriptHashBuilder_init(&ctx->hashBuilder);
+// 	}
+
+// 	read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 	subhandler_fn_t* subhandler = lookup_subhandler(p1);
+// 	VALIDATE(subhandler != NULL, ERR_INVALID_REQUEST_PARAMETERS);
+// 	subhandler(&view);
+// }
+
+// #undef TRACE_WITH_CTX
diff --git a/src/deriveNativeScriptHash.h b/src/deriveNativeScriptHash.h
index 2044a1d..aca7717 100644
--- a/src/deriveNativeScriptHash.h
+++ b/src/deriveNativeScriptHash.h
@@ -1,51 +1,51 @@
-#ifndef H_CARDANO_APP_DERIVE_NATIVE_SCRIPT_HASH
-#define H_CARDANO_APP_DERIVE_NATIVE_SCRIPT_HASH
-
-#include "bip44.h"
-#include "cardano.h"
-#include "common.h"
-#include "handlers.h"
-#include "nativeScriptHashBuilder.h"
-
-handler_fn_t deriveNativeScriptHash_handleAPDU;
-
-// a special type for distinguishing what to show in the UI, makes it easier
-// to handle PUBKEY DEVICE_OWNED vs THIRD_PARTY
-typedef enum {
-	UI_SCRIPT_PUBKEY_PATH = 0,	// aka DEVICE_OWNED
-	UI_SCRIPT_PUBKEY_HASH,		// aka THIRD_PARTY
-	UI_SCRIPT_ALL,
-	UI_SCRIPT_ANY,
-	UI_SCRIPT_N_OF_K,
-	UI_SCRIPT_INVALID_BEFORE,
-	UI_SCRIPT_INVALID_HEREAFTER,
-} ui_native_script_type;
-
-typedef struct {
-	uint32_t totalScripts;
-	uint32_t remainingScripts;
-} complex_native_script_t;
-
-typedef union {
-	uint32_t requiredScripts;
-	bip44_path_t pubkeyPath;
-	uint8_t pubkeyHash[ADDRESS_KEY_HASH_LENGTH];
-	uint64_t timelock;
-} native_script_content_t;
-
-typedef struct {
-	uint8_t level;
-	// stores information about a complex script at the index level
-	complex_native_script_t complexScripts[MAX_SCRIPT_DEPTH];
-
-	uint8_t scriptHashBuffer[SCRIPT_HASH_LENGTH];
-	native_script_hash_builder_t hashBuilder;
-
-	native_script_content_t scriptContent;
-
-	// UI information
-	int ui_step;
-	ui_native_script_type ui_scriptType;
-} ins_derive_native_script_hash_context_t;
-
-#endif // H_CARDANO_APP_DERIVE_NATIVE_SCRIPT_HASH
+// #ifndef H_CARDANO_APP_DERIVE_NATIVE_SCRIPT_HASH
+// #define H_CARDANO_APP_DERIVE_NATIVE_SCRIPT_HASH
+
+// #include "bip44.h"
+// #include "cardano.h"
+// #include "common.h"
+// #include "handlers.h"
+// #include "nativeScriptHashBuilder.h"
+
+// handler_fn_t deriveNativeScriptHash_handleAPDU;
+
+// // a special type for distinguishing what to show in the UI, makes it easier
+// // to handle PUBKEY DEVICE_OWNED vs THIRD_PARTY
+// typedef enum {
+// 	UI_SCRIPT_PUBKEY_PATH = 0,	// aka DEVICE_OWNED
+// 	UI_SCRIPT_PUBKEY_HASH,		// aka THIRD_PARTY
+// 	UI_SCRIPT_ALL,
+// 	UI_SCRIPT_ANY,
+// 	UI_SCRIPT_N_OF_K,
+// 	UI_SCRIPT_INVALID_BEFORE,
+// 	UI_SCRIPT_INVALID_HEREAFTER,
+// } ui_native_script_type;
+
+// typedef struct {
+// 	uint32_t totalScripts;
+// 	uint32_t remainingScripts;
+// } complex_native_script_t;
+
+// typedef union {
+// 	uint32_t requiredScripts;
+// 	bip44_path_t pubkeyPath;
+// 	uint8_t pubkeyHash[ADDRESS_KEY_HASH_LENGTH];
+// 	uint64_t timelock;
+// } native_script_content_t;
+
+// typedef struct {
+// 	uint8_t level;
+// 	// stores information about a complex script at the index level
+// 	complex_native_script_t complexScripts[MAX_SCRIPT_DEPTH];
+
+// 	uint8_t scriptHashBuffer[SCRIPT_HASH_LENGTH];
+// 	native_script_hash_builder_t hashBuilder;
+
+// 	native_script_content_t scriptContent;
+
+// 	// UI information
+// 	int ui_step;
+// 	ui_native_script_type ui_scriptType;
+// } ins_derive_native_script_hash_context_t;
+
+// #endif // H_CARDANO_APP_DERIVE_NATIVE_SCRIPT_HASH
diff --git a/src/handlers.c b/src/handlers.c
index f591160..20efb1d 100644
--- a/src/handlers.c
+++ b/src/handlers.c
@@ -10,9 +10,9 @@
 #include "runTests.h"
 #include "errors.h"
 #include "deriveAddress.h"
-#include "deriveNativeScriptHash.h"
+// #include "deriveNativeScriptHash.h"
 #include "signTx.h"
-#include "signOpCert.h"
+// #include "signOpCert.h"
 
 // The APDU protocol uses a single-byte instruction code (INS) to specify
 // which command should be executed. We'll use this code to dispatch on a
@@ -28,15 +28,15 @@ handler_fn_t* lookupHandler(uint8_t ins)
 		// 0x1* -  public-key/address related
 		CASE(0x10, getPublicKeys_handleAPDU);
 		CASE(0x11, deriveAddress_handleAPDU);
-		CASE(0x12, deriveNativeScriptHash_handleAPDU);
+		// CASE(0x12, deriveNativeScriptHash_handleAPDU);
 
 		// 0x2* -  signing related
 		CASE(0x21, signTx_handleAPDU);
-		CASE(0x22, signOpCert_handleAPDU);
+		// CASE(0x22, signOpCert_handleAPDU);
 
 		#ifdef DEVEL
 		// 0xF* -  debug_mode related
-		CASE(0xF0, handleRunTests);
+		// CASE(0xF0, handleRunTests);
 		//   0xF1  reserved for INS_SET_HEADLESS_INTERACTION
 		#endif // DEVEL
 #undef   CASE
diff --git a/src/ipUtils.c b/src/ipUtils.c
index 2386ee2..3075340 100644
--- a/src/ipUtils.c
+++ b/src/ipUtils.c
@@ -1,161 +1,161 @@
-/*
- * Taken from glibc:
- * https://www.gnu.org/software/libc/sources.html
- * resolv/inet_ntop.c
- *
- * Modified by Vacuumlabs (2021).
- */
-
-/*
- * Copyright (c) 1996-1999 by Internet Software Consortium.
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
- * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
- * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
- * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- */
-
-#include "assert.h"
-#include "ipUtils.h"
-
-#define NS_IN6ADDRSZ 16 /*%< IPv6 T_AAAA */
-#define NS_INT16SZ 2 /*%< #/bytes of data in a uint16_t */
-
-/*
- * WARNING: Don't even consider trying to compile this on a system where
- * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
- */
-
-/*
- *	format an IPv4 address
- * return:
- *	`dst' (as a const)
- * notes:
- *	(1) uses no statics
- *	(2) takes a uint8_t* not an in_addr as input
- * author:
- *	Paul Vixie, 1996.
- */
-void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize)
-{
-
-	ASSERT(dstSize >= IPV4_STR_SIZE_MAX);
-
-	static const char fmt[] = "%u.%u.%u.%u";
-
-	snprintf(dst, dstSize, fmt, src[0], src[1], src[2], src[3]);
-
-	ASSERT(strlen(dst) + 1 < dstSize);
-}
-
-/*
- *	convert IPv6 binary address into presentation (printable) format
- * author:
- *	Paul Vixie, 1996.
- */
-void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize)
-{
-	STATIC_ASSERT(sizeof(size_t) >= 4, "bad size_t size");
-	STATIC_ASSERT(sizeof(unsigned int) >= 4, "bad unsigned int size");
-
-	/*
-	 * Note that int32_t and int16_t need only be "at least" large enough
-	 * to contain a value of the specified size.  On some systems, like
-	 * Crays, there is no such thing as an integer variable with 16 bits.
-	 * Keep this in mind if you think this function should have been coded
-	 * to use pointer overlays.  All the world's not a VAX.
-	 */
-	char tmp[IPV6_STR_SIZE_MAX] = {0};
-	struct {
-		int base, len;
-	} best, cur;
-	unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];
-
-	/*
-	 * Preprocess:
-	 *	Copy the input (bytewise) array into a wordwise array.
-	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
-	 */
-	memset(words, '\0', sizeof words);
-	for (int i = 0; i < NS_IN6ADDRSZ; i += 2) {
-		ASSERT((unsigned int)(i / 2) < SIZEOF(words));
-		words[i / 2] = (src[i] << 8) | src[i + 1];
-	}
-	best.base = -1;
-	cur.base = -1;
-	best.len = 0;
-	cur.len = 0;
-	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
-		ASSERT((unsigned int) i < SIZEOF(words));
-		if (words[i] == 0) {
-			if (cur.base == -1)
-				cur.base = i, cur.len = 1;
-			else
-				cur.len++;
-		} else {
-			if (cur.base != -1) {
-				if (best.base == -1 || cur.len > best.len)
-					best = cur;
-				cur.base = -1;
-			}
-		}
-	}
-	if (cur.base != -1) {
-		if (best.base == -1 || cur.len > best.len)
-			best = cur;
-	}
-	if (best.base != -1 && best.len < 2)
-		best.base = -1;
-
-	/*
-	 * Format the result.
-	 */
-	char* tp = tmp;
-	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
-		/* Are we inside the best run of 0x00's? */
-		if (best.base != -1 && i >= best.base &&
-		    i < (best.base + best.len)) {
-			if (i == best.base) {
-				ASSERT(tp < tmp + SIZEOF(tmp));
-				*tp++ = ':';
-			}
-			continue;
-		}
-		/* Are we following an initial run of 0x00s or any real hex? */
-		if (i != 0) {
-			ASSERT(tp < tmp + SIZEOF(tmp));
-			*tp++ = ':';
-		}
-		/* Is this address an encapsulated IPv4? */
-		if (i == 6 && best.base == 0 &&
-		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
-			inet_ntop4(src + 12, tp, sizeof tmp - (tp - tmp));
-			tp += strlen(tp);
-			break;
-		}
-		STATIC_ASSERT(sizeof(words[i]) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(words[i]), "signed type for %u");
-		snprintf(tp, sizeof tmp - (tp - tmp), "%x", words[i]);
-
-		tp += strlen(tp);
-	}
-	/* Was it a trailing run of 0x00's? */
-	if (best.base != -1 && (best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ)) {
-		ASSERT(tp < tmp + SIZEOF(tmp));
-		*tp++ = ':';
-	}
-	ASSERT(tp < tmp + SIZEOF(tmp));
-	*tp++ = '\0';
-
-	ASSERT(strlen(tmp) + 1 < dstSize);
-
-	strncpy(dst, tmp, dstSize);
-}
+// /*
+//  * Taken from glibc:
+//  * https://www.gnu.org/software/libc/sources.html
+//  * resolv/inet_ntop.c
+//  *
+//  * Modified by Vacuumlabs (2021).
+//  */
+
+// /*
+//  * Copyright (c) 1996-1999 by Internet Software Consortium.
+//  *
+//  * Permission to use, copy, modify, and distribute this software for any
+//  * purpose with or without fee is hereby granted, provided that the above
+//  * copyright notice and this permission notice appear in all copies.
+//  *
+//  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+//  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+//  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+//  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+//  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+//  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+//  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+//  * SOFTWARE.
+//  */
+
+// #include "assert.h"
+// #include "ipUtils.h"
+
+// #define NS_IN6ADDRSZ 16 /*%< IPv6 T_AAAA */
+// #define NS_INT16SZ 2 /*%< #/bytes of data in a uint16_t */
+
+// /*
+//  * WARNING: Don't even consider trying to compile this on a system where
+//  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
+//  */
+
+// /*
+//  *	format an IPv4 address
+//  * return:
+//  *	`dst' (as a const)
+//  * notes:
+//  *	(1) uses no statics
+//  *	(2) takes a uint8_t* not an in_addr as input
+//  * author:
+//  *	Paul Vixie, 1996.
+//  */
+// void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize)
+// {
+
+// 	ASSERT(dstSize >= IPV4_STR_SIZE_MAX);
+
+// 	static const char fmt[] = "%u.%u.%u.%u";
+
+// 	snprintf(dst, dstSize, fmt, src[0], src[1], src[2], src[3]);
+
+// 	ASSERT(strlen(dst) + 1 < dstSize);
+// }
+
+// /*
+//  *	convert IPv6 binary address into presentation (printable) format
+//  * author:
+//  *	Paul Vixie, 1996.
+//  */
+// void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize)
+// {
+// 	STATIC_ASSERT(sizeof(size_t) >= 4, "bad size_t size");
+// 	STATIC_ASSERT(sizeof(unsigned int) >= 4, "bad unsigned int size");
+
+// 	/*
+// 	 * Note that int32_t and int16_t need only be "at least" large enough
+// 	 * to contain a value of the specified size.  On some systems, like
+// 	 * Crays, there is no such thing as an integer variable with 16 bits.
+// 	 * Keep this in mind if you think this function should have been coded
+// 	 * to use pointer overlays.  All the world's not a VAX.
+// 	 */
+// 	char tmp[IPV6_STR_SIZE_MAX] = {0};
+// 	struct {
+// 		int base, len;
+// 	} best, cur;
+// 	unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];
+
+// 	/*
+// 	 * Preprocess:
+// 	 *	Copy the input (bytewise) array into a wordwise array.
+// 	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
+// 	 */
+// 	memset(words, '\0', sizeof words);
+// 	for (int i = 0; i < NS_IN6ADDRSZ; i += 2) {
+// 		ASSERT((unsigned int)(i / 2) < SIZEOF(words));
+// 		words[i / 2] = (src[i] << 8) | src[i + 1];
+// 	}
+// 	best.base = -1;
+// 	cur.base = -1;
+// 	best.len = 0;
+// 	cur.len = 0;
+// 	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+// 		ASSERT((unsigned int) i < SIZEOF(words));
+// 		if (words[i] == 0) {
+// 			if (cur.base == -1)
+// 				cur.base = i, cur.len = 1;
+// 			else
+// 				cur.len++;
+// 		} else {
+// 			if (cur.base != -1) {
+// 				if (best.base == -1 || cur.len > best.len)
+// 					best = cur;
+// 				cur.base = -1;
+// 			}
+// 		}
+// 	}
+// 	if (cur.base != -1) {
+// 		if (best.base == -1 || cur.len > best.len)
+// 			best = cur;
+// 	}
+// 	if (best.base != -1 && best.len < 2)
+// 		best.base = -1;
+
+// 	/*
+// 	 * Format the result.
+// 	 */
+// 	char* tp = tmp;
+// 	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+// 		/* Are we inside the best run of 0x00's? */
+// 		if (best.base != -1 && i >= best.base &&
+// 		    i < (best.base + best.len)) {
+// 			if (i == best.base) {
+// 				ASSERT(tp < tmp + SIZEOF(tmp));
+// 				*tp++ = ':';
+// 			}
+// 			continue;
+// 		}
+// 		/* Are we following an initial run of 0x00s or any real hex? */
+// 		if (i != 0) {
+// 			ASSERT(tp < tmp + SIZEOF(tmp));
+// 			*tp++ = ':';
+// 		}
+// 		/* Is this address an encapsulated IPv4? */
+// 		if (i == 6 && best.base == 0 &&
+// 		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
+// 			inet_ntop4(src + 12, tp, sizeof tmp - (tp - tmp));
+// 			tp += strlen(tp);
+// 			break;
+// 		}
+// 		STATIC_ASSERT(sizeof(words[i]) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(words[i]), "signed type for %u");
+// 		snprintf(tp, sizeof tmp - (tp - tmp), "%x", words[i]);
+
+// 		tp += strlen(tp);
+// 	}
+// 	/* Was it a trailing run of 0x00's? */
+// 	if (best.base != -1 && (best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ)) {
+// 		ASSERT(tp < tmp + SIZEOF(tmp));
+// 		*tp++ = ':';
+// 	}
+// 	ASSERT(tp < tmp + SIZEOF(tmp));
+// 	*tp++ = '\0';
+
+// 	ASSERT(strlen(tmp) + 1 < dstSize);
+
+// 	strncpy(dst, tmp, dstSize);
+// }
diff --git a/src/ipUtils.h b/src/ipUtils.h
index ffa0862..90da88f 100644
--- a/src/ipUtils.h
+++ b/src/ipUtils.h
@@ -1,16 +1,16 @@
-#ifndef H_CARDANO_APP_IP_UTILS
-#define H_CARDANO_APP_IP_UTILS
+// #ifndef H_CARDANO_APP_IP_UTILS
+// #define H_CARDANO_APP_IP_UTILS
 
-#include "os.h"
+// #include "os.h"
 
-#define IPV4_STR_SIZE_MAX (sizeof "255.255.255.255")
-#define IPV6_STR_SIZE_MAX (sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")
+// #define IPV4_STR_SIZE_MAX (sizeof "255.255.255.255")
+// #define IPV6_STR_SIZE_MAX (sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")
 
-void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize);
-void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize);
+// void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize);
+// void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize);
 
-#ifdef DEVEL
-void run_ipUtils_test();
-#endif // DEVEL
+// #ifdef DEVEL
+// void run_ipUtils_test();
+// #endif // DEVEL
 
-#endif  // H_CARDANO_APP_SIGN_TX_UTILS
+// #endif  // H_CARDANO_APP_SIGN_TX_UTILS
diff --git a/src/ipUtils_test.c b/src/ipUtils_test.c
index 413bef7..108e50f 100644
--- a/src/ipUtils_test.c
+++ b/src/ipUtils_test.c
@@ -1,58 +1,58 @@
-#ifdef DEVEL
+// #ifdef DEVEL
 
-#include "ipUtils.h"
-#include "utils.h"
+// #include "ipUtils.h"
+// #include "utils.h"
 
-static void test1()
-{
-	TRACE("ipUtils test");
+// static void test1()
+// {
+// 	TRACE("ipUtils test");
 
-	// in:  fe80:0000:0000:0000:a299:9bff:fe18:50d1
-	// out: fe80::a299:9bff:fe18:50d1
+// 	// in:  fe80:0000:0000:0000:a299:9bff:fe18:50d1
+// 	// out: fe80::a299:9bff:fe18:50d1
 
-	uint8_t in[16] = {0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0x99, 0x9b, 0xff, 0xfe, 0x18, 0x50, 0xd1};
+// 	uint8_t in[16] = {0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0x99, 0x9b, 0xff, 0xfe, 0x18, 0x50, 0xd1};
 
-	char s[46] = {0};
-	inet_ntop6(in, s, SIZEOF(s));
+// 	char s[46] = {0};
+// 	inet_ntop6(in, s, SIZEOF(s));
 
-	ASSERT(!strcmp(s, "fe80::a299:9bff:fe18:50d1"));
-}
+// 	ASSERT(!strcmp(s, "fe80::a299:9bff:fe18:50d1"));
+// }
 
-static void test2()
-{
-	TRACE("ipUtils test");
+// static void test2()
+// {
+// 	TRACE("ipUtils test");
 
-	// in:  2001:0db8:1111:000a:00b0:0000:0000:0200
-	// out: 2001:db8:1111:a:b0::200
+// 	// in:  2001:0db8:1111:000a:00b0:0000:0000:0200
+// 	// out: 2001:db8:1111:a:b0::200
 
-	uint8_t in[16] = {0x20, 0x01, 0x0d, 0xb8, 0x11, 0x11, 0x00, 0x0a, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00};
+// 	uint8_t in[16] = {0x20, 0x01, 0x0d, 0xb8, 0x11, 0x11, 0x00, 0x0a, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00};
 
-	char s[46] = {0};
-	inet_ntop6(in, s, SIZEOF(s));
+// 	char s[46] = {0};
+// 	inet_ntop6(in, s, SIZEOF(s));
 
-	ASSERT(!strcmp(s, "2001:db8:1111:a:b0::200"));
-}
+// 	ASSERT(!strcmp(s, "2001:db8:1111:a:b0::200"));
+// }
 
-static void test3()
-{
-	TRACE("ipUtils test");
+// static void test3()
+// {
+// 	TRACE("ipUtils test");
 
-	// in:  0:0:0:0:0:ffff:c000:280
-	// out: ::ffff:192.0.2.128
+// 	// in:  0:0:0:0:0:ffff:c000:280
+// 	// out: ::ffff:192.0.2.128
 
-	uint8_t in[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x02, 0x80};
+// 	uint8_t in[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x02, 0x80};
 
-	char s[46] = {0};
-	inet_ntop6(in, s, SIZEOF(s));
+// 	char s[46] = {0};
+// 	inet_ntop6(in, s, SIZEOF(s));
 
-	ASSERT(!strcmp(s, "::ffff:192.0.2.128"));
-}
+// 	ASSERT(!strcmp(s, "::ffff:192.0.2.128"));
+// }
 
-void run_ipUtils_test()
-{
-	test1();
-	test2();
-	test3();
-}
+// void run_ipUtils_test()
+// {
+// 	test1();
+// 	test2();
+// 	test3();
+// }
 
-#endif // DEVEL
+// #endif // DEVEL
diff --git a/src/messageSigning.c b/src/messageSigning.c
index 006eb69..e381848 100644
--- a/src/messageSigning.c
+++ b/src/messageSigning.c
@@ -74,25 +74,25 @@ void getTxWitness(bip44_path_t* pathSpec,
 	#endif
 }
 
-void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
-        const uint8_t* payloadHashBuffer, size_t payloadHashSize,
-        uint8_t* outBuffer, size_t outSize)
-{
-	ASSERT(payloadHashSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
-	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
+// void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
+//         const uint8_t* payloadHashBuffer, size_t payloadHashSize,
+//         uint8_t* outBuffer, size_t outSize)
+// {
+// 	ASSERT(payloadHashSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
+// 	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
 
-	#ifndef FUZZING
-	signRawMessageWithPath(pathSpec, payloadHashBuffer, payloadHashSize, outBuffer, outSize);
-	#endif
-}
+// 	#ifndef FUZZING
+// 	signRawMessageWithPath(pathSpec, payloadHashBuffer, payloadHashSize, outBuffer, outSize);
+// 	#endif
+// }
 
-void getOpCertSignature(bip44_path_t* pathSpec,
-                        const uint8_t* opCertBodyBuffer, size_t opCertBodySize,
-                        uint8_t* outBuffer, size_t outSize)
-{
-	ASSERT(bip44_isPoolColdKeyPath(pathSpec));
-	ASSERT(opCertBodySize == OP_CERT_BODY_LENGTH);
-	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
+// void getOpCertSignature(bip44_path_t* pathSpec,
+//                         const uint8_t* opCertBodyBuffer, size_t opCertBodySize,
+//                         uint8_t* outBuffer, size_t outSize)
+// {
+// 	ASSERT(bip44_isPoolColdKeyPath(pathSpec));
+// 	ASSERT(opCertBodySize == OP_CERT_BODY_LENGTH);
+// 	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
 
-	signRawMessageWithPath(pathSpec, opCertBodyBuffer, opCertBodySize, outBuffer, outSize);
-}
+// 	signRawMessageWithPath(pathSpec, opCertBodyBuffer, opCertBodySize, outBuffer, outSize);
+// }
diff --git a/src/messageSigning.h b/src/messageSigning.h
index 5fd7e45..9d7d1fa 100644
--- a/src/messageSigning.h
+++ b/src/messageSigning.h
@@ -7,9 +7,9 @@ void getTxWitness(bip44_path_t* pathSpec,
                   const uint8_t* txHashBuffer, size_t txHashSize,
                   uint8_t* outBuffer, size_t outSize);
 
-void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
-        const uint8_t* payloadHashBuffer, size_t payloadHashSize,
-        uint8_t* outBuffer, size_t outSize);
+// void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
+//         const uint8_t* payloadHashBuffer, size_t payloadHashSize,
+//         uint8_t* outBuffer, size_t outSize);
 
 void getOpCertSignature(bip44_path_t* pathSpec,
                         const uint8_t* opCertBodyBuffer, size_t opCertBodySize,
diff --git a/src/nativeScriptHashBuilder.c b/src/nativeScriptHashBuilder.c
index 202b268..122ba3a 100644
--- a/src/nativeScriptHashBuilder.c
+++ b/src/nativeScriptHashBuilder.c
@@ -1,229 +1,229 @@
-#include "cbor.h"
-#include "nativeScriptHashBuilder.h"
-
-//#define TRACE_NATIVE_SCRIPT_HASH_BUILDER
-
-#ifdef TRACE_NATIVE_SCRIPT_HASH_BUILDER
-#define _TRACE(...) TRACE(__VA_ARGS__)
-#define _TRACE_BUFFER(...) TRACE_BUFFER(__VA_ARGS__)
-#else
-#define _TRACE(...)
-#define _TRACE_BUFFER(...)
-#endif // TRACE_NATIVE_SCRIPT_HASH_BUILDER
-
-#define APPEND_CBOR(type, value) blake2b_224_append_cbor_data(&builder->nativeScriptHash, type, value)
-#define APPEND_BUFFER(buffer, size) blake2b_224_append_buffer_data(&builder->nativeScriptHash, buffer, size)
-
-static void blake2b_224_append_buffer_data(
-        blake2b_224_context_t* hashCtx,
-        const uint8_t* buffer, size_t size
-)
-{
-	_TRACE_BUFFER(buffer, size);
-	blake2b_224_append(hashCtx, buffer, size);
-}
-
-__noinline_due_to_stack__
-static void blake2b_224_append_cbor_data(
-        blake2b_224_context_t* hashCtx,
-        uint8_t type, uint64_t value
-)
-{
-	uint8_t buffer[10] = {0};
-	size_t size = cbor_writeToken(type, value, buffer, SIZEOF(buffer));
-	_TRACE_BUFFER(buffer, size);
-	blake2b_224_append(hashCtx, buffer, size);
-}
-
-static inline void advanceState(native_script_hash_builder_t* builder)
-{
-	// advance state should be only called when state is not finished
-	// the advance state determines the next state from the current level
-	// and number of remaining scripts for the current level
-	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);
-
-	_TRACE("Advancing state, level = %u, remaining scripts = %u", builder->level, builder->remainingScripts[builder->level]);
-
-	if (builder->level == 0 && builder->remainingScripts[builder->level] == 0) {
-		builder->state = NATIVE_SCRIPT_HASH_BUILDER_FINISHED;
-	} else {
-		builder->state = NATIVE_SCRIPT_HASH_BUILDER_SCRIPT;
-	}
-}
-
-static inline bool isComplexScriptFinished(native_script_hash_builder_t* builder)
-{
-	return builder->level > 0 && builder->remainingScripts[builder->level] == 0;
-}
-
-static void complexScriptFinished(native_script_hash_builder_t* builder)
-{
-	while (isComplexScriptFinished(builder)) {
-		ASSERT(builder->level > 0);
-		builder->level--;
-
-		ASSERT(builder->remainingScripts[builder->level] > 0);
-		builder->remainingScripts[builder->level]--;
-	}
-}
-
-static void simpleScriptFinished(native_script_hash_builder_t* builder)
-{
-	ASSERT(builder->remainingScripts[builder->level] > 0);
-	builder->remainingScripts[builder->level]--;
-
-	if(isComplexScriptFinished(builder)) {
-		complexScriptFinished(builder);
-	}
-}
-
-void nativeScriptHashBuilder_init(
-        native_script_hash_builder_t* builder
-)
-{
-	TRACE("Serializing native script hash data");
-	blake2b_224_init(&builder->nativeScriptHash);
-
-	// the native script hash is computed as a CBOR representation of the script,
-	// but with a zero byte prepended before the CBOR
-	uint8_t init[1] = {0x00};
-	APPEND_BUFFER(init, 1);
-
-	builder->state = NATIVE_SCRIPT_HASH_BUILDER_SCRIPT;
-	builder->level = 0;
-	builder->remainingScripts[builder->level] = 1;
-}
-
-#define _DEFINE_COMPLEX_SCRIPT(name, type) \
-	void nativeScriptHashBuilder_startComplexScript_##name(\
-	        native_script_hash_builder_t* builder,\
-	        uint32_t remainingScripts\
-	                                                      )\
-	{\
-		_TRACE("state = %d", builder->state);\
-		\
-		ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);\
-		\
-		/* Array(2)[ */\
-		/*    Unsigned[native script type], */\
-		/*    Array(remainingScripts)[ */\
-		/*       // entries added later */\
-		/*    ], */\
-		/* ] */\
-		APPEND_CBOR(CBOR_TYPE_ARRAY, 2);\
-		APPEND_CBOR(CBOR_TYPE_UNSIGNED, type);\
-		APPEND_CBOR(CBOR_TYPE_ARRAY, remainingScripts);\
-		\
-		builder->level++;\
-		builder->remainingScripts[builder->level] = remainingScripts;\
-		\
-		if(isComplexScriptFinished(builder)) {\
-			complexScriptFinished(builder);\
-		}\
-		advanceState(builder);\
-	}
-
-_DEFINE_COMPLEX_SCRIPT(all, NATIVE_SCRIPT_ALL)
-_DEFINE_COMPLEX_SCRIPT(any, NATIVE_SCRIPT_ANY)
-
-#undef _DEFINE_COMPLEX_SCRIPT
-
-void nativeScriptHashBuilder_startComplexScript_n_of_k(
-        native_script_hash_builder_t* builder,
-        uint32_t requiredScripts,
-        uint32_t remainingScripts
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);
-
-	// Array(3)[
-	//    Unsigned[native script type = 3],
-	//    Unsigned[requiredScripts],
-	//    Array(remainingScripts)[
-	//       // entries added later
-	//    ],
-	// ]
-	APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
-	APPEND_CBOR(CBOR_TYPE_UNSIGNED, NATIVE_SCRIPT_N_OF_K);
-	APPEND_CBOR(CBOR_TYPE_UNSIGNED, requiredScripts);
-	APPEND_CBOR(CBOR_TYPE_ARRAY, remainingScripts);
-
-	builder->level++;
-	builder->remainingScripts[builder->level] = remainingScripts;
-
-	if(isComplexScriptFinished(builder)) {
-		complexScriptFinished(builder);
-	}
-	advanceState(builder);
-}
-
-void nativeScriptHashBuilder_addScript_pubkey(
-        native_script_hash_builder_t* builder,
-        const uint8_t *pubKeyHashBuffer, size_t pubKeyHashSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);
-	ASSERT(pubKeyHashSize == ADDRESS_KEY_HASH_LENGTH);
-
-	// Array(2)[
-	//    Unsigned[native script type = 0],
-	//    Bytes[pubKeyHash],
-	// ]
-	APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
-	APPEND_CBOR(CBOR_TYPE_UNSIGNED, NATIVE_SCRIPT_PUBKEY);
-	APPEND_CBOR(CBOR_TYPE_BYTES, pubKeyHashSize);
-	APPEND_BUFFER(pubKeyHashBuffer, pubKeyHashSize);
-
-	simpleScriptFinished(builder);
-	advanceState(builder);
-}
-
-#define _DEFINE_SIMPLE_TIMELOCK_SCRIPT(name, type) \
-	void nativeScriptHashBuilder_addScript_##name(\
-	        native_script_hash_builder_t* builder,\
-	        uint64_t timelock\
-	                                             )\
-	{\
-		_TRACE("state = %d", builder->state);\
-		\
-		ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);\
-		\
-		/* Array(2)[ */\
-		/*    Unsigned[native script type], */\
-		/*    Unsigned[timelock], */\
-		/* ] */\
-		APPEND_CBOR(CBOR_TYPE_ARRAY, 2);\
-		APPEND_CBOR(CBOR_TYPE_UNSIGNED, type);\
-		APPEND_CBOR(CBOR_TYPE_UNSIGNED, timelock);\
-		\
-		simpleScriptFinished(builder);\
-		advanceState(builder);\
-	}
-
-_DEFINE_SIMPLE_TIMELOCK_SCRIPT(invalidBefore, NATIVE_SCRIPT_INVALID_BEFORE);
-_DEFINE_SIMPLE_TIMELOCK_SCRIPT(invalidHereafter, NATIVE_SCRIPT_INVALID_HEREAFTER);
-
-#undef _DEFINE_SIMPLE_TIMELOCK_SCRIPT
-
-void nativeScriptHashBuilder_finalize(
-        native_script_hash_builder_t* builder,
-        uint8_t *outBuffer, size_t outSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_FINISHED);
-
-	ASSERT(outSize == SCRIPT_HASH_LENGTH);
-
-	blake2b_224_finalize(&builder->nativeScriptHash, outBuffer, outSize);
-}
-
-#undef APPEND_BUFFER
-#undef APPEND_CBOR
-#undef _TRACE_BUFFER
-#undef _TRACE
+// #include "cbor.h"
+// #include "nativeScriptHashBuilder.h"
+
+// //#define TRACE_NATIVE_SCRIPT_HASH_BUILDER
+
+// #ifdef TRACE_NATIVE_SCRIPT_HASH_BUILDER
+// #define _TRACE(...) TRACE(__VA_ARGS__)
+// #define _TRACE_BUFFER(...) TRACE_BUFFER(__VA_ARGS__)
+// #else
+// #define _TRACE(...)
+// #define _TRACE_BUFFER(...)
+// #endif // TRACE_NATIVE_SCRIPT_HASH_BUILDER
+
+// #define APPEND_CBOR(type, value) blake2b_224_append_cbor_data(&builder->nativeScriptHash, type, value)
+// #define APPEND_BUFFER(buffer, size) blake2b_224_append_buffer_data(&builder->nativeScriptHash, buffer, size)
+
+// static void blake2b_224_append_buffer_data(
+//         blake2b_224_context_t* hashCtx,
+//         const uint8_t* buffer, size_t size
+// )
+// {
+// 	_TRACE_BUFFER(buffer, size);
+// 	blake2b_224_append(hashCtx, buffer, size);
+// }
+
+// __noinline_due_to_stack__
+// static void blake2b_224_append_cbor_data(
+//         blake2b_224_context_t* hashCtx,
+//         uint8_t type, uint64_t value
+// )
+// {
+// 	uint8_t buffer[10] = {0};
+// 	size_t size = cbor_writeToken(type, value, buffer, SIZEOF(buffer));
+// 	_TRACE_BUFFER(buffer, size);
+// 	blake2b_224_append(hashCtx, buffer, size);
+// }
+
+// static inline void advanceState(native_script_hash_builder_t* builder)
+// {
+// 	// advance state should be only called when state is not finished
+// 	// the advance state determines the next state from the current level
+// 	// and number of remaining scripts for the current level
+// 	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);
+
+// 	_TRACE("Advancing state, level = %u, remaining scripts = %u", builder->level, builder->remainingScripts[builder->level]);
+
+// 	if (builder->level == 0 && builder->remainingScripts[builder->level] == 0) {
+// 		builder->state = NATIVE_SCRIPT_HASH_BUILDER_FINISHED;
+// 	} else {
+// 		builder->state = NATIVE_SCRIPT_HASH_BUILDER_SCRIPT;
+// 	}
+// }
+
+// static inline bool isComplexScriptFinished(native_script_hash_builder_t* builder)
+// {
+// 	return builder->level > 0 && builder->remainingScripts[builder->level] == 0;
+// }
+
+// static void complexScriptFinished(native_script_hash_builder_t* builder)
+// {
+// 	while (isComplexScriptFinished(builder)) {
+// 		ASSERT(builder->level > 0);
+// 		builder->level--;
+
+// 		ASSERT(builder->remainingScripts[builder->level] > 0);
+// 		builder->remainingScripts[builder->level]--;
+// 	}
+// }
+
+// static void simpleScriptFinished(native_script_hash_builder_t* builder)
+// {
+// 	ASSERT(builder->remainingScripts[builder->level] > 0);
+// 	builder->remainingScripts[builder->level]--;
+
+// 	if(isComplexScriptFinished(builder)) {
+// 		complexScriptFinished(builder);
+// 	}
+// }
+
+// void nativeScriptHashBuilder_init(
+//         native_script_hash_builder_t* builder
+// )
+// {
+// 	TRACE("Serializing native script hash data");
+// 	blake2b_224_init(&builder->nativeScriptHash);
+
+// 	// the native script hash is computed as a CBOR representation of the script,
+// 	// but with a zero byte prepended before the CBOR
+// 	uint8_t init[1] = {0x00};
+// 	APPEND_BUFFER(init, 1);
+
+// 	builder->state = NATIVE_SCRIPT_HASH_BUILDER_SCRIPT;
+// 	builder->level = 0;
+// 	builder->remainingScripts[builder->level] = 1;
+// }
+
+// #define _DEFINE_COMPLEX_SCRIPT(name, type) \
+// 	void nativeScriptHashBuilder_startComplexScript_##name(\
+// 	        native_script_hash_builder_t* builder,\
+// 	        uint32_t remainingScripts\
+// 	                                                      )\
+// 	{\
+// 		_TRACE("state = %d", builder->state);\
+// 		\
+// 		ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);\
+// 		\
+// 		/* Array(2)[ */\
+// 		/*    Unsigned[native script type], */\
+// 		/*    Array(remainingScripts)[ */\
+// 		/*       // entries added later */\
+// 		/*    ], */\
+// 		/* ] */\
+// 		APPEND_CBOR(CBOR_TYPE_ARRAY, 2);\
+// 		APPEND_CBOR(CBOR_TYPE_UNSIGNED, type);\
+// 		APPEND_CBOR(CBOR_TYPE_ARRAY, remainingScripts);\
+// 		\
+// 		builder->level++;\
+// 		builder->remainingScripts[builder->level] = remainingScripts;\
+// 		\
+// 		if(isComplexScriptFinished(builder)) {\
+// 			complexScriptFinished(builder);\
+// 		}\
+// 		advanceState(builder);\
+// 	}
+
+// _DEFINE_COMPLEX_SCRIPT(all, NATIVE_SCRIPT_ALL)
+// _DEFINE_COMPLEX_SCRIPT(any, NATIVE_SCRIPT_ANY)
+
+// #undef _DEFINE_COMPLEX_SCRIPT
+
+// void nativeScriptHashBuilder_startComplexScript_n_of_k(
+//         native_script_hash_builder_t* builder,
+//         uint32_t requiredScripts,
+//         uint32_t remainingScripts
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);
+
+// 	// Array(3)[
+// 	//    Unsigned[native script type = 3],
+// 	//    Unsigned[requiredScripts],
+// 	//    Array(remainingScripts)[
+// 	//       // entries added later
+// 	//    ],
+// 	// ]
+// 	APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
+// 	APPEND_CBOR(CBOR_TYPE_UNSIGNED, NATIVE_SCRIPT_N_OF_K);
+// 	APPEND_CBOR(CBOR_TYPE_UNSIGNED, requiredScripts);
+// 	APPEND_CBOR(CBOR_TYPE_ARRAY, remainingScripts);
+
+// 	builder->level++;
+// 	builder->remainingScripts[builder->level] = remainingScripts;
+
+// 	if(isComplexScriptFinished(builder)) {
+// 		complexScriptFinished(builder);
+// 	}
+// 	advanceState(builder);
+// }
+
+// void nativeScriptHashBuilder_addScript_pubkey(
+//         native_script_hash_builder_t* builder,
+//         const uint8_t *pubKeyHashBuffer, size_t pubKeyHashSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);
+// 	ASSERT(pubKeyHashSize == ADDRESS_KEY_HASH_LENGTH);
+
+// 	// Array(2)[
+// 	//    Unsigned[native script type = 0],
+// 	//    Bytes[pubKeyHash],
+// 	// ]
+// 	APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
+// 	APPEND_CBOR(CBOR_TYPE_UNSIGNED, NATIVE_SCRIPT_PUBKEY);
+// 	APPEND_CBOR(CBOR_TYPE_BYTES, pubKeyHashSize);
+// 	APPEND_BUFFER(pubKeyHashBuffer, pubKeyHashSize);
+
+// 	simpleScriptFinished(builder);
+// 	advanceState(builder);
+// }
+
+// #define _DEFINE_SIMPLE_TIMELOCK_SCRIPT(name, type) \
+// 	void nativeScriptHashBuilder_addScript_##name(\
+// 	        native_script_hash_builder_t* builder,\
+// 	        uint64_t timelock\
+// 	                                             )\
+// 	{\
+// 		_TRACE("state = %d", builder->state);\
+// 		\
+// 		ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_SCRIPT);\
+// 		\
+// 		/* Array(2)[ */\
+// 		/*    Unsigned[native script type], */\
+// 		/*    Unsigned[timelock], */\
+// 		/* ] */\
+// 		APPEND_CBOR(CBOR_TYPE_ARRAY, 2);\
+// 		APPEND_CBOR(CBOR_TYPE_UNSIGNED, type);\
+// 		APPEND_CBOR(CBOR_TYPE_UNSIGNED, timelock);\
+// 		\
+// 		simpleScriptFinished(builder);\
+// 		advanceState(builder);\
+// 	}
+
+// _DEFINE_SIMPLE_TIMELOCK_SCRIPT(invalidBefore, NATIVE_SCRIPT_INVALID_BEFORE);
+// _DEFINE_SIMPLE_TIMELOCK_SCRIPT(invalidHereafter, NATIVE_SCRIPT_INVALID_HEREAFTER);
+
+// #undef _DEFINE_SIMPLE_TIMELOCK_SCRIPT
+
+// void nativeScriptHashBuilder_finalize(
+//         native_script_hash_builder_t* builder,
+//         uint8_t *outBuffer, size_t outSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == NATIVE_SCRIPT_HASH_BUILDER_FINISHED);
+
+// 	ASSERT(outSize == SCRIPT_HASH_LENGTH);
+
+// 	blake2b_224_finalize(&builder->nativeScriptHash, outBuffer, outSize);
+// }
+
+// #undef APPEND_BUFFER
+// #undef APPEND_CBOR
+// #undef _TRACE_BUFFER
+// #undef _TRACE
diff --git a/src/nativeScriptHashBuilder.h b/src/nativeScriptHashBuilder.h
index 752eecb..2c0a287 100644
--- a/src/nativeScriptHashBuilder.h
+++ b/src/nativeScriptHashBuilder.h
@@ -1,62 +1,62 @@
-#ifndef H_CARDANO_APP_NATIVE_SCRIPT_HASH_BUILDER
-#define H_CARDANO_APP_NATIVE_SCRIPT_HASH_BUILDER
-
-#include "cardano.h"
-#include "hash.h"
-
-typedef enum {
-	NATIVE_SCRIPT_HASH_BUILDER_SCRIPT = 100,
-	NATIVE_SCRIPT_HASH_BUILDER_FINISHED = 200,
-} native_script_hash_builder_state_t;
-
-typedef struct {
-	uint8_t level;
-	uint32_t remainingScripts[MAX_SCRIPT_DEPTH];
-	native_script_hash_builder_state_t state;
-	blake2b_224_context_t nativeScriptHash;
-} native_script_hash_builder_t;
-
-void nativeScriptHashBuilder_init(
-        native_script_hash_builder_t* builder
-);
-
-void nativeScriptHashBuilder_startComplexScript_all(
-        native_script_hash_builder_t* builder,
-        uint32_t remainingScripts
-);
-
-void nativeScriptHashBuilder_startComplexScript_any(
-        native_script_hash_builder_t* builder,
-        uint32_t remainingScripts
-);
-
-void nativeScriptHashBuilder_startComplexScript_n_of_k(
-        native_script_hash_builder_t* builder,
-        uint32_t remainingScripts, uint32_t requiredScripts
-);
-
-void nativeScriptHashBuilder_addScript_pubkey(
-        native_script_hash_builder_t* builder,
-        const uint8_t *pubKeyHashBuffer, size_t pubKeyHashSize
-);
-
-void nativeScriptHashBuilder_addScript_invalidBefore(
-        native_script_hash_builder_t* builder,
-        uint64_t timelock
-);
-
-void nativeScriptHashBuilder_addScript_invalidHereafter(
-        native_script_hash_builder_t* builder,
-        uint64_t timelock
-);
-
-void nativeScriptHashBuilder_finalize(
-        native_script_hash_builder_t* builder,
-        uint8_t *outBuffer, size_t outSize
-);
-
-/* #ifdef DEVEL */
-void run_nativeScriptHashBuilder_test();
-/* #endif // DEVEL */
-
-#endif // H_CARDANO_APP_NATIVE_SCRIPT_HASH_BUILDER
+// #ifndef H_CARDANO_APP_NATIVE_SCRIPT_HASH_BUILDER
+// #define H_CARDANO_APP_NATIVE_SCRIPT_HASH_BUILDER
+
+// #include "cardano.h"
+// #include "hash.h"
+
+// typedef enum {
+// 	NATIVE_SCRIPT_HASH_BUILDER_SCRIPT = 100,
+// 	NATIVE_SCRIPT_HASH_BUILDER_FINISHED = 200,
+// } native_script_hash_builder_state_t;
+
+// typedef struct {
+// 	uint8_t level;
+// 	uint32_t remainingScripts[MAX_SCRIPT_DEPTH];
+// 	native_script_hash_builder_state_t state;
+// 	blake2b_224_context_t nativeScriptHash;
+// } native_script_hash_builder_t;
+
+// void nativeScriptHashBuilder_init(
+//         native_script_hash_builder_t* builder
+// );
+
+// void nativeScriptHashBuilder_startComplexScript_all(
+//         native_script_hash_builder_t* builder,
+//         uint32_t remainingScripts
+// );
+
+// void nativeScriptHashBuilder_startComplexScript_any(
+//         native_script_hash_builder_t* builder,
+//         uint32_t remainingScripts
+// );
+
+// void nativeScriptHashBuilder_startComplexScript_n_of_k(
+//         native_script_hash_builder_t* builder,
+//         uint32_t remainingScripts, uint32_t requiredScripts
+// );
+
+// void nativeScriptHashBuilder_addScript_pubkey(
+//         native_script_hash_builder_t* builder,
+//         const uint8_t *pubKeyHashBuffer, size_t pubKeyHashSize
+// );
+
+// void nativeScriptHashBuilder_addScript_invalidBefore(
+//         native_script_hash_builder_t* builder,
+//         uint64_t timelock
+// );
+
+// void nativeScriptHashBuilder_addScript_invalidHereafter(
+//         native_script_hash_builder_t* builder,
+//         uint64_t timelock
+// );
+
+// void nativeScriptHashBuilder_finalize(
+//         native_script_hash_builder_t* builder,
+//         uint8_t *outBuffer, size_t outSize
+// );
+
+// /* #ifdef DEVEL */
+// void run_nativeScriptHashBuilder_test();
+// /* #endif // DEVEL */
+
+// #endif // H_CARDANO_APP_NATIVE_SCRIPT_HASH_BUILDER
diff --git a/src/nativeScriptHashBuilder_test.c b/src/nativeScriptHashBuilder_test.c
index c3f2e88..8720cfb 100644
--- a/src/nativeScriptHashBuilder_test.c
+++ b/src/nativeScriptHashBuilder_test.c
@@ -1,108 +1,108 @@
-#ifdef DEVEL
+// #ifdef DEVEL
 
-#include "hexUtils.h"
-#include "nativeScriptHashBuilder.h"
-#include "testUtils.h"
+// #include "hexUtils.h"
+// #include "nativeScriptHashBuilder.h"
+// #include "testUtils.h"
 
-#define BUF_FROM_STR(name, size) \
-	uint8_t name[size] = {0}; \
-	decode_hex(name##Str, name, size); \
-
-#define BEFORE_EACH \
-	native_script_hash_builder_t builder; \
-	nativeScriptHashBuilder_init(&builder); \
-
-#define FINALIZE \
-	uint8_t result[SCRIPT_HASH_LENGTH] = {0}; \
-	nativeScriptHashBuilder_finalize(&builder, result, ADDRESS_KEY_HASH_LENGTH);\
-	PRINTF("Native script hash hex\n");\
-	PRINTF("%.*h\n", 32, result);
-
-#define EQUALS(name) \
-	BUF_FROM_STR(name, SCRIPT_HASH_LENGTH); \
-	EXPECT_EQ_BYTES(result, name, SCRIPT_HASH_LENGTH);
-
-static const char* pubkeyHashStr = "3a55d9f68255dfbefa1efd711f82d005fae1be2e145d616c90cf0fa9";
-static const char* expectedPubkeyScriptHashStr = "855228f5ecececf9c85618007cc3c2e5bdf5e6d41ef8d6fa793fe0eb";
-
-static const uint64_t invalidBefore = 42;
-static const char* expectedInvalidBeforeScriptHashStr = "2a25e608a683057e32ea38b50ce8875d5b34496b393da8d25d314c4e";
-
-static const uint64_t invalidHereafter = 42;
-static const char* expectedInvalidHereafterScriptHashStr = "1620dc65993296335183f23ff2f7747268168fabbeecbf24c8a20194";
-
-static const char* expectedEmptyAllScriptHashStr = "d441227553a0f1a965fee7d60a0f724b368dd1bddbc208730fccebcf";
-static const char* expectedEmptyAnyScriptHashStr = "52dc3d43b6d2465e96109ce75ab61abe5e9c1d8a3c9ce6ff8a3af528";
-static const char* expectedEmptyNofKScriptHashStr = "3530cc9ae7f2895111a99b7a02184dd7c0cea7424f1632d73951b1d7";
-
-static const char* expectedNestedComplexScriptsStr = "1f292766b9b0db263f8ecc087478f6aeea3c9fe091674153084e5668";
-
-void run_nativeScriptHashBuilder_test()
-{
-	PRINTF("nativeScriptHashBuilder test\n");
-	{
-		BEFORE_EACH;
-
-		BUF_FROM_STR(pubkeyHash, ADDRESS_KEY_HASH_LENGTH);
-		nativeScriptHashBuilder_addScript_pubkey(&builder, pubkeyHash, SIZEOF(pubkeyHash));
-
-		FINALIZE;
-		EQUALS(expectedPubkeyScriptHash);
-	}
-	{
-		BEFORE_EACH;
-
-		nativeScriptHashBuilder_addScript_invalidBefore(&builder, invalidBefore);
-
-		FINALIZE;
-		EQUALS(expectedInvalidBeforeScriptHash);
-	}
-	{
-		BEFORE_EACH;
-
-		nativeScriptHashBuilder_addScript_invalidHereafter(&builder, invalidHereafter);
-
-		FINALIZE;
-		EQUALS(expectedInvalidHereafterScriptHash);
-	}
-	{
-		BEFORE_EACH;
-
-		nativeScriptHashBuilder_startComplexScript_all(&builder, 0);
-
-		FINALIZE;
-		EQUALS(expectedEmptyAllScriptHash);
-	}
-	{
-		BEFORE_EACH;
-
-		nativeScriptHashBuilder_startComplexScript_any(&builder, 0);
-
-		FINALIZE;
-		EQUALS(expectedEmptyAnyScriptHash);
-	}
-	{
-		BEFORE_EACH;
-
-		nativeScriptHashBuilder_startComplexScript_n_of_k(&builder, 0, 0);
-
-		FINALIZE;
-		EQUALS(expectedEmptyNofKScriptHash);
-	}
-	{
-		BEFORE_EACH;
-
-		nativeScriptHashBuilder_startComplexScript_all(&builder, 1);
-		nativeScriptHashBuilder_startComplexScript_any(&builder, 1);
-		nativeScriptHashBuilder_startComplexScript_n_of_k(&builder, 0, 0);
-
-		FINALIZE;
-		EQUALS(expectedNestedComplexScripts);
-	}
-}
-
-#undef EQUALS
-#undef FINALIZE
-#undef BEFORE_EACH
-#undef BUF_FROM_STR
-#endif // DEVEL
+// #define BUF_FROM_STR(name, size) \
+// 	uint8_t name[size] = {0}; \
+// 	decode_hex(name##Str, name, size); \
+
+// #define BEFORE_EACH \
+// 	native_script_hash_builder_t builder; \
+// 	nativeScriptHashBuilder_init(&builder); \
+
+// #define FINALIZE \
+// 	uint8_t result[SCRIPT_HASH_LENGTH] = {0}; \
+// 	nativeScriptHashBuilder_finalize(&builder, result, ADDRESS_KEY_HASH_LENGTH);\
+// 	PRINTF("Native script hash hex\n");\
+// 	PRINTF("%.*h\n", 32, result);
+
+// #define EQUALS(name) \
+// 	BUF_FROM_STR(name, SCRIPT_HASH_LENGTH); \
+// 	EXPECT_EQ_BYTES(result, name, SCRIPT_HASH_LENGTH);
+
+// static const char* pubkeyHashStr = "3a55d9f68255dfbefa1efd711f82d005fae1be2e145d616c90cf0fa9";
+// static const char* expectedPubkeyScriptHashStr = "855228f5ecececf9c85618007cc3c2e5bdf5e6d41ef8d6fa793fe0eb";
+
+// static const uint64_t invalidBefore = 42;
+// static const char* expectedInvalidBeforeScriptHashStr = "2a25e608a683057e32ea38b50ce8875d5b34496b393da8d25d314c4e";
+
+// static const uint64_t invalidHereafter = 42;
+// static const char* expectedInvalidHereafterScriptHashStr = "1620dc65993296335183f23ff2f7747268168fabbeecbf24c8a20194";
+
+// static const char* expectedEmptyAllScriptHashStr = "d441227553a0f1a965fee7d60a0f724b368dd1bddbc208730fccebcf";
+// static const char* expectedEmptyAnyScriptHashStr = "52dc3d43b6d2465e96109ce75ab61abe5e9c1d8a3c9ce6ff8a3af528";
+// static const char* expectedEmptyNofKScriptHashStr = "3530cc9ae7f2895111a99b7a02184dd7c0cea7424f1632d73951b1d7";
+
+// static const char* expectedNestedComplexScriptsStr = "1f292766b9b0db263f8ecc087478f6aeea3c9fe091674153084e5668";
+
+// void run_nativeScriptHashBuilder_test()
+// {
+// 	PRINTF("nativeScriptHashBuilder test\n");
+// 	{
+// 		BEFORE_EACH;
+
+// 		BUF_FROM_STR(pubkeyHash, ADDRESS_KEY_HASH_LENGTH);
+// 		nativeScriptHashBuilder_addScript_pubkey(&builder, pubkeyHash, SIZEOF(pubkeyHash));
+
+// 		FINALIZE;
+// 		EQUALS(expectedPubkeyScriptHash);
+// 	}
+// 	{
+// 		BEFORE_EACH;
+
+// 		nativeScriptHashBuilder_addScript_invalidBefore(&builder, invalidBefore);
+
+// 		FINALIZE;
+// 		EQUALS(expectedInvalidBeforeScriptHash);
+// 	}
+// 	{
+// 		BEFORE_EACH;
+
+// 		nativeScriptHashBuilder_addScript_invalidHereafter(&builder, invalidHereafter);
+
+// 		FINALIZE;
+// 		EQUALS(expectedInvalidHereafterScriptHash);
+// 	}
+// 	{
+// 		BEFORE_EACH;
+
+// 		nativeScriptHashBuilder_startComplexScript_all(&builder, 0);
+
+// 		FINALIZE;
+// 		EQUALS(expectedEmptyAllScriptHash);
+// 	}
+// 	{
+// 		BEFORE_EACH;
+
+// 		nativeScriptHashBuilder_startComplexScript_any(&builder, 0);
+
+// 		FINALIZE;
+// 		EQUALS(expectedEmptyAnyScriptHash);
+// 	}
+// 	{
+// 		BEFORE_EACH;
+
+// 		nativeScriptHashBuilder_startComplexScript_n_of_k(&builder, 0, 0);
+
+// 		FINALIZE;
+// 		EQUALS(expectedEmptyNofKScriptHash);
+// 	}
+// 	{
+// 		BEFORE_EACH;
+
+// 		nativeScriptHashBuilder_startComplexScript_all(&builder, 1);
+// 		nativeScriptHashBuilder_startComplexScript_any(&builder, 1);
+// 		nativeScriptHashBuilder_startComplexScript_n_of_k(&builder, 0, 0);
+
+// 		FINALIZE;
+// 		EQUALS(expectedNestedComplexScripts);
+// 	}
+// }
+
+// #undef EQUALS
+// #undef FINALIZE
+// #undef BEFORE_EACH
+// #undef BUF_FROM_STR
+// #endif // DEVEL
diff --git a/src/runTests.c b/src/runTests.c
index 1588003..1ac0e21 100644
--- a/src/runTests.c
+++ b/src/runTests.c
@@ -1,60 +1,60 @@
-#ifdef DEVEL
+// #ifdef DEVEL
 
-#include "runTests.h"
-#include "cbor.h"
-#include "base58.h"
-#include "bech32.h"
-#include "testUtils.h"
-#include "hexUtils.h"
-#include "hash.h"
-#include "bip44.h"
-#include "keyDerivation.h"
-#include "addressUtilsByron.h"
-#include "addressUtilsShelley.h"
-#include "crc32.h"
-#include "txHashBuilder.h"
-#include "auxDataHashBuilder.h"
-#include "textUtils.h"
-#include "ipUtils.h"
-#include "uiHelpers.h"
-#include "tokens.h"
-#include "deriveNativeScriptHash.h"
+// #include "runTests.h"
+// #include "cbor.h"
+// #include "base58.h"
+// #include "bech32.h"
+// #include "testUtils.h"
+// #include "hexUtils.h"
+// #include "hash.h"
+// #include "bip44.h"
+// #include "keyDerivation.h"
+// #include "addressUtilsByron.h"
+// #include "addressUtilsShelley.h"
+// #include "crc32.h"
+// #include "txHashBuilder.h"
+// #include "auxDataHashBuilder.h"
+// #include "textUtils.h"
+// #include "ipUtils.h"
+// #include "uiHelpers.h"
+// #include "tokens.h"
+// #include "deriveNativeScriptHash.h"
 
 
-void handleRunTests(
-        uint8_t p1 MARK_UNUSED,
-        uint8_t p2 MARK_UNUSED,
-        uint8_t *wireBuffer MARK_UNUSED,
-        size_t wireSize MARK_UNUSED,
-        bool isNewCall MARK_UNUSED
-)
-{
-	// Note: Make sure to have RESET_ON_CRASH flag disabled
-	// as it interferes with tests verifying assertions
-	BEGIN_ASSERT_NOEXCEPT {
-		PRINTF("Running tests\n");
-		run_hex_test();
-		run_base58_test();
-		run_bech32_test();
-		run_crc32_test();
-		run_endian_test();
-		run_textUtils_test();
-		run_tokens_test();
-		run_ipUtils_test();
-		run_hash_test();
-		run_cbor_test();
-		run_bip44_test();
-		run_key_derivation_test();
-		run_addressUtilsByron_test();
-		run_addressUtilsShelley_test();
-		run_txHashBuilder_test();
-		run_auxDataHashBuilder_test();
-		run_nativeScriptHashBuilder_test();
-		PRINTF("All tests done\n");
-	} END_ASSERT_NOEXCEPT;
+// void handleRunTests(
+//         uint8_t p1 MARK_UNUSED,
+//         uint8_t p2 MARK_UNUSED,
+//         uint8_t *wireBuffer MARK_UNUSED,
+//         size_t wireSize MARK_UNUSED,
+//         bool isNewCall MARK_UNUSED
+// )
+// {
+// 	// Note: Make sure to have RESET_ON_CRASH flag disabled
+// 	// as it interferes with tests verifying assertions
+// 	BEGIN_ASSERT_NOEXCEPT {
+// 		PRINTF("Running tests\n");
+// 		run_hex_test();
+// 		run_base58_test();
+// 		run_bech32_test();
+// 		run_crc32_test();
+// 		run_endian_test();
+// 		run_textUtils_test();
+// 		run_tokens_test();
+// 		run_ipUtils_test();
+// 		run_hash_test();
+// 		run_cbor_test();
+// 		run_bip44_test();
+// 		run_key_derivation_test();
+// 		run_addressUtilsByron_test();
+// 		run_addressUtilsShelley_test();
+// 		run_txHashBuilder_test();
+// 		run_auxDataHashBuilder_test();
+// 		run_nativeScriptHashBuilder_test();
+// 		PRINTF("All tests done\n");
+// 	} END_ASSERT_NOEXCEPT;
 
-	io_send_buf(SUCCESS, NULL, 0);
-	ui_idle();
-}
+// 	io_send_buf(SUCCESS, NULL, 0);
+// 	ui_idle();
+// }
 
-#endif // DEVEL
+// #endif // DEVEL
diff --git a/src/runTests.h b/src/runTests.h
index 4dec40e..926c0c8 100644
--- a/src/runTests.h
+++ b/src/runTests.h
@@ -1,12 +1,12 @@
-#ifdef DEVEL
+// #ifdef DEVEL
 
-#ifndef H_CARDANO_APP_RUN_TESTS
-#define H_CARDANO_APP_RUN_TESTS
+// #ifndef H_CARDANO_APP_RUN_TESTS
+// #define H_CARDANO_APP_RUN_TESTS
 
-#include "handlers.h"
+// #include "handlers.h"
 
-handler_fn_t handleRunTests;
+// handler_fn_t handleRunTests;
 
-#endif // H_CARDANO_APP_RUN_TESTS
+// #endif // H_CARDANO_APP_RUN_TESTS
 
-#endif // DEVEL
+// #endif // DEVEL
diff --git a/src/securityPolicy.c b/src/securityPolicy.c
index 1be5402..9996041 100644
--- a/src/securityPolicy.c
+++ b/src/securityPolicy.c
@@ -33,12 +33,12 @@ static inline bool is_standard_base_address(const addressParams_t* addressParams
 #undef CHECK
 }
 
-static inline bool is_reward_address(const addressParams_t* addressParams)
-{
-	ASSERT(isValidAddressParams(addressParams));
+// static inline bool is_reward_address(const addressParams_t* addressParams)
+// {
+// 	ASSERT(isValidAddressParams(addressParams));
 
-	return addressParams->type == REWARD_KEY || addressParams->type == REWARD_SCRIPT;
-}
+// 	return addressParams->type == REWARD_KEY || addressParams->type == REWARD_SCRIPT;
+// }
 
 // spending part of the address is a script hash
 static inline bool allows_datum_hash(const uint8_t addressType)
@@ -80,13 +80,13 @@ security_policy_t policyForDerivePrivateKey(const bip44_path_t* path)
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
 
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
 
-	case PATH_MINT_KEY:
+	// case PATH_MINT_KEY:
 
-	case PATH_POOL_COLD_KEY:
+	// case PATH_POOL_COLD_KEY:
 
 		ALLOW();
 		break;
@@ -127,11 +127,11 @@ security_policy_t policyForGetExtendedPublicKey(const bip44_path_t* pathSpec)
 
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-	case PATH_MINT_KEY:
-	case PATH_POOL_COLD_KEY:
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MINT_KEY:
+	// case PATH_POOL_COLD_KEY:
 		WARN_UNLESS(bip44_isPathReasonable(pathSpec));
 		// ask for permission
 		PROMPT();
@@ -153,20 +153,20 @@ security_policy_t policyForGetExtendedPublicKeyBulkExport(const bip44_path_t* pa
 	case PATH_ORDINARY_ACCOUNT:
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-	case PATH_MINT_KEY:
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MINT_KEY:
 		WARN_UNLESS(bip44_isPathReasonable(pathSpec));
 		// we do not show these paths since there may be many of them
 		ALLOW();
 		break;
 
-	case PATH_POOL_COLD_KEY:
-		WARN_UNLESS(bip44_isPathReasonable(pathSpec));
-		// but ask for permission when pool cold key is requested
-		PROMPT();
-		break;
+	// case PATH_POOL_COLD_KEY:
+	// 	WARN_UNLESS(bip44_isPathReasonable(pathSpec));
+	// 	// but ask for permission when pool cold key is requested
+	// 	PROMPT();
+	// 	break;
 
 	default:
 		DENY();
@@ -269,10 +269,10 @@ bool isTxNetworkIdVerifiable(
 
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// pool registration certificate contains pool reward account
-		return true;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// pool registration certificate contains pool reward account
+	// 	return true;
 
 	default:
 		return false;
@@ -302,11 +302,11 @@ security_policy_t policyForSignTxInit(
         uint32_t networkId,
         uint32_t protocolMagic,
         uint16_t numOutputs,
-        uint16_t numCertificates,
+        // uint16_t numCertificates,
         uint16_t numWithdrawals,
-        bool includeMint,
+        // bool includeMint,
         uint16_t numCollaterals,
-        uint16_t numRequiredSigners,
+        // uint16_t numRequiredSigners,
         bool includeScriptDataHash,
         bool includeNetworkId
 )
@@ -320,27 +320,27 @@ security_policy_t policyForSignTxInit(
 	// mostly because of potential cross-witnessing
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// necessary to avoid intermingling witnesses from several certs
-		DENY_UNLESS(numCertificates == 1);
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// necessary to avoid intermingling witnesses from several certs
+	// 	DENY_UNLESS(numCertificates == 1);
 
-		// witnesses for owners and withdrawals are the same
-		// we forbid withdrawals so that users cannot be tricked into witnessing
-		// something unintentionally (e.g. an owner given by the staking key hash)
-		DENY_UNLESS(numWithdrawals == 0);
+	// 	// witnesses for owners and withdrawals are the same
+	// 	// we forbid withdrawals so that users cannot be tricked into witnessing
+	// 	// something unintentionally (e.g. an owner given by the staking key hash)
+	// 	DENY_UNLESS(numWithdrawals == 0);
 
-		// mint must not be combined with pool registration certificates
-		DENY_IF(includeMint);
+	// 	// mint must not be combined with pool registration certificates
+	// 	DENY_IF(includeMint);
 
-		// no Plutus elements for pool registrations
-		DENY_IF(includeScriptDataHash);
-		DENY_IF(numCollaterals > 0);
-		DENY_IF(numRequiredSigners > 0);
-		break;
+	// 	// no Plutus elements for pool registrations
+	// 	DENY_IF(includeScriptDataHash);
+	// 	DENY_IF(numCollaterals > 0);
+	// 	DENY_IF(numRequiredSigners > 0);
+	// 	break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		// collaterals are allowed only in PLUTUS_TX
 		DENY_IF(numCollaterals > 0);
 		break;
@@ -386,9 +386,9 @@ security_policy_t policyForSignTxInput(sign_tx_signingmode_t txSigningMode)
 		break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		// inputs are not interesting for the user (transferred funds are shown in the outputs)
 		ALLOW();
 		break;
@@ -440,22 +440,22 @@ security_policy_t policyForSignTxOutputAddressBytes(
 		// no Plutus elements for pool registration, only allow in other modes
 		DENY_UNLESS(
 		        txSigningMode == SIGN_TX_SIGNINGMODE_ORDINARY_TX ||
-		        txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
+		        // txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
 		        txSigningMode == SIGN_TX_SIGNINGMODE_PLUTUS_TX
 		);
 	}
 
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// all the funds are provided by the operator
-		// and thus outputs are irrelevant to the owner (even those having tokens or datum hash)
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// all the funds are provided by the operator
+	// 	// and thus outputs are irrelevant to the owner (even those having tokens or datum hash)
+	// 	ALLOW();
+	// 	break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		// utxo on a Plutus script address without datum hash is unspendable
 		// but we can't DENY because it is valid for native scripts
@@ -522,14 +522,14 @@ security_policy_t policyForSignTxOutputAddressParams(
 		// no Plutus elements for pool registration, only allow in other modes
 		DENY_UNLESS(
 		        txSigningMode == SIGN_TX_SIGNINGMODE_ORDINARY_TX ||
-		        txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
+		        // txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
 		        txSigningMode == SIGN_TX_SIGNINGMODE_PLUTUS_TX
 		);
 	}
 
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX: {
 		// unusual paths or spending and staking path mismatch
 		SHOW_UNLESS(is_standard_base_address(params));
@@ -542,14 +542,14 @@ security_policy_t policyForSignTxOutputAddressParams(
 		break;
 	}
 
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX: {
-		// for simplicity, all outputs should be given as external addresses;
-		// generally, more than one party is needed to sign
-		// spending from a multisig address, so we do not expect
-		// there will be 1852 outputs (that would be considered change)
-		DENY();
-		break;
-	}
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX: {
+	// 	// for simplicity, all outputs should be given as external addresses;
+	// 	// generally, more than one party is needed to sign
+	// 	// spending from a multisig address, so we do not expect
+	// 	// there will be 1852 outputs (that would be considered change)
+	// 	DENY();
+	// 	break;
+	// }
 
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX: {
 		// the output could affect script validation so it must not be entirely hidden
@@ -559,13 +559,13 @@ security_policy_t policyForSignTxOutputAddressParams(
 		break;
 	}
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER: {
-		// we forbid these to avoid leaking information
-		// (since the outputs are not shown, the user is unaware of what addresses are being derived)
-		// it also makes the tx signing faster if all outputs are given as addresses
-		DENY();
-		break;
-	}
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER: {
+	// 	// we forbid these to avoid leaking information
+	// 	// (since the outputs are not shown, the user is unaware of what addresses are being derived)
+	// 	// it also makes the tx signing faster if all outputs are given as addresses
+	// 	DENY();
+	// 	break;
+	// }
 
 	default:
 		ASSERT(false);
@@ -637,18 +637,18 @@ security_policy_t policyForSignTxFee(
 {
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		// always show the fee if it is paid by the signer
 		SHOW();
 		break;
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// fees are paid by the operator and are thus irrelevant for owners
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// fees are paid by the operator and are thus irrelevant for owners
+	// 	ALLOW();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -680,20 +680,20 @@ security_policy_t policyForSignTxCertificate(
 		ALLOW();
 		break;
 
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-		// pool registration is allowed only in POOL_REGISTRATION signging modes
-		DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
-		// pool retirement is impossible with multisig keys
-		DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// 	// pool registration is allowed only in POOL_REGISTRATION signging modes
+	// 	DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
+	// 	// pool retirement is impossible with multisig keys
+	// 	DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
+	// 	ALLOW();
+	// 	break;
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// only pool registration is allowed
-		DENY_UNLESS(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// only pool registration is allowed
+	// 	DENY_UNLESS(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
+	// 	ALLOW();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -729,9 +729,9 @@ security_policy_t policyForSignTxCertificateStaking(
 			PROMPT();
 			break;
 
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -748,9 +748,9 @@ security_policy_t policyForSignTxCertificateStaking(
 			break;
 
 		case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -787,199 +787,199 @@ security_policy_t policyForSignTxCertificateStaking(
 	DENY(); // should not be reached
 }
 
-security_policy_t policyForSignTxCertificateStakePoolRetirement(
-        sign_tx_signingmode_t txSigningMode,
-        const bip44_path_t* poolIdPath,
-        uint64_t epoch MARK_UNUSED
-)
-{
-	switch (txSigningMode) {
-
-	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-		// pool retirement may only be present in ORDINARY_TX signing mode
-		// the path hash should be a valid pool cold key path
-		DENY_UNLESS(bip44_isPoolColdKeyPath(poolIdPath));
-		PROMPT();
-		break;
-
-	default:
-		// in other signing modes, the tx containing pool retirement certificate
-		// should have already been reported as invalid
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationInit(
-        sign_tx_signingmode_t txSigningMode,
-        uint32_t numOwners
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// there should be exactly one owner given by path for which we provide a witness
-		DENY_IF(numOwners == 0);
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
-		DENY();
-		break;
-
-	default:
-		ASSERT(false);
-		break;
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationPoolId(
-        sign_tx_signingmode_t txSigningMode,
-        const pool_id_t* poolId
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// owner should see a hash
-		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_HASH);
-		SHOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		// operator should see a path
-		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_PATH);
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
-        sign_tx_signingmode_t txSigningMode
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// not interesting for an owner
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
-        sign_tx_signingmode_t txSigningMode,
-        const reward_account_t* poolRewardAccount MARK_UNUSED
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationOwner(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_owner_t* owner,
-        uint32_t numOwnersGivenByPath
-)
-{
-	if (owner->keyReferenceType == KEY_REFERENCE_PATH) {
-		// when path is present, it should be a valid staking path
-		DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(&owner->path));
-		DENY_IF(violatesSingleAccountOrStoreIt(&owner->path));
-	}
-
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// can be 0 while processing owners given by hash
-		// or if no path owner is given at all (then we just compute the tx hash and don't allow witnesses)
-		DENY_UNLESS(numOwnersGivenByPath <= 1);
-		SHOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		// operator should receive owners given by hash
-		ASSERT(numOwnersGivenByPath == 0);
-		DENY_UNLESS(owner->keyReferenceType == KEY_REFERENCE_HASH);
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationRelay(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_relay_t* relay MARK_UNUSED
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// not interesting for an owner
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationMetadata()
-{
-	SHOW();
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationNoMetadata()
-{
-	SHOW();
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationConfirm(
-        uint32_t numOwners, uint32_t numRelays
-)
-{
-	// notify the user if there are no owners and/or relays
-	PROMPT_IF(numOwners == 0);
-	PROMPT_IF(numRelays == 0);
-
-	ALLOW();
-}
+// security_policy_t policyForSignTxCertificateStakePoolRetirement(
+//         sign_tx_signingmode_t txSigningMode,
+//         const bip44_path_t* poolIdPath,
+//         uint64_t epoch MARK_UNUSED
+// )
+// {
+// 	switch (txSigningMode) {
+
+// 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
+// 		// pool retirement may only be present in ORDINARY_TX signing mode
+// 		// the path hash should be a valid pool cold key path
+// 		DENY_UNLESS(bip44_isPoolColdKeyPath(poolIdPath));
+// 		PROMPT();
+// 		break;
+
+// 	default:
+// 		// in other signing modes, the tx containing pool retirement certificate
+// 		// should have already been reported as invalid
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationInit(
+//         sign_tx_signingmode_t txSigningMode,
+//         uint32_t numOwners
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// there should be exactly one owner given by path for which we provide a witness
+// 		DENY_IF(numOwners == 0);
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
+// 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+// 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
+// 		DENY();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 		break;
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationPoolId(
+//         sign_tx_signingmode_t txSigningMode,
+//         const pool_id_t* poolId
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// owner should see a hash
+// 		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_HASH);
+// 		SHOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		// operator should see a path
+// 		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_PATH);
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
+//         sign_tx_signingmode_t txSigningMode
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// not interesting for an owner
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
+//         sign_tx_signingmode_t txSigningMode,
+//         const reward_account_t* poolRewardAccount MARK_UNUSED
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationOwner(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_owner_t* owner,
+//         uint32_t numOwnersGivenByPath
+// )
+// {
+// 	if (owner->keyReferenceType == KEY_REFERENCE_PATH) {
+// 		// when path is present, it should be a valid staking path
+// 		DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(&owner->path));
+// 		DENY_IF(violatesSingleAccountOrStoreIt(&owner->path));
+// 	}
+
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// can be 0 while processing owners given by hash
+// 		// or if no path owner is given at all (then we just compute the tx hash and don't allow witnesses)
+// 		DENY_UNLESS(numOwnersGivenByPath <= 1);
+// 		SHOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		// operator should receive owners given by hash
+// 		ASSERT(numOwnersGivenByPath == 0);
+// 		DENY_UNLESS(owner->keyReferenceType == KEY_REFERENCE_HASH);
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationRelay(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_relay_t* relay MARK_UNUSED
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// not interesting for an owner
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationMetadata()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationNoMetadata()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationConfirm(
+//         uint32_t numOwners, uint32_t numRelays
+// )
+// {
+// 	// notify the user if there are no owners and/or relays
+// 	PROMPT_IF(numOwners == 0);
+// 	PROMPT_IF(numRelays == 0);
+
+// 	ALLOW();
+// }
 
 // For each withdrawal
 security_policy_t policyForSignTxWithdrawal(
@@ -998,10 +998,10 @@ security_policy_t policyForSignTxWithdrawal(
 			ALLOW();
 			break;
 
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			// script hash is expected for multisig txs
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	// script hash is expected for multisig txs
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -1026,10 +1026,10 @@ security_policy_t policyForSignTxWithdrawal(
 			DENY();
 			break;
 
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			// script hash is expected for multisig txs
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	// script hash is expected for multisig txs
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -1040,7 +1040,7 @@ security_policy_t policyForSignTxWithdrawal(
 
 	case STAKE_CREDENTIAL_SCRIPT_HASH:
 		switch (txSigningMode) {
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 			SHOW_IF(app_mode_expert());
 			ALLOW();
@@ -1081,19 +1081,19 @@ static inline security_policy_t _ordinaryWitnessPolicy(const bip44_path_t* path,
 		ALLOW();
 		break;
 
-	case PATH_POOL_COLD_KEY:
-		// ordinary key paths and pool cold key paths can be hidden if they are not unusual
-		// (the user saw all outputs, withdrawals and pool certificates and they all belong to him)
-		WARN_UNLESS(bip44_isPathReasonable(path));
-		SHOW();
-		break;
+	// case PATH_POOL_COLD_KEY:
+	// 	// ordinary key paths and pool cold key paths can be hidden if they are not unusual
+	// 	// (the user saw all outputs, withdrawals and pool certificates and they all belong to him)
+	// 	WARN_UNLESS(bip44_isPathReasonable(path));
+	// 	SHOW();
+	// 	break;
 
-	case PATH_MINT_KEY:
-		DENY_UNLESS(mintPresent);
-		// maybe not necessary, but let the user know which mint key is he using (eg. in case
-		// the minting policy contains multiple of his keys but with different rules)
-		SHOW();
-		break;
+	// case PATH_MINT_KEY:
+	// 	DENY_UNLESS(mintPresent);
+	// 	// maybe not necessary, but let the user know which mint key is he using (eg. in case
+	// 	// the minting policy contains multiple of his keys but with different rules)
+	// 	SHOW();
+	// 	break;
 
 	default:
 		// multisig keys forbidden
@@ -1102,31 +1102,31 @@ static inline security_policy_t _ordinaryWitnessPolicy(const bip44_path_t* path,
 	}
 }
 
-static inline security_policy_t _multisigWitnessPolicy(const bip44_path_t* path, bool mintPresent)
-{
-	switch (bip44_classifyPath(path)) {
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-		// multisig key paths are allowed, but hiding them would make impossible for the user to
-		// distinguish what funds are being spent (multisig UTXOs sharing a signer are not
-		// necessarily interchangeable, because they may be governed by a different script)
-		WARN_UNLESS(bip44_isPathReasonable(path));
-		SHOW();
-		break;
-
-	case PATH_MINT_KEY:
-		DENY_UNLESS(mintPresent);
-		// maybe not necessary, but let the user know which mint key is he using (eg. in case
-		// the minting policy contains multiple of his keys but with different rules)
-		SHOW();
-		break;
-
-	default:
-		// ordinary and pool cold keys forbidden
-		DENY();
-		break;
-	}
-}
+// static inline security_policy_t _multisigWitnessPolicy(const bip44_path_t* path, bool mintPresent)
+// {
+// 	switch (bip44_classifyPath(path)) {
+// 	case PATH_MULTISIG_SPENDING_KEY:
+// 	case PATH_MULTISIG_STAKING_KEY:
+// 		// multisig key paths are allowed, but hiding them would make impossible for the user to
+// 		// distinguish what funds are being spent (multisig UTXOs sharing a signer are not
+// 		// necessarily interchangeable, because they may be governed by a different script)
+// 		WARN_UNLESS(bip44_isPathReasonable(path));
+// 		SHOW();
+// 		break;
+
+// 	case PATH_MINT_KEY:
+// 		DENY_UNLESS(mintPresent);
+// 		// maybe not necessary, but let the user know which mint key is he using (eg. in case
+// 		// the minting policy contains multiple of his keys but with different rules)
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		// ordinary and pool cold keys forbidden
+// 		DENY();
+// 		break;
+// 	}
+// }
 
 static inline security_policy_t _plutusWitnessPolicy(const bip44_path_t* path, bool mintPresent)
 {
@@ -1134,69 +1134,69 @@ static inline security_policy_t _plutusWitnessPolicy(const bip44_path_t* path, b
 	// in PLUTUS_TX, we allow signing with any path, but it must be shown
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
 		WARN_UNLESS(bip44_isPathReasonable(path));
 		SHOW();
 		break;
 
-	case PATH_MINT_KEY:
-		// mint witness without mint in the tx: somewhat suspicious,
-		// no known usecase, but a mint path could be e.g. in required signers
-		SHOW_UNLESS(mintPresent);
-		// maybe not necessary, but let the user know which mint key is he using (e.g. in case
-		// the minting policy contains multiple of his keys but with different rules)
-		SHOW();
-		break;
-
-	case PATH_POOL_COLD_KEY:
-	default:
-		DENY();
-		break;
-	}
-}
-
-static inline security_policy_t _poolRegistrationOwnerWitnessPolicy(const bip44_path_t* witnessPath, const bip44_path_t* poolOwnerPath)
-{
-	switch (bip44_classifyPath(witnessPath)) {
-
-	case PATH_ORDINARY_STAKING_KEY:
-		if (poolOwnerPath != NULL) {
-			// an owner was given by path
-			// the witness path must be identical
-			DENY_UNLESS(bip44_pathsEqual(witnessPath, poolOwnerPath));
-		} else {
-			// no owner was given by path
-			// we must not allow witnesses because they might witness owners given by key hash
-			DENY();
-		}
-		WARN_UNLESS(bip44_isPathReasonable(witnessPath));
-		SHOW();
-		break;
+	// case PATH_MINT_KEY:
+	// 	// mint witness without mint in the tx: somewhat suspicious,
+	// 	// no known usecase, but a mint path could be e.g. in required signers
+	// 	SHOW_UNLESS(mintPresent);
+	// 	// maybe not necessary, but let the user know which mint key is he using (e.g. in case
+	// 	// the minting policy contains multiple of his keys but with different rules)
+	// 	SHOW();
+	// 	break;
 
+	// case PATH_POOL_COLD_KEY:
 	default:
 		DENY();
 		break;
 	}
 }
 
-static inline security_policy_t _poolRegistrationOperatorWitnessPolicy(const bip44_path_t* path)
-{
-	switch (bip44_classifyPath(path)) {
-
-	case PATH_ORDINARY_SPENDING_KEY:
-	case PATH_POOL_COLD_KEY:
-		// only ordinary spending key paths (because of inputs) and pool cold key path are allowed
-		WARN_UNLESS(bip44_isPathReasonable(path));
-		// TODO is there a reason to show the witnesses?
-		SHOW();
-		break;
-
-	default:
-		DENY();
-		break;
-	}
-}
+// static inline security_policy_t _poolRegistrationOwnerWitnessPolicy(const bip44_path_t* witnessPath, const bip44_path_t* poolOwnerPath)
+// {
+// 	switch (bip44_classifyPath(witnessPath)) {
+
+// 	case PATH_ORDINARY_STAKING_KEY:
+// 		if (poolOwnerPath != NULL) {
+// 			// an owner was given by path
+// 			// the witness path must be identical
+// 			DENY_UNLESS(bip44_pathsEqual(witnessPath, poolOwnerPath));
+// 		} else {
+// 			// no owner was given by path
+// 			// we must not allow witnesses because they might witness owners given by key hash
+// 			DENY();
+// 		}
+// 		WARN_UNLESS(bip44_isPathReasonable(witnessPath));
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		DENY();
+// 		break;
+// 	}
+// }
+
+// static inline security_policy_t _poolRegistrationOperatorWitnessPolicy(const bip44_path_t* path)
+// {
+// 	switch (bip44_classifyPath(path)) {
+
+// 	case PATH_ORDINARY_SPENDING_KEY:
+// 	case PATH_POOL_COLD_KEY:
+// 		// only ordinary spending key paths (because of inputs) and pool cold key path are allowed
+// 		WARN_UNLESS(bip44_isPathReasonable(path));
+// 		// TODO is there a reason to show the witnesses?
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		DENY();
+// 		break;
+// 	}
+// }
 
 // For each transaction witness
 // Note: witnesses reveal public key of an address and Ledger *does not* check
@@ -1204,25 +1204,25 @@ static inline security_policy_t _poolRegistrationOperatorWitnessPolicy(const bip
 security_policy_t policyForSignTxWitness(
         sign_tx_signingmode_t txSigningMode,
         const bip44_path_t* witnessPath,
-        bool mintPresent,
-        const bip44_path_t* poolOwnerPath
+        bool mintPresent
+        // const bip44_path_t* poolOwnerPath
 )
 {
 	switch (txSigningMode) {
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 		return _ordinaryWitnessPolicy(witnessPath, mintPresent);
 
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-		return _multisigWitnessPolicy(witnessPath, mintPresent);
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// 	return _multisigWitnessPolicy(witnessPath, mintPresent);
 
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		return _plutusWitnessPolicy(witnessPath, mintPresent);
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		return _poolRegistrationOwnerWitnessPolicy(witnessPath, poolOwnerPath);
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	return _poolRegistrationOwnerWitnessPolicy(witnessPath, poolOwnerPath);
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		return _poolRegistrationOperatorWitnessPolicy(witnessPath);
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// 	return _poolRegistrationOperatorWitnessPolicy(witnessPath);
 
 	default:
 		ASSERT(false);
@@ -1240,12 +1240,12 @@ security_policy_t policyForSignTxAuxData(aux_data_type_t auxDataType)
 		SHOW_IF(app_mode_expert());
 		ALLOW();
 
-	case AUX_DATA_TYPE_CATALYST_REGISTRATION:
-		// this is the policy for the initial prompt
-		// details of the registration are governed by separate policies
-		// (see policyForCatalystRegistration...)
-		SHOW();
-		break;
+	// case AUX_DATA_TYPE_CATALYST_REGISTRATION:
+	// 	// this is the policy for the initial prompt
+	// 	// details of the registration are governed by separate policies
+	// 	// (see policyForCatalystRegistration...)
+	// 	SHOW();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -1262,59 +1262,59 @@ security_policy_t policyForSignTxValidityIntervalStart()
 }
 
 // For transaction mint field
-security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
-		SHOW();
-		break;
-
-	default:
-		// in POOL_REGISTRATION signing modes, non-empty mint field
-		// should have already been reported as invalid
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-// For final mint confirmation
-security_policy_t policyForSignTxMintConfirm(security_policy_t mintInitPolicy)
-{
-	switch (mintInitPolicy) {
-	case POLICY_ALLOW_WITHOUT_PROMPT:
-		ALLOW();
-		break;
-
-	case POLICY_SHOW_BEFORE_RESPONSE:
-		// all minted coins were shown, show a final cofirmation prompt as well
-		PROMPT();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
+// security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode)
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
+// 	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+// 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		// in POOL_REGISTRATION signing modes, non-empty mint field
+// 		// should have already been reported as invalid
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// // For final mint confirmation
+// security_policy_t policyForSignTxMintConfirm(security_policy_t mintInitPolicy)
+// {
+// 	switch (mintInitPolicy) {
+// 	case POLICY_ALLOW_WITHOUT_PROMPT:
+// 		ALLOW();
+// 		break;
+
+// 	case POLICY_SHOW_BEFORE_RESPONSE:
+// 		// all minted coins were shown, show a final cofirmation prompt as well
+// 		PROMPT();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
 
 // For transaction script data hash
 security_policy_t policyForSignTxScriptDataHash(const sign_tx_signingmode_t txSigningMode)
 {
 	switch (txSigningMode) {
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		SHOW_IF(app_mode_expert());
 		ALLOW();
 		break;
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		DENY();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// 	DENY();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -1337,9 +1337,9 @@ security_policy_t policyForSignTxCollateral(const sign_tx_signingmode_t txSignin
 		break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 		// collaterals allowed only if Plutus script is to be executed
 		DENY();
 		break;
@@ -1356,7 +1356,7 @@ static bool required_signers_allowed(const sign_tx_signingmode_t txSigningMode)
 	switch (txSigningMode) {
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		return true;
 
 	default:
@@ -1372,13 +1372,13 @@ static bool is_required_signer_allowed(bip44_path_t *path)
 	case PATH_ORDINARY_STAKING_KEY:
 		return bip44_hasShelleyPrefix(path);
 
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-		return true;
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
+	// 	return true;
 
-	case PATH_MINT_KEY:
-		return true;
+	// case PATH_MINT_KEY:
+	// 	return true;
 
 	default:
 		return false;
@@ -1417,61 +1417,61 @@ security_policy_t policyForSignTxConfirm()
 	PROMPT();
 }
 
-security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
-        const addressParams_t* params,
-        const uint8_t networkId
-)
-{
-	DENY_UNLESS(isValidAddressParams(params));
-	DENY_UNLESS(isShelleyAddressType(params->type));
-	DENY_IF(params->networkId != networkId);
-
-	WARN_UNLESS(is_reward_address(params) || is_standard_base_address(params));
-
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationStakingKey(
-        const bip44_path_t* stakingKeyPath
-)
-{
-	DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(stakingKeyPath));
-	WARN_UNLESS(bip44_hasReasonableAccount(stakingKeyPath));
-
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationVotingKey()
-{
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationNonce()
-{
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationConfirm()
-{
-	PROMPT();
-}
-
-security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec)
-{
-	switch (bip44_classifyPath(poolColdKeyPathSpec)) {
-
-	case PATH_POOL_COLD_KEY:
-		if (bip44_isPathReasonable(poolColdKeyPathSpec)) {
-			PROMPT();
-		} else {
-			WARN();
-		}
-		break;
-
-	default:
-		DENY();
-		break;
-	}
-
-	DENY(); // should not be reached
-}
+// security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
+//         const addressParams_t* params,
+//         const uint8_t networkId
+// )
+// {
+// 	DENY_UNLESS(isValidAddressParams(params));
+// 	DENY_UNLESS(isShelleyAddressType(params->type));
+// 	DENY_IF(params->networkId != networkId);
+
+// 	WARN_UNLESS(is_reward_address(params) || is_standard_base_address(params));
+
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationStakingKey(
+//         const bip44_path_t* stakingKeyPath
+// )
+// {
+// 	DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(stakingKeyPath));
+// 	WARN_UNLESS(bip44_hasReasonableAccount(stakingKeyPath));
+
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationVotingKey()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationNonce()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationConfirm()
+// {
+// 	PROMPT();
+// }
+
+// security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec)
+// {
+// 	switch (bip44_classifyPath(poolColdKeyPathSpec)) {
+
+// 	case PATH_POOL_COLD_KEY:
+// 		if (bip44_isPathReasonable(poolColdKeyPathSpec)) {
+// 			PROMPT();
+// 		} else {
+// 			WARN();
+// 		}
+// 		break;
+
+// 	default:
+// 		DENY();
+// 		break;
+// 	}
+
+// 	DENY(); // should not be reached
+// }
diff --git a/src/securityPolicy.h b/src/securityPolicy.h
index 48cba45..351c461 100644
--- a/src/securityPolicy.h
+++ b/src/securityPolicy.h
@@ -5,7 +5,7 @@
 #include "bip44.h"
 #include "cardano.h"
 #include "securityPolicyType.h"
-#include "signTxPoolRegistration.h"
+// #include "signTxPoolRegistration.h"
 #include "signTxAuxData.h"
 #include "signTx.h"
 
@@ -34,11 +34,11 @@ security_policy_t policyForSignTxInit(
         uint32_t networkId,
         uint32_t protocolMagic,
         uint16_t numOutputs,
-        uint16_t numCertificates,
+        // uint16_t numCertificates,
         uint16_t numWithdrawals,
-        bool includeMint,
+        // bool includeMint,
         uint16_t numCollaterals,
-        uint16_t numRequiredSigners,
+        // uint16_t numRequiredSigners,
         bool includeScriptDataHash,
         bool includeNetworkId
 );
@@ -78,40 +78,40 @@ security_policy_t policyForSignTxCertificateStaking(
         const certificate_type_t certificateType,
         const stake_credential_t* stakeCredential
 );
-security_policy_t policyForSignTxCertificateStakePoolRetirement(
-        sign_tx_signingmode_t txSigningMode,
-        const bip44_path_t* stakeCredential,
-        uint64_t epoch
-);
-security_policy_t policyForSignTxStakePoolRegistrationInit(
-        sign_tx_signingmode_t txSigningMode,
-        uint32_t numOwners
-);
-security_policy_t policyForSignTxStakePoolRegistrationPoolId(
-        sign_tx_signingmode_t txSigningMode,
-        const pool_id_t* poolId
-);
-security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
-        sign_tx_signingmode_t txSigningMode
-);
-security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
-        sign_tx_signingmode_t txSigningMode,
-        const reward_account_t* poolRewardAccount
-);
-security_policy_t policyForSignTxStakePoolRegistrationOwner(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_owner_t* owner,
-        uint32_t numOwnersGivenByPath
-);
-security_policy_t policyForSignTxStakePoolRegistrationRelay(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_relay_t* relay
-);
-security_policy_t policyForSignTxStakePoolRegistrationMetadata();
-security_policy_t policyForSignTxStakePoolRegistrationNoMetadata();
-security_policy_t policyForSignTxStakePoolRegistrationConfirm(
-        uint32_t numOwners, uint32_t numRelays
-);
+// security_policy_t policyForSignTxCertificateStakePoolRetirement(
+//         sign_tx_signingmode_t txSigningMode,
+//         const bip44_path_t* stakeCredential,
+//         uint64_t epoch
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationInit(
+//         sign_tx_signingmode_t txSigningMode,
+//         uint32_t numOwners
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationPoolId(
+//         sign_tx_signingmode_t txSigningMode,
+//         const pool_id_t* poolId
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
+//         sign_tx_signingmode_t txSigningMode
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
+//         sign_tx_signingmode_t txSigningMode,
+//         const reward_account_t* poolRewardAccount
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationOwner(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_owner_t* owner,
+//         uint32_t numOwnersGivenByPath
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationRelay(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_relay_t* relay
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationMetadata();
+// security_policy_t policyForSignTxStakePoolRegistrationNoMetadata();
+// security_policy_t policyForSignTxStakePoolRegistrationConfirm(
+//         uint32_t numOwners, uint32_t numRelays
+// );
 
 security_policy_t policyForSignTxWithdrawal(
         sign_tx_signingmode_t txSigningMode,
@@ -122,8 +122,8 @@ security_policy_t policyForSignTxAuxData(aux_data_type_t auxDataType);
 
 security_policy_t policyForSignTxValidityIntervalStart();
 
-security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode);
-security_policy_t policyForSignTxMintConfirm(security_policy_t outputPolicy);
+// security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode);
+// security_policy_t policyForSignTxMintConfirm(security_policy_t outputPolicy);
 
 security_policy_t policyForSignTxScriptDataHash(const sign_tx_signingmode_t txSigningMode);
 
@@ -137,23 +137,23 @@ security_policy_t policyForSignTxRequiredSigner(
 security_policy_t policyForSignTxWitness(
         sign_tx_signingmode_t txSigningMode,
         const bip44_path_t* witnessPath,
-        bool mintPresent,
-        const bip44_path_t* poolOwnerPath
+        bool mintPresent
+        // const bip44_path_t* poolOwnerPath
 );
 
 security_policy_t policyForSignTxConfirm();
 
-security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec);
-
-security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
-        const addressParams_t* params,
-        const uint8_t networkId
-);
-security_policy_t policyForCatalystRegistrationStakingKey(
-        const bip44_path_t* stakingKeyPath
-);
-security_policy_t policyForCatalystRegistrationVotingKey();
-security_policy_t policyForCatalystRegistrationNonce();
-security_policy_t policyForCatalystRegistrationConfirm();
+// security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec);
+
+// security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
+//         const addressParams_t* params,
+//         const uint8_t networkId
+// );
+// security_policy_t policyForCatalystRegistrationStakingKey(
+//         const bip44_path_t* stakingKeyPath
+// );
+// security_policy_t policyForCatalystRegistrationVotingKey();
+// security_policy_t policyForCatalystRegistrationNonce();
+// security_policy_t policyForCatalystRegistrationConfirm();
 
 #endif // H_CARDANO_APP_SECURITY_POLICY
diff --git a/src/signOpCert.c b/src/signOpCert.c
index 6bf0794..f1c16da 100644
--- a/src/signOpCert.c
+++ b/src/signOpCert.c
@@ -1,205 +1,205 @@
-#include "common.h"
-
-#include "signOpCert.h"
-#include "keyDerivation.h"
-#include "endian.h"
-#include "state.h"
-#include "uiHelpers.h"
-#include "uiScreens.h"
-#include "securityPolicy.h"
-#include "messageSigning.h"
-#include "textUtils.h"
-
-static ins_sign_op_cert_context_t* ctx = &(instructionState.signOpCertContext);
-
-
-static int16_t RESPONSE_READY_MAGIC = 31678;
-
-// forward declaration
-static void signOpCert_ui_runStep();
-enum {
-	UI_STEP_WARNING = 100,
-	UI_STEP_CONFIRM_START,
-	UI_STEP_DISPLAY_POOL_COLD_KEY_PATH,
-	UI_STEP_DISPLAY_POOL_ID,
-	UI_STEP_DISPLAY_KES_PUBLIC_KEY,
-	UI_STEP_DISPLAY_KES_PERIOD,
-	UI_STEP_DISPLAY_ISSUE_COUNTER,
-	UI_STEP_CONFIRM,
-	UI_STEP_RESPOND,
-	UI_STEP_INVALID,
-};
-
-void signOpCert_handleAPDU(
-        uint8_t p1,
-        uint8_t p2,
-        uint8_t *wireDataBuffer,
-        size_t wireDataSize,
-        bool isNewCall
-)
-{
-	// Initialize state
-	if (isNewCall) {
-		explicit_bzero(ctx, SIZEOF(*ctx));
-	}
-	ctx->responseReadyMagic = 0;
-
-	// Validate params
-	VALIDATE(p1 == P1_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
-	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
-
-	{
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		STATIC_ASSERT(SIZEOF(ctx->kesPublicKey) == KES_PUBLIC_KEY_LENGTH, "wrong KES public key size");
-		view_parseBuffer(ctx->kesPublicKey, &view, KES_PUBLIC_KEY_LENGTH);
-		TRACE("KES key:");
-		TRACE_BUFFER(ctx->kesPublicKey, KES_PUBLIC_KEY_LENGTH);
-
-		ctx->kesPeriod = parse_u8be(&view);
-		TRACE("KES period:");
-		TRACE_UINT64(ctx->kesPeriod);
-
-		ctx->issueCounter = parse_u8be(&view);
-		TRACE("Issue counter:");
-		TRACE_UINT64(ctx->issueCounter);
-
-		view_skipBytes(&view, bip44_parseFromWire(&ctx->poolColdKeyPathSpec, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	// Check security policy
-	security_policy_t policy = policyForSignOpCert(&ctx->poolColdKeyPathSpec);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		uint8_t opCertBodyBuffer[OP_CERT_BODY_LENGTH] = {0};
-		write_view_t opCertBodyBufferView = make_write_view(opCertBodyBuffer, opCertBodyBuffer + OP_CERT_BODY_LENGTH);
-
-		view_appendBuffer(&opCertBodyBufferView, (const uint8_t*) &ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey));
-		{
-			uint8_t chunk[8] = {0};
-			u8be_write(chunk, ctx->issueCounter);
-			#ifdef FUZZING
-			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
-			#else
-			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
-			#endif
-		}
-		{
-			uint8_t chunk[8] = {0};
-			u8be_write(chunk, ctx->kesPeriod);
-			#ifdef FUZZING
-			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
-			#else
-			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
-			#endif
-		}
-
-		ASSERT(view_processedSize(&opCertBodyBufferView) == OP_CERT_BODY_LENGTH);
-		TRACE_BUFFER(opCertBodyBuffer, SIZEOF(opCertBodyBuffer));
-
-		getOpCertSignature(
-		        &ctx->poolColdKeyPathSpec,
-		        opCertBodyBuffer,
-		        OP_CERT_BODY_LENGTH,
-		        ctx->signature,
-		        SIZEOF(ctx->signature)
-		);
-	}
-	ctx->responseReadyMagic = RESPONSE_READY_MAGIC;
-
-	switch (policy) {
-#define  CASE(policy, step) case policy: {ctx->ui_step = step; break;}
-		CASE(POLICY_PROMPT_WARN_UNUSUAL,    UI_STEP_WARNING);
-		CASE(POLICY_PROMPT_BEFORE_RESPONSE, UI_STEP_CONFIRM_START);
-		CASE(POLICY_ALLOW_WITHOUT_PROMPT,   UI_STEP_RESPOND);
-#undef   CASE
-	default:
-		THROW(ERR_NOT_IMPLEMENTED);
-	}
-	signOpCert_ui_runStep();
-}
-
-static void signOpCert_ui_runStep()
-{
-	ui_callback_fn_t* this_fn = signOpCert_ui_runStep;
-
-	UI_STEP_BEGIN(ctx->ui_step, this_fn);
-
-	UI_STEP(UI_STEP_WARNING) {
-		ui_displayPaginatedText(
-		        "Unusual request",
-		        "Proceed with care",
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_CONFIRM_START) {
-		ui_displayPrompt(
-		        "Start new",
-		        "operational certificate?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_POOL_COLD_KEY_PATH) {
-		ui_displayPathScreen("Pool cold key path", &ctx->poolColdKeyPathSpec, this_fn);
-	}
-	UI_STEP(UI_STEP_DISPLAY_POOL_ID) {
-		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-		bip44_pathToKeyHash(&ctx->poolColdKeyPathSpec, poolKeyHash, SIZEOF(poolKeyHash));
-
-		ui_displayBech32Screen(
-		        "Pool ID",
-		        "pool_vk",
-		        poolKeyHash, SIZEOF(poolKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_KES_PUBLIC_KEY) {
-		ui_displayBech32Screen(
-		        "KES public key",
-		        "kes_vk",
-		        ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey),
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_KES_PERIOD) {
-		char kesPeriodString[50] = {0};
-		explicit_bzero(kesPeriodString, SIZEOF(kesPeriodString));
-		str_formatUint64(ctx->kesPeriod, kesPeriodString, SIZEOF(kesPeriodString));
-		ui_displayPaginatedText(
-		        "KES period",
-		        kesPeriodString,
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_ISSUE_COUNTER) {
-		char issueCounterString[50] = {0};
-		explicit_bzero(issueCounterString, SIZEOF(issueCounterString));
-		str_formatUint64(ctx->issueCounter, issueCounterString, SIZEOF(issueCounterString));
-		ui_displayPaginatedText(
-		        "Issue counter",
-		        issueCounterString,
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm",
-		        "operational certificate?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(UI_STEP_RESPOND) {
-		ASSERT(ctx->responseReadyMagic == RESPONSE_READY_MAGIC);
-
-		io_send_buf(SUCCESS, (uint8_t*) &ctx->signature, SIZEOF(ctx->signature));
-		ui_idle();
-
-	}
-	UI_STEP_END(UI_STEP_INVALID);
-}
+// #include "common.h"
+
+// #include "signOpCert.h"
+// #include "keyDerivation.h"
+// #include "endian.h"
+// #include "state.h"
+// #include "uiHelpers.h"
+// #include "uiScreens.h"
+// #include "securityPolicy.h"
+// #include "messageSigning.h"
+// #include "textUtils.h"
+
+// static ins_sign_op_cert_context_t* ctx = &(instructionState.signOpCertContext);
+
+
+// static int16_t RESPONSE_READY_MAGIC = 31678;
+
+// // forward declaration
+// static void signOpCert_ui_runStep();
+// enum {
+// 	UI_STEP_WARNING = 100,
+// 	UI_STEP_CONFIRM_START,
+// 	UI_STEP_DISPLAY_POOL_COLD_KEY_PATH,
+// 	UI_STEP_DISPLAY_POOL_ID,
+// 	UI_STEP_DISPLAY_KES_PUBLIC_KEY,
+// 	UI_STEP_DISPLAY_KES_PERIOD,
+// 	UI_STEP_DISPLAY_ISSUE_COUNTER,
+// 	UI_STEP_CONFIRM,
+// 	UI_STEP_RESPOND,
+// 	UI_STEP_INVALID,
+// };
+
+// void signOpCert_handleAPDU(
+//         uint8_t p1,
+//         uint8_t p2,
+//         uint8_t *wireDataBuffer,
+//         size_t wireDataSize,
+//         bool isNewCall
+// )
+// {
+// 	// Initialize state
+// 	if (isNewCall) {
+// 		explicit_bzero(ctx, SIZEOF(*ctx));
+// 	}
+// 	ctx->responseReadyMagic = 0;
+
+// 	// Validate params
+// 	VALIDATE(p1 == P1_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
+// 	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
+
+// 	{
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		STATIC_ASSERT(SIZEOF(ctx->kesPublicKey) == KES_PUBLIC_KEY_LENGTH, "wrong KES public key size");
+// 		view_parseBuffer(ctx->kesPublicKey, &view, KES_PUBLIC_KEY_LENGTH);
+// 		TRACE("KES key:");
+// 		TRACE_BUFFER(ctx->kesPublicKey, KES_PUBLIC_KEY_LENGTH);
+
+// 		ctx->kesPeriod = parse_u8be(&view);
+// 		TRACE("KES period:");
+// 		TRACE_UINT64(ctx->kesPeriod);
+
+// 		ctx->issueCounter = parse_u8be(&view);
+// 		TRACE("Issue counter:");
+// 		TRACE_UINT64(ctx->issueCounter);
+
+// 		view_skipBytes(&view, bip44_parseFromWire(&ctx->poolColdKeyPathSpec, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	// Check security policy
+// 	security_policy_t policy = policyForSignOpCert(&ctx->poolColdKeyPathSpec);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		uint8_t opCertBodyBuffer[OP_CERT_BODY_LENGTH] = {0};
+// 		write_view_t opCertBodyBufferView = make_write_view(opCertBodyBuffer, opCertBodyBuffer + OP_CERT_BODY_LENGTH);
+
+// 		view_appendBuffer(&opCertBodyBufferView, (const uint8_t*) &ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey));
+// 		{
+// 			uint8_t chunk[8] = {0};
+// 			u8be_write(chunk, ctx->issueCounter);
+// 			#ifdef FUZZING
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
+// 			#else
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
+// 			#endif
+// 		}
+// 		{
+// 			uint8_t chunk[8] = {0};
+// 			u8be_write(chunk, ctx->kesPeriod);
+// 			#ifdef FUZZING
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
+// 			#else
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
+// 			#endif
+// 		}
+
+// 		ASSERT(view_processedSize(&opCertBodyBufferView) == OP_CERT_BODY_LENGTH);
+// 		TRACE_BUFFER(opCertBodyBuffer, SIZEOF(opCertBodyBuffer));
+
+// 		getOpCertSignature(
+// 		        &ctx->poolColdKeyPathSpec,
+// 		        opCertBodyBuffer,
+// 		        OP_CERT_BODY_LENGTH,
+// 		        ctx->signature,
+// 		        SIZEOF(ctx->signature)
+// 		);
+// 	}
+// 	ctx->responseReadyMagic = RESPONSE_READY_MAGIC;
+
+// 	switch (policy) {
+// #define  CASE(policy, step) case policy: {ctx->ui_step = step; break;}
+// 		CASE(POLICY_PROMPT_WARN_UNUSUAL,    UI_STEP_WARNING);
+// 		CASE(POLICY_PROMPT_BEFORE_RESPONSE, UI_STEP_CONFIRM_START);
+// 		CASE(POLICY_ALLOW_WITHOUT_PROMPT,   UI_STEP_RESPOND);
+// #undef   CASE
+// 	default:
+// 		THROW(ERR_NOT_IMPLEMENTED);
+// 	}
+// 	signOpCert_ui_runStep();
+// }
+
+// static void signOpCert_ui_runStep()
+// {
+// 	ui_callback_fn_t* this_fn = signOpCert_ui_runStep;
+
+// 	UI_STEP_BEGIN(ctx->ui_step, this_fn);
+
+// 	UI_STEP(UI_STEP_WARNING) {
+// 		ui_displayPaginatedText(
+// 		        "Unusual request",
+// 		        "Proceed with care",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_CONFIRM_START) {
+// 		ui_displayPrompt(
+// 		        "Start new",
+// 		        "operational certificate?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_POOL_COLD_KEY_PATH) {
+// 		ui_displayPathScreen("Pool cold key path", &ctx->poolColdKeyPathSpec, this_fn);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_POOL_ID) {
+// 		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 		bip44_pathToKeyHash(&ctx->poolColdKeyPathSpec, poolKeyHash, SIZEOF(poolKeyHash));
+
+// 		ui_displayBech32Screen(
+// 		        "Pool ID",
+// 		        "pool_vk",
+// 		        poolKeyHash, SIZEOF(poolKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_KES_PUBLIC_KEY) {
+// 		ui_displayBech32Screen(
+// 		        "KES public key",
+// 		        "kes_vk",
+// 		        ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_KES_PERIOD) {
+// 		char kesPeriodString[50] = {0};
+// 		explicit_bzero(kesPeriodString, SIZEOF(kesPeriodString));
+// 		str_formatUint64(ctx->kesPeriod, kesPeriodString, SIZEOF(kesPeriodString));
+// 		ui_displayPaginatedText(
+// 		        "KES period",
+// 		        kesPeriodString,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_ISSUE_COUNTER) {
+// 		char issueCounterString[50] = {0};
+// 		explicit_bzero(issueCounterString, SIZEOF(issueCounterString));
+// 		str_formatUint64(ctx->issueCounter, issueCounterString, SIZEOF(issueCounterString));
+// 		ui_displayPaginatedText(
+// 		        "Issue counter",
+// 		        issueCounterString,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm",
+// 		        "operational certificate?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_RESPOND) {
+// 		ASSERT(ctx->responseReadyMagic == RESPONSE_READY_MAGIC);
+
+// 		io_send_buf(SUCCESS, (uint8_t*) &ctx->signature, SIZEOF(ctx->signature));
+// 		ui_idle();
+
+// 	}
+// 	UI_STEP_END(UI_STEP_INVALID);
+// }
diff --git a/src/signOpCert.h b/src/signOpCert.h
index af84479..e7cf564 100644
--- a/src/signOpCert.h
+++ b/src/signOpCert.h
@@ -1,23 +1,23 @@
-#ifndef H_CARDANO_APP_SIGN_OP_CERT
-#define H_CARDANO_APP_SIGN_OP_CERT
+// #ifndef H_CARDANO_APP_SIGN_OP_CERT
+// #define H_CARDANO_APP_SIGN_OP_CERT
 
-#include "common.h"
-#include "handlers.h"
-#include "bip44.h"
-#include "keyDerivation.h"
+// #include "common.h"
+// #include "handlers.h"
+// #include "bip44.h"
+// #include "keyDerivation.h"
 
-handler_fn_t signOpCert_handleAPDU;
+// handler_fn_t signOpCert_handleAPDU;
 
-#define KES_PUBLIC_KEY_LENGTH 32
+// #define KES_PUBLIC_KEY_LENGTH 32
 
-typedef struct {
-	int16_t responseReadyMagic;
-	uint8_t kesPublicKey[KES_PUBLIC_KEY_LENGTH];
-	uint64_t kesPeriod;
-	uint64_t issueCounter;
-	bip44_path_t poolColdKeyPathSpec;
-	uint8_t signature[64];
-	int ui_step;
-} ins_sign_op_cert_context_t;
+// typedef struct {
+// 	int16_t responseReadyMagic;
+// 	uint8_t kesPublicKey[KES_PUBLIC_KEY_LENGTH];
+// 	uint64_t kesPeriod;
+// 	uint64_t issueCounter;
+// 	bip44_path_t poolColdKeyPathSpec;
+// 	uint8_t signature[64];
+// 	int ui_step;
+// } ins_sign_op_cert_context_t;
 
-#endif // H_CARDANO_APP_SIGN_OP_CERT
\ No newline at end of file
+// #endif // H_CARDANO_APP_SIGN_OP_CERT
\ No newline at end of file
diff --git a/src/signTx.c b/src/signTx.c
index ec23d83..beab09a 100644
--- a/src/signTx.c
+++ b/src/signTx.c
@@ -186,24 +186,27 @@ static inline void advanceStage()
 		if (ctx->includeValidityIntervalStart) {
 			ASSERT(BODY_CTX->validityIntervalStartReceived);
 		}
-		ctx->stage = SIGN_STAGE_BODY_MINT;
-		if (ctx->includeMint) {
-			txHashBuilder_enterMint(&BODY_CTX->txHashBuilder);
-			signTxMint_init();
-			// wait for mint APDU
+		ctx->stage = SIGN_STAGE_BODY_SCRIPT_DATA_HASH;	
+		if (ctx->includeScriptDataHash) {
 			break;
 		}
+		// if (ctx->includeMint) {
+		// 	txHashBuilder_enterMint(&BODY_CTX->txHashBuilder);
+		// 	signTxMint_init();
+		// 	// wait for mint APDU
+		// 	break;
+		// }
 
 	// intentional fallthrough
 
-	case SIGN_STAGE_BODY_MINT:
-		if (ctx->includeMint) {
-			ASSERT(BODY_CTX->mintReceived);
-		}
-		ctx->stage = SIGN_STAGE_BODY_SCRIPT_DATA_HASH;
-		if (ctx->includeScriptDataHash) {
-			break;
-		}
+	// case SIGN_STAGE_BODY_MINT:
+	// 	if (ctx->includeMint) {
+	// 		ASSERT(BODY_CTX->mintReceived);
+	// 	}
+	// 	ctx->stage = SIGN_STAGE_BODY_SCRIPT_DATA_HASH;
+	// 	if (ctx->includeScriptDataHash) {
+	// 		break;
+	// 	}
 
 	// intentional fallthrough
 
@@ -317,37 +320,37 @@ static inline void checkForFinishedSubmachines()
 		}
 		break;
 
-	case SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE:
-		if (signTxPoolRegistration_isFinished()) {
-			TRACE();
-			ASSERT(BODY_CTX->currentCertificate < ctx->numCertificates);
-			ctx->stage = SIGN_STAGE_BODY_CERTIFICATES;
-
-			advanceCertificatesStateIfAppropriate();
-		}
-		break;
-
-	case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
-		if (signTxCatalystRegistration_isFinished()) {
-			TRACE();
-			ctx->stage = SIGN_STAGE_AUX_DATA;
-			AUX_DATA_CTX->auxDataReceived = true;
-
-			STATIC_ASSERT(SIZEOF(ctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
-			STATIC_ASSERT(SIZEOF(AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
-			memmove(ctx->auxDataHash, AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash, AUX_DATA_HASH_LENGTH);
-
-			advanceStage();
-		}
-		break;
-
-	case SIGN_STAGE_BODY_MINT_SUBMACHINE:
-		if (signTxMint_isFinished()) {
-			TRACE();
-			ctx->stage = SIGN_STAGE_BODY_MINT;
-			BODY_CTX->mintReceived = true;
-			advanceStage();
-		}
+	// case SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE:
+	// 	if (signTxPoolRegistration_isFinished()) {
+	// 		TRACE();
+	// 		ASSERT(BODY_CTX->currentCertificate < ctx->numCertificates);
+	// 		ctx->stage = SIGN_STAGE_BODY_CERTIFICATES;
+
+	// 		advanceCertificatesStateIfAppropriate();
+	// 	}
+	// 	break;
+
+	// case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
+	// 	if (signTxCatalystRegistration_isFinished()) {
+	// 		TRACE();
+	// 		ctx->stage = SIGN_STAGE_AUX_DATA;
+	// 		AUX_DATA_CTX->auxDataReceived = true;
+
+	// 		STATIC_ASSERT(SIZEOF(ctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
+	// 		STATIC_ASSERT(SIZEOF(AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
+	// 		memmove(ctx->auxDataHash, AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash, AUX_DATA_HASH_LENGTH);
+
+	// 		advanceStage();
+	// 	}
+	// 	break;
+
+	// case SIGN_STAGE_BODY_MINT_SUBMACHINE:
+	// 	if (signTxMint_isFinished()) {
+	// 		TRACE();
+	// 		ctx->stage = SIGN_STAGE_BODY_MINT;
+	// 		BODY_CTX->mintReceived = true;
+	// 		advanceStage();
+	// 	}
 	default:
 		break; // nothing to do otherwise
 	}
@@ -377,11 +380,11 @@ static const char *_newTxLine1(sign_tx_signingmode_t txSigningMode)
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 		return "New ordinary";
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		return "New pool owner";
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	return "New pool owner";
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		return "New pool operator";
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// 	return "New pool operator";
 
 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		return "New multisig";
@@ -523,8 +526,8 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 		ctx->includeValidityIntervalStart = signTx_parseIncluded(wireHeader->includeValidityIntervalStart);
 		TRACE("Include validity interval start %d", ctx->includeValidityIntervalStart);
 
-		ctx->includeMint = signTx_parseIncluded(wireHeader->includeMint);
-		TRACE("Include mint %d", ctx->includeMint);
+		// ctx->includeMint = signTx_parseIncluded(wireHeader->includeMint);
+		// TRACE("Include mint %d", ctx->includeMint);
 
 		ctx->includeScriptDataHash = signTx_parseIncluded(wireHeader->includeScriptDataHash);
 		TRACE("Include script data hash %d", ctx->includeScriptDataHash);
@@ -536,9 +539,9 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 		TRACE("Signing mode %d", (int) ctx->commonTxData.txSigningMode);
 		switch (ctx->commonTxData.txSigningMode) {
 		case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+		// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 			// these signing modes are allowed
 			break;
@@ -582,7 +585,7 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 
 	{
 		// default values for variables whose value is not given in the APDU
-		ctx->poolOwnerByPath = false;
+		// ctx->poolOwnerByPath = false;
 		ctx->shouldDisplayTxid = false;
 	}
 
@@ -591,11 +594,11 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 	                                   ctx->commonTxData.networkId,
 	                                   ctx->commonTxData.protocolMagic,
 	                                   ctx->numOutputs,
-	                                   ctx->numCertificates,
+	                                //    ctx->numCertificates,
 	                                   ctx->numWithdrawals,
-	                                   ctx->includeMint,
+	                                //    ctx->includeMint,
 	                                   ctx->numCollaterals,
-	                                   ctx->numRequiredSigners,
+	                                //    ctx->numRequiredSigners,
 	                                   ctx->includeScriptDataHash,
 	                                   ctx->includeNetworkId
 	                           );
@@ -649,34 +652,34 @@ static void signTx_handleAuxDataArbitraryHash_ui_runStep()
 }
 
 
-enum {
-	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY = 850,
-	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND,
-	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID,
-};
-static void signTx_handleAuxDataCatalystRegistration_ui_runStep()
-{
-	TRACE("UI step %d", ctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTx_handleAuxDataCatalystRegistration_ui_runStep;
-
-	UI_STEP_BEGIN(ctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY) {
-		ui_displayPrompt(
-		        "Register Catalyst",
-		        "voting key?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		signTxCatalystRegistration_init();
-		ctx->stage = SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE;
-	}
-	UI_STEP_END(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID);
-}
+// enum {
+// 	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY = 850,
+// 	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND,
+// 	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID,
+// };
+// static void signTx_handleAuxDataCatalystRegistration_ui_runStep()
+// {
+// 	TRACE("UI step %d", ctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTx_handleAuxDataCatalystRegistration_ui_runStep;
+
+// 	UI_STEP_BEGIN(ctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY) {
+// 		ui_displayPrompt(
+// 		        "Register Catalyst",
+// 		        "voting key?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		signTxCatalystRegistration_init();
+// 		ctx->stage = SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE;
+// 	}
+// 	UI_STEP_END(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID);
+// }
 
 __noinline_due_to_stack__
 static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
@@ -687,17 +690,17 @@ static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 		ASSERT(ctx->includeAuxData == true);
 
 		// delegate to state sub-machine for stake pool registration certificate data
-		if (signTxCatalystRegistration_isValidInstruction(p2)) {
-			TRACE();
-			CHECK_STAGE(SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE);
+		// if (signTxCatalystRegistration_isValidInstruction(p2)) {
+		// 	TRACE();
+		// 	CHECK_STAGE(SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE);
 
-			TRACE_STACK_USAGE();
+		// 	TRACE_STACK_USAGE();
 
-			signTxCatalystRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
-			return;
-		} else {
+		// 	signTxCatalystRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
+		// 	return;
+		// } else {
 			CHECK_STAGE(SIGN_STAGE_AUX_DATA);
-		}
+		// }
 	}
 	{
 		explicit_bzero(ctx->auxDataHash, SIZEOF(ctx->auxDataHash));
@@ -716,8 +719,8 @@ static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 			break;
 		}
 
-		case AUX_DATA_TYPE_CATALYST_REGISTRATION:
-			break;
+		// case AUX_DATA_TYPE_CATALYST_REGISTRATION:
+		// 	break;
 
 		default:
 			THROW(ERR_INVALID_DATA);
@@ -745,19 +748,19 @@ static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 		signTx_handleAuxDataArbitraryHash_ui_runStep();
 		break;
 	}
-	case AUX_DATA_TYPE_CATALYST_REGISTRATION:
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-
-		signTx_handleAuxDataCatalystRegistration_ui_runStep();
-		break;
+// 	case AUX_DATA_TYPE_CATALYST_REGISTRATION:
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+
+// 		signTx_handleAuxDataCatalystRegistration_ui_runStep();
+// 		break;
 	default:
 		ASSERT(false);
 	}
@@ -1159,53 +1162,53 @@ static void signTx_handleCertificate_ui_runStep()
 	UI_STEP_END(HANDLE_CERTIFICATE_STEP_INVALID);
 }
 
-enum {
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION = 650,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID,
-};
-
-static void signTx_handleCertificatePoolRetirement_ui_runStep()
-{
-	TRACE("UI step %d", ctx->ui_step);
-	ASSERT(BODY_CTX->stageData.certificate.type == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
-
-	ui_callback_fn_t* this_fn = signTx_handleCertificatePoolRetirement_ui_runStep;
-
-	UI_STEP_BEGIN(ctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION) {
-		ui_displayBech32Screen(
-		        "Retire stake pool",
-		        "pool",
-		        BODY_CTX->stageData.certificate.poolKeyHash, SIZEOF(BODY_CTX->stageData.certificate.poolKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH) {
-		ui_displayUint64Screen(
-		        "at the start of epoch",
-		        BODY_CTX->stageData.certificate.epoch,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm",
-		        "pool retirement",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		advanceCertificatesStateIfAppropriate();
-	}
-	UI_STEP_END(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID);
-}
+// enum {
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION = 650,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID,
+// };
+
+// static void signTx_handleCertificatePoolRetirement_ui_runStep()
+// {
+// 	TRACE("UI step %d", ctx->ui_step);
+// 	ASSERT(BODY_CTX->stageData.certificate.type == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
+
+// 	ui_callback_fn_t* this_fn = signTx_handleCertificatePoolRetirement_ui_runStep;
+
+// 	UI_STEP_BEGIN(ctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION) {
+// 		ui_displayBech32Screen(
+// 		        "Retire stake pool",
+// 		        "pool",
+// 		        BODY_CTX->stageData.certificate.poolKeyHash, SIZEOF(BODY_CTX->stageData.certificate.poolKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH) {
+// 		ui_displayUint64Screen(
+// 		        "at the start of epoch",
+// 		        BODY_CTX->stageData.certificate.epoch,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm",
+// 		        "pool retirement",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		advanceCertificatesStateIfAppropriate();
+// 	}
+// 	UI_STEP_END(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID);
+// }
 
 static void _parsePathSpec(read_view_t* view, bip44_path_t* pathSpec)
 {
@@ -1262,15 +1265,15 @@ static void _parseCertificateData(uint8_t* wireDataBuffer, size_t wireDataSize,
 		view_parseBuffer(certificateData->poolKeyHash, &view, POOL_KEY_HASH_LENGTH);
 		break;
 
-	case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION:
-		// nothing more to parse, certificate data will be provided
-		// in additional APDUs processed by a submachine
-		return;
+	// case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION:
+	// 	// nothing more to parse, certificate data will be provided
+	// 	// in additional APDUs processed by a submachine
+	// 	return;
 
-	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT:
-		_parsePathSpec(&view, &certificateData->poolIdPath);
-		certificateData->epoch = parse_u8be(&view);
-		break;
+	// case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT:
+	// 	_parsePathSpec(&view, &certificateData->poolIdPath);
+	// 	certificateData->epoch = parse_u8be(&view);
+	// 	break;
 
 	default:
 		THROW(ERR_INVALID_DATA);
@@ -1353,15 +1356,15 @@ static void _addCertificateDataToTx(
 		break;
 	}
 
-	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
-		_fillHashFromPath(&BODY_CTX->stageData.certificate.poolIdPath, certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash));
-		txHashBuilder_addCertificate_poolRetirement(
-		        txHashBuilder,
-		        certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash),
-		        certificateData->epoch
-		);
-		break;
-	}
+	// case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
+	// 	_fillHashFromPath(&BODY_CTX->stageData.certificate.poolIdPath, certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash));
+	// 	txHashBuilder_addCertificate_poolRetirement(
+	// 	        txHashBuilder,
+	// 	        certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash),
+	// 	        certificateData->epoch
+	// 	);
+	// 	break;
+	// }
 
 	default:
 		ASSERT(false);
@@ -1376,15 +1379,15 @@ static void signTx_handleCertificateAPDU(uint8_t p2, uint8_t* wireDataBuffer, si
 	ASSERT(BODY_CTX->currentCertificate < ctx->numCertificates);
 
 	// delegate to state sub-machine for stake pool registration certificate data
-	if (signTxPoolRegistration_isValidInstruction(p2)) {
-		TRACE();
-		VALIDATE(ctx->stage == SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE, ERR_INVALID_DATA);
+	// if (signTxPoolRegistration_isValidInstruction(p2)) {
+	// 	TRACE();
+	// 	VALIDATE(ctx->stage == SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE, ERR_INVALID_DATA);
 
-		TRACE_STACK_USAGE();
+	// 	TRACE_STACK_USAGE();
 
-		signTxPoolRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
-		return;
-	}
+	// 	signTxPoolRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
+	// 	return;
+	// }
 
 	CHECK_STAGE(SIGN_STAGE_BODY_CERTIFICATES);
 	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
@@ -1434,38 +1437,38 @@ static void signTx_handleCertificateAPDU(uint8_t p2, uint8_t* wireDataBuffer, si
 		return;
 	}
 
-	case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION: {
-		// pool registration certificates have a separate sub-machine for handling APDU and UI
-		// nothing more to be done with them here, we just init the sub-machine
-		ctx->stage = SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE;
-		signTxPoolRegistration_init();
-
-		respondSuccessEmptyMsg();
-		return;
-	}
-
-	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
-		security_policy_t policy = policyForSignTxCertificateStakePoolRetirement(
-		                                   ctx->commonTxData.txSigningMode,
-		                                   &BODY_CTX->stageData.certificate.poolIdPath,
-		                                   BODY_CTX->stageData.certificate.epoch
-		                           );
-		TRACE("Policy: %d", (int) policy);
-		ENSURE_NOT_DENIED(policy);
-
-		_addCertificateDataToTx(&BODY_CTX->stageData.certificate, &BODY_CTX->txHashBuilder);
-
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-		signTx_handleCertificatePoolRetirement_ui_runStep();
-		return;
-	}
+// 	case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION: {
+// 		// pool registration certificates have a separate sub-machine for handling APDU and UI
+// 		// nothing more to be done with them here, we just init the sub-machine
+// 		ctx->stage = SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE;
+// 		signTxPoolRegistration_init();
+
+// 		respondSuccessEmptyMsg();
+// 		return;
+// 	}
+
+// 	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
+// 		security_policy_t policy = policyForSignTxCertificateStakePoolRetirement(
+// 		                                   ctx->commonTxData.txSigningMode,
+// 		                                   &BODY_CTX->stageData.certificate.poolIdPath,
+// 		                                   BODY_CTX->stageData.certificate.epoch
+// 		                           );
+// 		TRACE("Policy: %d", (int) policy);
+// 		ENSURE_NOT_DENIED(policy);
+
+// 		_addCertificateDataToTx(&BODY_CTX->stageData.certificate, &BODY_CTX->txHashBuilder);
+
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 		signTx_handleCertificatePoolRetirement_ui_runStep();
+// 		return;
+// 	}
 
 	default:
 		ASSERT(false);
@@ -1740,24 +1743,24 @@ static void signTx_handleValidityIntervalStartAPDU(uint8_t p2, uint8_t* wireData
 
 // ============================== MINT ==============================
 
-static void signTx_handleMintAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		TRACE("p2 = %d", p2);
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-	}
+// static void signTx_handleMintAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		TRACE("p2 = %d", p2);
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 	}
 
-	if (ctx->stage == SIGN_STAGE_BODY_MINT) {
-		ctx->stage = SIGN_STAGE_BODY_MINT_SUBMACHINE;
-	}
+// 	if (ctx->stage == SIGN_STAGE_BODY_MINT) {
+// 		ctx->stage = SIGN_STAGE_BODY_MINT_SUBMACHINE;
+// 	}
 
-	CHECK_STAGE(SIGN_STAGE_BODY_MINT_SUBMACHINE);
+// 	CHECK_STAGE(SIGN_STAGE_BODY_MINT_SUBMACHINE);
 
-	// all mint handling is delegated to a state sub-machine
-	VALIDATE(signTxMint_isValidInstruction(p2), ERR_INVALID_DATA);
-	signTxMint_handleAPDU(p2, wireDataBuffer, wireDataSize);
-}
+// 	// all mint handling is delegated to a state sub-machine
+// 	VALIDATE(signTxMint_isValidInstruction(p2), ERR_INVALID_DATA);
+// 	signTxMint_handleAPDU(p2, wireDataBuffer, wireDataSize);
+// }
 
 // ========================= SCRIPT DATA HASH ==========================
 
@@ -2084,7 +2087,7 @@ static bool _shouldDisplayTxId(sign_tx_signingmode_t signingMode)
 	switch(signingMode) {
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		if (ctx->shouldDisplayTxid && app_mode_expert())
 			return true;
 		return false;
@@ -2233,8 +2236,8 @@ static void signTx_handleWitnessAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 	security_policy_t policy = policyForSignTxWitness(
 	                                   ctx->commonTxData.txSigningMode,
 	                                   &WITNESS_CTX->stageData.witness.path,
-	                                   ctx->includeMint,
-	                                   ctx->poolOwnerByPath ? &ctx->poolOwnerPath : NULL
+	                                   ctx->includeMint
+	                                //    ctx->poolOwnerByPath ? &ctx->poolOwnerPath : NULL
 	                           );
 	TRACE("Policy: %d", (int) policy);
 	ENSURE_NOT_DENIED(policy);
@@ -2293,7 +2296,7 @@ static subhandler_fn_t* lookup_subhandler(uint8_t p1)
 		CASE(0x06, signTx_handleCertificateAPDU);
 		CASE(0x07, signTx_handleWithdrawalAPDU);
 		CASE(0x09, signTx_handleValidityIntervalStartAPDU);
-		CASE(0x0b, signTx_handleMintAPDU);
+		// CASE(0x0b, signTx_handleMintAPDU);
 		CASE(0x0c, signTx_handleScriptDataHashAPDU);
 		CASE(0x0d, signTx_handleCollateralAPDU);
 		CASE(0x0e, signTx_handleRequiredSignerAPDU);
@@ -2356,7 +2359,7 @@ ins_sign_tx_aux_data_context_t* accessAuxDataContext()
 	switch (ctx->stage) {
 
 	case SIGN_STAGE_AUX_DATA:
-	case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
+	// case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
 		return &(ctx->txPartCtx.aux_data_ctx);
 
 	default:
diff --git a/src/signTx.h b/src/signTx.h
index 255a070..43c10e0 100644
--- a/src/signTx.h
+++ b/src/signTx.h
@@ -7,17 +7,17 @@
 #include "txHashBuilder.h"
 #include "bip44.h"
 #include "addressUtilsShelley.h"
-#include "signTxMint.h"
+// #include "signTxMint.h"
 #include "signTxOutput.h"
-#include "signTxPoolRegistration.h"
-#include "signTxCatalystRegistration.h"
+// #include "signTxPoolRegistration.h"
+// #include "signTxCatalystRegistration.h"
 #include "signTxAuxData.h"
 
 // the signing mode significantly affects restrictions on tx being signed
 typedef enum {
 	SIGN_TX_SIGNINGMODE_ORDINARY_TX = 3, // enum value 3 is needed for backwards compatibility
-	SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER = 4,
-	SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR = 5,
+	// SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER = 4,
+	// SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR = 5,
 	SIGN_TX_SIGNINGMODE_MULTISIG_TX = 6,
 	SIGN_TX_SIGNINGMODE_PLUTUS_TX = 7,
 } sign_tx_signingmode_t;
@@ -26,7 +26,7 @@ typedef enum {
 	SIGN_STAGE_NONE = 0,
 	SIGN_STAGE_INIT = 23,
 	SIGN_STAGE_AUX_DATA = 24,
-	SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE = 25,
+	// SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE = 25,
 	SIGN_STAGE_BODY_INPUTS = 26,
 	SIGN_STAGE_BODY_OUTPUTS = 27,
 	SIGN_STAGE_BODY_OUTPUTS_SUBMACHINE = 28,
@@ -85,7 +85,7 @@ typedef struct {
 
 	union {
 		stake_credential_t stakeCredential;
-		bip44_path_t poolIdPath;
+		// bip44_path_t poolIdPath;
 	};
 	uint64_t epoch;
 	uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH];
@@ -111,11 +111,11 @@ typedef struct {
 typedef struct {
 	bool auxDataReceived;
 	aux_data_type_t auxDataType;
-	aux_data_hash_builder_t auxDataHashBuilder;
+	// aux_data_hash_builder_t auxDataHashBuilder;
 
-	struct {
-		catalyst_registration_context_t catalyst_registration_subctx;
-	} stageContext;
+	// struct {
+	// 	catalyst_registration_context_t catalyst_registration_subctx;
+	// } stageContext;
 } ins_sign_tx_aux_data_context_t;
 
 typedef enum {
@@ -162,9 +162,9 @@ typedef struct {
 	} stageData; // TODO rename to reflect single-APDU scope
 
 	union {
-		pool_registration_context_t pool_registration_subctx;
+		// pool_registration_context_t pool_registration_subctx;
 		output_context_t output_subctx;
-		mint_context_t mint_subctx;
+		// mint_context_t mint_subctx;
 	} stageContext;
 } ins_sign_tx_body_context_t;
 
@@ -203,8 +203,8 @@ typedef struct {
 		ins_sign_tx_witness_context_t witnesses_ctx;
 	} txPartCtx;
 
-	bool poolOwnerByPath;
-	bip44_path_t poolOwnerPath;
+	// bool poolOwnerByPath;
+	// bip44_path_t poolOwnerPath;
 
 	bool shouldDisplayTxid; // long bytestrings (e.g. datums in outputs) are better verified indirectly
 
diff --git a/src/signTxAuxData.h b/src/signTxAuxData.h
index 4317654..132fd0e 100644
--- a/src/signTxAuxData.h
+++ b/src/signTxAuxData.h
@@ -3,7 +3,7 @@
 
 typedef enum {
 	AUX_DATA_TYPE_ARBITRARY_HASH = 0,
-	AUX_DATA_TYPE_CATALYST_REGISTRATION = 1,
+	// AUX_DATA_TYPE_CATALYST_REGISTRATION = 1,
 } aux_data_type_t;
 
 #endif // H_CARDANO_APP_SIGN_TX_AUX_DATA
diff --git a/src/signTxCatalystRegistration.c b/src/signTxCatalystRegistration.c
index fdffe53..a3b87a5 100644
--- a/src/signTxCatalystRegistration.c
+++ b/src/signTxCatalystRegistration.c
@@ -1,635 +1,635 @@
-#include "app_mode.h"
-#include "signTxCatalystRegistration.h"
-#include "state.h"
-#include "uiHelpers.h"
-#include "signTxUtils.h"
-#include "uiScreens.h"
-#include "auxDataHashBuilder.h"
-#include "txHashBuilder.h"
-#include "textUtils.h"
-#include "bufView.h"
-#include "securityPolicy.h"
-#include "messageSigning.h"
-
-static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
-
-static inline catalyst_registration_context_t* accessSubContext()
-{
-	return &AUX_DATA_CTX->stageContext.catalyst_registration_subctx;
-}
-
-bool signTxCatalystRegistration_isFinished()
-{
-	const catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("Catalyst registration submachine state: %d", subctx->state);
-	// we are also asserting that the state is valid
-	switch (subctx->state) {
-	case STATE_CATALYST_REGISTRATION_FINISHED:
-		return true;
-
-	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
-	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
-	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
-	case STATE_CATALYST_REGISTRATION_NONCE:
-	case STATE_CATALYST_REGISTRATION_CONFIRM:
-		return false;
-
-	default:
-		ASSERT(false);
-	}
-}
-
-void signTxCatalystRegistration_init()
-{
-	explicit_bzero(&AUX_DATA_CTX->stageContext, SIZEOF(AUX_DATA_CTX->stageContext));
-	auxDataHashBuilder_init(&AUX_DATA_CTX->auxDataHashBuilder);
-
-	accessSubContext()->state = STATE_CATALYST_REGISTRATION_VOTING_KEY;
-}
-
-static inline void CHECK_STATE(sign_tx_catalyst_registration_state_t expected)
-{
-	TRACE("Catalyst voting registration submachine state: current %d, expected %d", accessSubContext()->state, expected);
-	VALIDATE(accessSubContext()->state == expected, ERR_INVALID_STATE);
-}
-
-static inline void advanceState()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("Advancing Catalyst registration state from: %d", subctx->state);
-
-	switch (subctx->state) {
-
-	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
-		subctx->state = STATE_CATALYST_REGISTRATION_STAKING_KEY;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
-		subctx->state = STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
-		subctx->state = STATE_CATALYST_REGISTRATION_NONCE;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_NONCE:
-		subctx->state = STATE_CATALYST_REGISTRATION_CONFIRM;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_CONFIRM:
-		subctx->state = STATE_CATALYST_REGISTRATION_FINISHED;
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	TRACE("Advancing Catalyst registration state to: %d", subctx->state);
-}
-
-// ============================== VOTING KEY ==============================
-
-enum {
-	HANDLE_VOTING_KEY_STEP_DISPLAY = 8200,
-	HANDLE_VOTING_KEY_STEP_RESPOND,
-	HANDLE_VOTING_KEY_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleVotingKey_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_VOTING_KEY_STEP_DISPLAY) {
-		STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
-
-		// Jormungandr public key, hence the "ed25519_pk" prefix
-		// https://github.com/input-output-hk/jormungandr/blob/a057af27493d823be02480bb20258c25ff979e2a/jormungandr-lib/src/crypto/key.rs#L126
-		ui_displayBech32Screen(
-		        "Voting public key",
-		        "ed25519_pk",
-		        subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_VOTING_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_VOTING_KEY_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleVotingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_KEY);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-	{
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		{
-			VALIDATE(wireDataSize == SIZEOF(subctx->stateData.votingPubKey), ERR_INVALID_DATA);
-			read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-			STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
-			view_parseBuffer(subctx->stateData.votingPubKey, &view, CATALYST_VOTING_PUBLIC_KEY_LENGTH);
-
-			VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-		}
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationVotingKey();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
-		auxDataHashBuilder_catalystRegistration_enter(auxDataHashBuilder);
-		auxDataHashBuilder_catalystRegistration_enterPayload(auxDataHashBuilder);
-		auxDataHashBuilder_catalystRegistration_addVotingKey(
-		        auxDataHashBuilder, subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH
-		);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_KEY_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleVotingKey_ui_runStep();
-}
-
-// ============================== STAKING KEY ==============================
-
-enum {
-	HANDLE_STAKING_KEY_STEP_WARNING = 8300,
-	HANDLE_STAKING_KEY_STEP_DISPLAY,
-	HANDLE_STAKING_KEY_STEP_RESPOND,
-	HANDLE_STAKING_KEY_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleStakingKey_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleStakingKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_STAKING_KEY_STEP_WARNING) {
-		ui_displayPaginatedText(
-		        "Unusual request",
-		        "Proceed with care",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_STAKING_KEY_STEP_DISPLAY) {
-		ui_displayStakingKeyScreen(
-		        &subctx->stakingKeyPath,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_STAKING_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_STAKING_KEY_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleStakingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_STAKING_KEY);
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stakingKeyPath, SIZEOF(subctx->stakingKeyPath));
-	}
-	{
-		// parse input
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		view_skipBytes(
-		        &view,
-		        bip44_parseFromWire(&subctx->stakingKeyPath, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view))
-		);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationStakingKey(
-	                                   &subctx->stakingKeyPath
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		extendedPublicKey_t extStakingPubKey;
-		deriveExtendedPublicKey(&subctx->stakingKeyPath, &extStakingPubKey);
-		auxDataHashBuilder_catalystRegistration_addStakingKey(
-		        &AUX_DATA_CTX->auxDataHashBuilder, extStakingPubKey.pubKey, SIZEOF(extStakingPubKey.pubKey)
-		);
-	}
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_STAKING_KEY_STEP_WARNING);
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_STAKING_KEY_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_STAKING_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleStakingKey_ui_runStep();
-}
-
-// ============================== VOTING REWARDS ADDRESS ==============================
-
-enum {
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING = 8500,
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS,
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND,
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID
-};
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING) {
-		ui_displayPaginatedText(
-		        "Unusual request",
-		        "Proceed with care",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS) {
-		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
-		size_t addressSize = deriveAddress(
-		                             &subctx->stateData.votingRewardsAddressParams,
-		                             addressBuffer,
-		                             SIZEOF(addressBuffer)
-		                     );
-		ASSERT(addressSize > 0);
-		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
-
-		ui_displayAddressScreen(
-		        "Rewards go to",
-		        addressBuffer,
-		        addressSize,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleVotingRewardsAddressAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// safety checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(
-		        &subctx->stateData.votingRewardsAddressParams,
-		        SIZEOF(subctx->stateData.votingRewardsAddressParams)
-		);
-	}
-	{
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		view_parseAddressParams(&view, &subctx->stateData.votingRewardsAddressParams);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationVotingRewardsAddressParams(
-	                                   &subctx->stateData.votingRewardsAddressParams,
-	                                   commonTxData->networkId
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		ASSERT(isShelleyAddressType(subctx->stateData.votingRewardsAddressParams.type));
-		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
-		size_t addressSize = deriveAddress(
-		                             &subctx->stateData.votingRewardsAddressParams,
-		                             addressBuffer,
-		                             SIZEOF(addressBuffer)
-		                     );
-		ASSERT(addressSize > 0);
-		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
-
-		auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
-		        &AUX_DATA_CTX->auxDataHashBuilder, addressBuffer, addressSize
-		);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING);
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-
-		signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep();
-	}
-}
-
-// ============================== NONCE ==============================
-
-enum {
-	HANDLE_NONCE_STEP_DISPLAY = 8600,
-	HANDLE_NONCE_STEP_RESPOND,
-	HANDLE_NONCE_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleNonce_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleNonce_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_NONCE_STEP_DISPLAY) {
-		ui_displayUint64Screen(
-		        "Nonce",
-		        subctx->stateData.nonce,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_NONCE_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_NONCE_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleNonceAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// sanity checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_NONCE);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		VALIDATE(wireDataSize == 8, ERR_INVALID_DATA);
-		subctx->stateData.nonce = u8be_read(wireDataBuffer);
-		TRACE(
-		        "Catalyst registration nonce: %d",
-		        subctx->stateData.nonce
-		);
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationNonce();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		auxDataHashBuilder_catalystRegistration_addNonce(&AUX_DATA_CTX->auxDataHashBuilder, subctx->stateData.nonce);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NONCE_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NONCE_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleNonce_ui_runStep();
-}
-
-// ============================== CONFIRM ==============================
-
-enum {
-	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
-	HANDLE_CONFIRM_STEP_DISPLAY_HASH,
-	HANDLE_CONFIRM_STEP_RESPOND,
-	HANDLE_CONFIRM_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleConfirm_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleConfirm_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
-		// confirming this means the signature being sent out of the device
-		// so we want to show it in non-expert mode too
-		ui_displayPrompt(
-		        "Confirm voting key",
-		        "registration?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_DISPLAY_HASH) {
-		if (!app_mode_expert()) {
-			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_RESPOND);
-		}
-		ui_displayHexBufferScreen(
-		        "Auxiliary data hash",
-		        subctx->auxDataHash,
-		        SIZEOF(subctx->auxDataHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
-		struct {
-			uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
-			uint8_t signature[ED25519_SIGNATURE_LENGTH];
-		} wireResponse = {0};
-
-		STATIC_ASSERT(SIZEOF(subctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong aux data hash length");
-		memmove(wireResponse.auxDataHash, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
-
-		STATIC_ASSERT(SIZEOF(subctx->stateData.registrationSignature) == ED25519_SIGNATURE_LENGTH, "Wrong Catalyst registration signature length");
-		memmove(wireResponse.signature, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
-
-		io_send_buf(SUCCESS, (uint8_t*) &wireResponse, SIZEOF(wireResponse));
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
-{
-	{
-		//sanity checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_CONFIRM);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-
-	{
-		// no data to receive
-		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationConfirm();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
-		{
-			uint8_t votingPayloadHashBuffer[CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH] = {0};
-			auxDataHashBuilder_catalystRegistration_finalizePayload(auxDataHashBuilder, votingPayloadHashBuffer, AUX_DATA_HASH_LENGTH);
-			getCatalystVotingRegistrationSignature(
-			        &subctx->stakingKeyPath,
-			        votingPayloadHashBuffer, CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH,
-			        subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH
-			);
-		}
-		auxDataHashBuilder_catalystRegistration_addSignature(auxDataHashBuilder, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
-		auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(auxDataHashBuilder);
-
-		auxDataHashBuilder_finalize(auxDataHashBuilder, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleConfirm_ui_runStep();
-}
-
-
-// ============================== main APDU handler ==============================
-
-enum {
-	APDU_INSTRUCTION_VOTING_KEY = 0x30,
-	APDU_INSTRUCTION_STAKING_KEY = 0x31,
-	APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS = 0x32,
-	APDU_INSTRUCTION_NONCE = 0x33,
-	APDU_INSTRUCTION_CONFIRM = 0x34
-};
-
-bool signTxCatalystRegistration_isValidInstruction(uint8_t p2)
-{
-	switch (p2) {
-	case APDU_INSTRUCTION_VOTING_KEY:
-	case APDU_INSTRUCTION_STAKING_KEY:
-	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
-	case APDU_INSTRUCTION_NONCE:
-	case APDU_INSTRUCTION_CONFIRM:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-
-	switch (p2) {
-	case APDU_INSTRUCTION_VOTING_KEY:
-		signTxCatalystRegistration_handleVotingKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_STAKING_KEY:
-		signTxCatalystRegistration_handleStakingKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
-		signTxCatalystRegistration_handleVotingRewardsAddressAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_NONCE:
-		signTxCatalystRegistration_handleNonceAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_CONFIRM:
-		signTxCatalystRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	default:
-		// this is not supposed to be called with invalid p2
-		ASSERT(false);
-	}
-}
+// #include "app_mode.h"
+// #include "signTxCatalystRegistration.h"
+// #include "state.h"
+// #include "uiHelpers.h"
+// #include "signTxUtils.h"
+// #include "uiScreens.h"
+// #include "auxDataHashBuilder.h"
+// #include "txHashBuilder.h"
+// #include "textUtils.h"
+// #include "bufView.h"
+// #include "securityPolicy.h"
+// #include "messageSigning.h"
+
+// static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
+
+// static inline catalyst_registration_context_t* accessSubContext()
+// {
+// 	return &AUX_DATA_CTX->stageContext.catalyst_registration_subctx;
+// }
+
+// bool signTxCatalystRegistration_isFinished()
+// {
+// 	const catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("Catalyst registration submachine state: %d", subctx->state);
+// 	// we are also asserting that the state is valid
+// 	switch (subctx->state) {
+// 	case STATE_CATALYST_REGISTRATION_FINISHED:
+// 		return true;
+
+// 	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
+// 	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
+// 	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
+// 	case STATE_CATALYST_REGISTRATION_NONCE:
+// 	case STATE_CATALYST_REGISTRATION_CONFIRM:
+// 		return false;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// void signTxCatalystRegistration_init()
+// {
+// 	explicit_bzero(&AUX_DATA_CTX->stageContext, SIZEOF(AUX_DATA_CTX->stageContext));
+// 	auxDataHashBuilder_init(&AUX_DATA_CTX->auxDataHashBuilder);
+
+// 	accessSubContext()->state = STATE_CATALYST_REGISTRATION_VOTING_KEY;
+// }
+
+// static inline void CHECK_STATE(sign_tx_catalyst_registration_state_t expected)
+// {
+// 	TRACE("Catalyst voting registration submachine state: current %d, expected %d", accessSubContext()->state, expected);
+// 	VALIDATE(accessSubContext()->state == expected, ERR_INVALID_STATE);
+// }
+
+// static inline void advanceState()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("Advancing Catalyst registration state from: %d", subctx->state);
+
+// 	switch (subctx->state) {
+
+// 	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_STAKING_KEY;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_NONCE;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_NONCE:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_CONFIRM;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_CONFIRM:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_FINISHED;
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	TRACE("Advancing Catalyst registration state to: %d", subctx->state);
+// }
+
+// // ============================== VOTING KEY ==============================
+
+// enum {
+// 	HANDLE_VOTING_KEY_STEP_DISPLAY = 8200,
+// 	HANDLE_VOTING_KEY_STEP_RESPOND,
+// 	HANDLE_VOTING_KEY_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleVotingKey_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_VOTING_KEY_STEP_DISPLAY) {
+// 		STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
+
+// 		// Jormungandr public key, hence the "ed25519_pk" prefix
+// 		// https://github.com/input-output-hk/jormungandr/blob/a057af27493d823be02480bb20258c25ff979e2a/jormungandr-lib/src/crypto/key.rs#L126
+// 		ui_displayBech32Screen(
+// 		        "Voting public key",
+// 		        "ed25519_pk",
+// 		        subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_VOTING_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_VOTING_KEY_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleVotingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_KEY);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+// 	{
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		{
+// 			VALIDATE(wireDataSize == SIZEOF(subctx->stateData.votingPubKey), ERR_INVALID_DATA);
+// 			read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 			STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
+// 			view_parseBuffer(subctx->stateData.votingPubKey, &view, CATALYST_VOTING_PUBLIC_KEY_LENGTH);
+
+// 			VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 		}
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationVotingKey();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
+// 		auxDataHashBuilder_catalystRegistration_enter(auxDataHashBuilder);
+// 		auxDataHashBuilder_catalystRegistration_enterPayload(auxDataHashBuilder);
+// 		auxDataHashBuilder_catalystRegistration_addVotingKey(
+// 		        auxDataHashBuilder, subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH
+// 		);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_KEY_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleVotingKey_ui_runStep();
+// }
+
+// // ============================== STAKING KEY ==============================
+
+// enum {
+// 	HANDLE_STAKING_KEY_STEP_WARNING = 8300,
+// 	HANDLE_STAKING_KEY_STEP_DISPLAY,
+// 	HANDLE_STAKING_KEY_STEP_RESPOND,
+// 	HANDLE_STAKING_KEY_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleStakingKey_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleStakingKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_STAKING_KEY_STEP_WARNING) {
+// 		ui_displayPaginatedText(
+// 		        "Unusual request",
+// 		        "Proceed with care",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_STAKING_KEY_STEP_DISPLAY) {
+// 		ui_displayStakingKeyScreen(
+// 		        &subctx->stakingKeyPath,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_STAKING_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_STAKING_KEY_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleStakingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_STAKING_KEY);
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stakingKeyPath, SIZEOF(subctx->stakingKeyPath));
+// 	}
+// 	{
+// 		// parse input
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		view_skipBytes(
+// 		        &view,
+// 		        bip44_parseFromWire(&subctx->stakingKeyPath, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view))
+// 		);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationStakingKey(
+// 	                                   &subctx->stakingKeyPath
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		extendedPublicKey_t extStakingPubKey;
+// 		deriveExtendedPublicKey(&subctx->stakingKeyPath, &extStakingPubKey);
+// 		auxDataHashBuilder_catalystRegistration_addStakingKey(
+// 		        &AUX_DATA_CTX->auxDataHashBuilder, extStakingPubKey.pubKey, SIZEOF(extStakingPubKey.pubKey)
+// 		);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_STAKING_KEY_STEP_WARNING);
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_STAKING_KEY_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_STAKING_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleStakingKey_ui_runStep();
+// }
+
+// // ============================== VOTING REWARDS ADDRESS ==============================
+
+// enum {
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING = 8500,
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS,
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND,
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID
+// };
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING) {
+// 		ui_displayPaginatedText(
+// 		        "Unusual request",
+// 		        "Proceed with care",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS) {
+// 		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
+// 		size_t addressSize = deriveAddress(
+// 		                             &subctx->stateData.votingRewardsAddressParams,
+// 		                             addressBuffer,
+// 		                             SIZEOF(addressBuffer)
+// 		                     );
+// 		ASSERT(addressSize > 0);
+// 		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
+
+// 		ui_displayAddressScreen(
+// 		        "Rewards go to",
+// 		        addressBuffer,
+// 		        addressSize,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleVotingRewardsAddressAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// safety checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(
+// 		        &subctx->stateData.votingRewardsAddressParams,
+// 		        SIZEOF(subctx->stateData.votingRewardsAddressParams)
+// 		);
+// 	}
+// 	{
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		view_parseAddressParams(&view, &subctx->stateData.votingRewardsAddressParams);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationVotingRewardsAddressParams(
+// 	                                   &subctx->stateData.votingRewardsAddressParams,
+// 	                                   commonTxData->networkId
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		ASSERT(isShelleyAddressType(subctx->stateData.votingRewardsAddressParams.type));
+// 		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
+// 		size_t addressSize = deriveAddress(
+// 		                             &subctx->stateData.votingRewardsAddressParams,
+// 		                             addressBuffer,
+// 		                             SIZEOF(addressBuffer)
+// 		                     );
+// 		ASSERT(addressSize > 0);
+// 		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
+
+// 		auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
+// 		        &AUX_DATA_CTX->auxDataHashBuilder, addressBuffer, addressSize
+// 		);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING);
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+
+// 		signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep();
+// 	}
+// }
+
+// // ============================== NONCE ==============================
+
+// enum {
+// 	HANDLE_NONCE_STEP_DISPLAY = 8600,
+// 	HANDLE_NONCE_STEP_RESPOND,
+// 	HANDLE_NONCE_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleNonce_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleNonce_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_NONCE_STEP_DISPLAY) {
+// 		ui_displayUint64Screen(
+// 		        "Nonce",
+// 		        subctx->stateData.nonce,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_NONCE_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_NONCE_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleNonceAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_NONCE);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		VALIDATE(wireDataSize == 8, ERR_INVALID_DATA);
+// 		subctx->stateData.nonce = u8be_read(wireDataBuffer);
+// 		TRACE(
+// 		        "Catalyst registration nonce: %d",
+// 		        subctx->stateData.nonce
+// 		);
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationNonce();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		auxDataHashBuilder_catalystRegistration_addNonce(&AUX_DATA_CTX->auxDataHashBuilder, subctx->stateData.nonce);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NONCE_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NONCE_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleNonce_ui_runStep();
+// }
+
+// // ============================== CONFIRM ==============================
+
+// enum {
+// 	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
+// 	HANDLE_CONFIRM_STEP_DISPLAY_HASH,
+// 	HANDLE_CONFIRM_STEP_RESPOND,
+// 	HANDLE_CONFIRM_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleConfirm_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleConfirm_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
+// 		// confirming this means the signature being sent out of the device
+// 		// so we want to show it in non-expert mode too
+// 		ui_displayPrompt(
+// 		        "Confirm voting key",
+// 		        "registration?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_DISPLAY_HASH) {
+// 		if (!app_mode_expert()) {
+// 			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_RESPOND);
+// 		}
+// 		ui_displayHexBufferScreen(
+// 		        "Auxiliary data hash",
+// 		        subctx->auxDataHash,
+// 		        SIZEOF(subctx->auxDataHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
+// 		struct {
+// 			uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
+// 			uint8_t signature[ED25519_SIGNATURE_LENGTH];
+// 		} wireResponse = {0};
+
+// 		STATIC_ASSERT(SIZEOF(subctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong aux data hash length");
+// 		memmove(wireResponse.auxDataHash, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
+
+// 		STATIC_ASSERT(SIZEOF(subctx->stateData.registrationSignature) == ED25519_SIGNATURE_LENGTH, "Wrong Catalyst registration signature length");
+// 		memmove(wireResponse.signature, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
+
+// 		io_send_buf(SUCCESS, (uint8_t*) &wireResponse, SIZEOF(wireResponse));
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
+// {
+// 	{
+// 		//sanity checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_CONFIRM);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+
+// 	{
+// 		// no data to receive
+// 		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationConfirm();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
+// 		{
+// 			uint8_t votingPayloadHashBuffer[CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH] = {0};
+// 			auxDataHashBuilder_catalystRegistration_finalizePayload(auxDataHashBuilder, votingPayloadHashBuffer, AUX_DATA_HASH_LENGTH);
+// 			getCatalystVotingRegistrationSignature(
+// 			        &subctx->stakingKeyPath,
+// 			        votingPayloadHashBuffer, CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH,
+// 			        subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH
+// 			);
+// 		}
+// 		auxDataHashBuilder_catalystRegistration_addSignature(auxDataHashBuilder, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
+// 		auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(auxDataHashBuilder);
+
+// 		auxDataHashBuilder_finalize(auxDataHashBuilder, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleConfirm_ui_runStep();
+// }
+
+
+// // ============================== main APDU handler ==============================
+
+// enum {
+// 	APDU_INSTRUCTION_VOTING_KEY = 0x30,
+// 	APDU_INSTRUCTION_STAKING_KEY = 0x31,
+// 	APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS = 0x32,
+// 	APDU_INSTRUCTION_NONCE = 0x33,
+// 	APDU_INSTRUCTION_CONFIRM = 0x34
+// };
+
+// bool signTxCatalystRegistration_isValidInstruction(uint8_t p2)
+// {
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_VOTING_KEY:
+// 	case APDU_INSTRUCTION_STAKING_KEY:
+// 	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
+// 	case APDU_INSTRUCTION_NONCE:
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		return true;
+
+// 	default:
+// 		return false;
+// 	}
+// }
+
+// void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_VOTING_KEY:
+// 		signTxCatalystRegistration_handleVotingKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_STAKING_KEY:
+// 		signTxCatalystRegistration_handleStakingKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
+// 		signTxCatalystRegistration_handleVotingRewardsAddressAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_NONCE:
+// 		signTxCatalystRegistration_handleNonceAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		signTxCatalystRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	default:
+// 		// this is not supposed to be called with invalid p2
+// 		ASSERT(false);
+// 	}
+// }
diff --git a/src/signTxCatalystRegistration.h b/src/signTxCatalystRegistration.h
index 05c53f4..9968666 100644
--- a/src/signTxCatalystRegistration.h
+++ b/src/signTxCatalystRegistration.h
@@ -1,51 +1,51 @@
-#ifndef H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
-#define H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
-
-#include "common.h"
-#include "cardano.h"
-#include "auxDataHashBuilder.h"
-#include "addressUtilsShelley.h"
-
-
-#define CATALYST_VOTING_PUBLIC_KEY_LENGTH 32
-
-// SIGN_STAGE_AUX_DATA = 24
-// AUX_DATA_TYPE_CATALYST_REGISTRATION = 1
-typedef enum {
-	STATE_CATALYST_REGISTRATION_VOTING_KEY = 2410,
-	STATE_CATALYST_REGISTRATION_STAKING_KEY = 2411,
-	STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS = 2412,
-	STATE_CATALYST_REGISTRATION_NONCE = 2413,
-	STATE_CATALYST_REGISTRATION_CONFIRM = 2414,
-	STATE_CATALYST_REGISTRATION_FINISHED = 2415
-} sign_tx_catalyst_registration_state_t;
-
-typedef struct {
-	sign_tx_catalyst_registration_state_t state;
-	int ui_step;
-
-	/*
-	* Staking key path kept outside of stateData to produce the Catalyst registration
-	* signature at the end of the flow without re-requesting the staking key path
-	* (with the undesired side-effect of allowing signing with a different key than included
-	* in the registration payload)
-	*/
-	bip44_path_t stakingKeyPath;
-	uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
-
-	union {
-		uint8_t votingPubKey[CATALYST_VOTING_PUBLIC_KEY_LENGTH];
-		addressParams_t votingRewardsAddressParams;
-		uint64_t nonce;
-		uint8_t registrationSignature[ED25519_SIGNATURE_LENGTH];
-	} stateData;
-} catalyst_registration_context_t;
-
-void signTxCatalystRegistration_init();
-
-bool signTxCatalystRegistration_isValidInstruction(uint8_t p2);
-void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
-
-bool signTxCatalystRegistration_isFinished();
-
-#endif // H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
+// #ifndef H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
+// #define H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
+
+// #include "common.h"
+// #include "cardano.h"
+// #include "auxDataHashBuilder.h"
+// #include "addressUtilsShelley.h"
+
+
+// #define CATALYST_VOTING_PUBLIC_KEY_LENGTH 32
+
+// // SIGN_STAGE_AUX_DATA = 24
+// // AUX_DATA_TYPE_CATALYST_REGISTRATION = 1
+// typedef enum {
+// 	STATE_CATALYST_REGISTRATION_VOTING_KEY = 2410,
+// 	STATE_CATALYST_REGISTRATION_STAKING_KEY = 2411,
+// 	STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS = 2412,
+// 	STATE_CATALYST_REGISTRATION_NONCE = 2413,
+// 	STATE_CATALYST_REGISTRATION_CONFIRM = 2414,
+// 	STATE_CATALYST_REGISTRATION_FINISHED = 2415
+// } sign_tx_catalyst_registration_state_t;
+
+// typedef struct {
+// 	sign_tx_catalyst_registration_state_t state;
+// 	int ui_step;
+
+// 	/*
+// 	* Staking key path kept outside of stateData to produce the Catalyst registration
+// 	* signature at the end of the flow without re-requesting the staking key path
+// 	* (with the undesired side-effect of allowing signing with a different key than included
+// 	* in the registration payload)
+// 	*/
+// 	bip44_path_t stakingKeyPath;
+// 	uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
+
+// 	union {
+// 		uint8_t votingPubKey[CATALYST_VOTING_PUBLIC_KEY_LENGTH];
+// 		addressParams_t votingRewardsAddressParams;
+// 		uint64_t nonce;
+// 		uint8_t registrationSignature[ED25519_SIGNATURE_LENGTH];
+// 	} stateData;
+// } catalyst_registration_context_t;
+
+// void signTxCatalystRegistration_init();
+
+// bool signTxCatalystRegistration_isValidInstruction(uint8_t p2);
+// void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
+
+// bool signTxCatalystRegistration_isFinished();
+
+// #endif // H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
diff --git a/src/signTxMint.c b/src/signTxMint.c
index dcacf7a..1b42afb 100644
--- a/src/signTxMint.c
+++ b/src/signTxMint.c
@@ -1,468 +1,468 @@
-#include "signTxMint.h"
-#include "signTxUtils.h"
-#include "state.h"
-#include "uiHelpers.h"
-#include "utils.h"
-#include "uiScreens.h"
-#include "textUtils.h"
-#include "securityPolicy.h"
-#include "tokens.h"
-
-static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
-
-static mint_context_t* accessSubcontext()
-{
-	return &BODY_CTX->stageContext.mint_subctx;
-}
-
-static inline void CHECK_STATE(sign_tx_mint_state_t expected)
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("Mint submachine state: current %d, expected %d", subctx->state, expected);
-	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
-}
-
-static inline void advanceState()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("Advancing mint state from: %d", subctx->state);
-
-	switch (subctx->state) {
-
-	case STATE_MINT_TOP_LEVEL_DATA:
-		ASSERT(subctx->numAssetGroups > 0);
-		ASSERT(subctx->currentAssetGroup == 0);
-		subctx->state = STATE_MINT_ASSET_GROUP;
-		break;
-
-	case STATE_MINT_ASSET_GROUP:
-		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
-
-		// we are going to receive token amounts for this group
-		ASSERT(subctx->numTokens > 0);
-		ASSERT(subctx->currentToken == 0);
-
-		subctx->state = STATE_MINT_TOKEN;
-		break;
-
-	case STATE_MINT_TOKEN:
-		// we are done with the current token group
-		ASSERT(subctx->currentToken == subctx->numTokens);
-		subctx->currentToken = 0;
-		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
-		subctx->currentAssetGroup++;
-
-		if (subctx->currentAssetGroup == subctx->numAssetGroups) {
-			// the whole token bundle has been received
-			subctx->state = STATE_MINT_CONFIRM;
-		} else {
-			subctx->state = STATE_MINT_ASSET_GROUP;
-		}
-		break;
-
-	case STATE_MINT_CONFIRM:
-		subctx->state = STATE_MINT_FINISHED;
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	TRACE("Advancing mint state to: %d", subctx->state);
-}
-
-enum {
-	HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY = 9200,
-	HANDLE_MINT_TOP_LEVEL_DATA_RESPOND,
-	HANDLE_MINT_TOP_LEVEL_DATA_INVALID,
-};
-
-__noinline_due_to_stack__
-static void signTxMint_handleTopLevelData_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-
-	ui_callback_fn_t* this_fn = signTxMint_handleTopLevelData_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY) {
-		char secondLine[50] = {0};
-		explicit_bzero(secondLine, SIZEOF(secondLine));
-		STATIC_ASSERT(!IS_SIGNED(subctx->numAssetGroups), "signed type for %u");
-		snprintf(secondLine, SIZEOF(secondLine), "%u asset groups", subctx->numAssetGroups);
-		ASSERT(strlen(secondLine) + 1 < SIZEOF(secondLine));
-
-		ui_displayPaginatedText(
-		        "Mint",
-		        secondLine,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_MINT_TOP_LEVEL_DATA_INVALID);
-}
-
-static void signTxMint_handleTopLevelDataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// safety checks
-		CHECK_STATE(STATE_MINT_TOP_LEVEL_DATA);
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	TRACE_BUFFER(wireDataBuffer, wireDataSize);
-	mint_context_t* subctx = accessSubcontext();
-	{
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		uint32_t numAssetGroups = parse_u4be(&view);
-		TRACE("num asset groups %u", numAssetGroups);
-		VALIDATE(numAssetGroups <= OUTPUT_ASSET_GROUPS_MAX, ERR_INVALID_DATA);
-		VALIDATE(numAssetGroups > 0, ERR_INVALID_DATA);
-
-		STATIC_ASSERT(OUTPUT_ASSET_GROUPS_MAX <= UINT16_MAX, "wrong max token groups");
-		ASSERT_TYPE(subctx->numAssetGroups, uint16_t);
-		subctx->numAssetGroups = (uint16_t) numAssetGroups;
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-	subctx->mintSecurityPolicy = policyForSignTxMintInit(commonTxData->txSigningMode);
-	ENSURE_NOT_DENIED(subctx->mintSecurityPolicy);
-
-	txHashBuilder_addMint_topLevelData(&BODY_CTX->txHashBuilder, subctx->numAssetGroups);
-
-	subctx->ui_step = HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY;
-	signTxMint_handleTopLevelData_ui_runStep();
-}
-
-enum {
-	HANDLE_ASSET_GROUP_STEP_DISPLAY = 9300,
-	HANDLE_ASSET_GROUP_STEP_RESPOND,
-	HANDLE_ASSET_GROUP_STEP_INVALID,
-};
-
-static void signTxMint_handleAssetGroup_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-
-	ui_callback_fn_t* this_fn = signTxMint_handleAssetGroup_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_ASSET_GROUP_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_ASSET_GROUP_STEP_INVALID);
-}
-
-static void signTxMint_handleAssetGroupAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// sanity checks
-		CHECK_STATE(STATE_MINT_ASSET_GROUP);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	mint_context_t* subctx = accessSubcontext();
-	{
-		token_group_t* tokenGroup = &subctx->stateData.tokenGroup;
-
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		uint8_t candidatePolicyId[MINTING_POLICY_ID_SIZE] = {0};
-		view_parseBuffer(candidatePolicyId, &view, MINTING_POLICY_ID_SIZE);
-
-		if (subctx->currentAssetGroup > 0) {
-			// compare with previous value before overwriting it
-			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
-			                 tokenGroup->policyId, MINTING_POLICY_ID_SIZE,
-			                 candidatePolicyId, MINTING_POLICY_ID_SIZE
-			         ), ERR_INVALID_DATA);
-		}
-
-		STATIC_ASSERT(SIZEOF(tokenGroup->policyId) >= MINTING_POLICY_ID_SIZE, "wrong policyId length");
-		memmove(tokenGroup->policyId, candidatePolicyId, MINTING_POLICY_ID_SIZE);
-
-		uint32_t numTokens = parse_u4be(&view);
-		VALIDATE(numTokens <= OUTPUT_TOKENS_IN_GROUP_MAX, ERR_INVALID_DATA);
-		VALIDATE(numTokens > 0, ERR_INVALID_DATA);
-		STATIC_ASSERT(OUTPUT_TOKENS_IN_GROUP_MAX <= UINT16_MAX, "wrong max token amounts in a group");
-		ASSERT_TYPE(subctx->numTokens, uint16_t);
-		subctx->numTokens = (uint16_t) numTokens;
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	{
-		// add tokengroup to tx
-		TRACE("Adding token group hash to tx hash");
-		txHashBuilder_addMint_tokenGroup(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.tokenGroup.policyId, MINTING_POLICY_ID_SIZE,
-		        subctx->numTokens
-		);
-		TRACE();
-	}
-
-	subctx->ui_step = HANDLE_ASSET_GROUP_STEP_RESPOND;
-	signTxMint_handleAssetGroup_ui_runStep();
-}
-
-enum {
-	HANDLE_TOKEN_STEP_DISPLAY_NAME = 9400,
-	HANDLE_TOKEN_STEP_DISPLAY_AMOUNT,
-	HANDLE_TOKEN_STEP_RESPOND,
-	HANDLE_TOKEN_STEP_INVALID,
-};
-
-
-static void signTxMint_handleToken_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	ui_callback_fn_t* this_fn = signTxMint_handleToken_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_NAME) {
-		ui_displayAssetFingerprintScreen(
-		        &subctx->stateData.tokenGroup,
-		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_AMOUNT) {
-		ui_displayTokenAmountMintScreen(
-		        &subctx->stateData.tokenGroup,
-		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
-		        subctx->stateData.token.amount,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_TOKEN_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		ASSERT(subctx->currentToken < subctx->numTokens);
-		subctx->currentToken++;
-
-		if (subctx->currentToken == subctx->numTokens) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_TOKEN_STEP_INVALID);
-}
-
-static void signTxMint_handleTokenAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// sanity checks
-		CHECK_STATE(STATE_MINT_TOKEN);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	mint_context_t* subctx = accessSubcontext();
-	{
-		mint_token_amount_t* token = &subctx->stateData.token;
-
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		const size_t candidateAssetNameSize = parse_u4be(&view);
-		VALIDATE(candidateAssetNameSize <= ASSET_NAME_SIZE_MAX, ERR_INVALID_DATA);
-		uint8_t candidateAssetNameBytes[ASSET_NAME_SIZE_MAX] = {0};
-		view_parseBuffer(candidateAssetNameBytes, &view, candidateAssetNameSize);
-
-		if (subctx->currentToken > 0) {
-			// compare with previous value before overwriting it
-			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
-			                 token->assetNameBytes, token->assetNameSize,
-			                 candidateAssetNameBytes, candidateAssetNameSize
-			         ), ERR_INVALID_DATA);
-		}
-
-		token->assetNameSize = candidateAssetNameSize;
-		STATIC_ASSERT(SIZEOF(token->assetNameBytes) >= ASSET_NAME_SIZE_MAX, "wrong asset name buffer size");
-		memmove(token->assetNameBytes, candidateAssetNameBytes, candidateAssetNameSize);
-
-		token->amount = parse_int64be(&view);
-		TRACE_INT64(token->amount);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	{
-		// select UI step
-		switch (subctx->mintSecurityPolicy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_TOKEN_STEP_DISPLAY_NAME);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_TOKEN_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	{
-		// add tokengroup to tx
-		TRACE("Adding token group hash to tx hash");
-		txHashBuilder_addMint_token(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
-		        subctx->stateData.token.amount
-		);
-		TRACE();
-	}
-
-	signTxMint_handleToken_ui_runStep();
-}
-
-enum {
-	HANDLE_CONFIRM_STEP_FINAL_CONFIRM = 9500,
-	HANDLE_CONFIRM_STEP_RESPOND,
-	HANDLE_CONFIRM_STEP_INVALID,
-};
-
-static void signTxMint_handleConfirm_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	ui_callback_fn_t* this_fn = signTxMint_handleConfirm_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm",
-		        "mint?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
-}
-
-static void signTxMint_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
-{
-	{
-		//sanity checks
-		CHECK_STATE(STATE_MINT_CONFIRM);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	{
-		// no data to receive
-		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
-	}
-
-	mint_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxMintConfirm(subctx->mintSecurityPolicy);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxMint_handleConfirm_ui_runStep();
-}
-
-enum {
-	APDU_INSTRUCTION_TOP_LEVEL_DATA = 0x30,
-	APDU_INSTRUCTION_ASSET_GROUP = 0x31,
-	APDU_INSTRUCTION_TOKEN = 0x32,
-	APDU_INSTRUCTION_CONFIRM = 0x33,
-};
-
-bool signTxMint_isValidInstruction(uint8_t p2)
-{
-	switch (p2) {
-	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
-	case APDU_INSTRUCTION_ASSET_GROUP:
-	case APDU_INSTRUCTION_TOKEN:
-	case APDU_INSTRUCTION_CONFIRM:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-void signTxMint_init()
-{
-	{
-		explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
-	}
-
-	accessSubcontext()->state = STATE_MINT_TOP_LEVEL_DATA;
-}
-
-void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-
-	switch (p2) {
-	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
-		signTxMint_handleTopLevelDataAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_ASSET_GROUP:
-		signTxMint_handleAssetGroupAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_TOKEN:
-		signTxMint_handleTokenAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_CONFIRM:
-		signTxMint_handleConfirmAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	default:
-		// this is not supposed to be called with invalid p2
-		ASSERT(false);
-	}
-}
-
-bool signTxMint_isFinished()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("Mint submachine state: %d", subctx->state);
-	// we are also asserting that the state is valid
-	switch (subctx->state) {
-	case STATE_MINT_FINISHED:
-		return true;
-
-	case STATE_MINT_TOP_LEVEL_DATA:
-	case STATE_MINT_ASSET_GROUP:
-	case STATE_MINT_TOKEN:
-	case STATE_MINT_CONFIRM:
-		return false;
-
-	default:
-		ASSERT(false);
-	}
-}
+// #include "signTxMint.h"
+// #include "signTxUtils.h"
+// #include "state.h"
+// #include "uiHelpers.h"
+// #include "utils.h"
+// #include "uiScreens.h"
+// #include "textUtils.h"
+// #include "securityPolicy.h"
+// #include "tokens.h"
+
+// static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
+
+// static mint_context_t* accessSubcontext()
+// {
+// 	return &BODY_CTX->stageContext.mint_subctx;
+// }
+
+// static inline void CHECK_STATE(sign_tx_mint_state_t expected)
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("Mint submachine state: current %d, expected %d", subctx->state, expected);
+// 	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
+// }
+
+// static inline void advanceState()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("Advancing mint state from: %d", subctx->state);
+
+// 	switch (subctx->state) {
+
+// 	case STATE_MINT_TOP_LEVEL_DATA:
+// 		ASSERT(subctx->numAssetGroups > 0);
+// 		ASSERT(subctx->currentAssetGroup == 0);
+// 		subctx->state = STATE_MINT_ASSET_GROUP;
+// 		break;
+
+// 	case STATE_MINT_ASSET_GROUP:
+// 		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
+
+// 		// we are going to receive token amounts for this group
+// 		ASSERT(subctx->numTokens > 0);
+// 		ASSERT(subctx->currentToken == 0);
+
+// 		subctx->state = STATE_MINT_TOKEN;
+// 		break;
+
+// 	case STATE_MINT_TOKEN:
+// 		// we are done with the current token group
+// 		ASSERT(subctx->currentToken == subctx->numTokens);
+// 		subctx->currentToken = 0;
+// 		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
+// 		subctx->currentAssetGroup++;
+
+// 		if (subctx->currentAssetGroup == subctx->numAssetGroups) {
+// 			// the whole token bundle has been received
+// 			subctx->state = STATE_MINT_CONFIRM;
+// 		} else {
+// 			subctx->state = STATE_MINT_ASSET_GROUP;
+// 		}
+// 		break;
+
+// 	case STATE_MINT_CONFIRM:
+// 		subctx->state = STATE_MINT_FINISHED;
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	TRACE("Advancing mint state to: %d", subctx->state);
+// }
+
+// enum {
+// 	HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY = 9200,
+// 	HANDLE_MINT_TOP_LEVEL_DATA_RESPOND,
+// 	HANDLE_MINT_TOP_LEVEL_DATA_INVALID,
+// };
+
+// __noinline_due_to_stack__
+// static void signTxMint_handleTopLevelData_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+
+// 	ui_callback_fn_t* this_fn = signTxMint_handleTopLevelData_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY) {
+// 		char secondLine[50] = {0};
+// 		explicit_bzero(secondLine, SIZEOF(secondLine));
+// 		STATIC_ASSERT(!IS_SIGNED(subctx->numAssetGroups), "signed type for %u");
+// 		snprintf(secondLine, SIZEOF(secondLine), "%u asset groups", subctx->numAssetGroups);
+// 		ASSERT(strlen(secondLine) + 1 < SIZEOF(secondLine));
+
+// 		ui_displayPaginatedText(
+// 		        "Mint",
+// 		        secondLine,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_MINT_TOP_LEVEL_DATA_INVALID);
+// }
+
+// static void signTxMint_handleTopLevelDataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// safety checks
+// 		CHECK_STATE(STATE_MINT_TOP_LEVEL_DATA);
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 	mint_context_t* subctx = accessSubcontext();
+// 	{
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		uint32_t numAssetGroups = parse_u4be(&view);
+// 		TRACE("num asset groups %u", numAssetGroups);
+// 		VALIDATE(numAssetGroups <= OUTPUT_ASSET_GROUPS_MAX, ERR_INVALID_DATA);
+// 		VALIDATE(numAssetGroups > 0, ERR_INVALID_DATA);
+
+// 		STATIC_ASSERT(OUTPUT_ASSET_GROUPS_MAX <= UINT16_MAX, "wrong max token groups");
+// 		ASSERT_TYPE(subctx->numAssetGroups, uint16_t);
+// 		subctx->numAssetGroups = (uint16_t) numAssetGroups;
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+// 	subctx->mintSecurityPolicy = policyForSignTxMintInit(commonTxData->txSigningMode);
+// 	ENSURE_NOT_DENIED(subctx->mintSecurityPolicy);
+
+// 	txHashBuilder_addMint_topLevelData(&BODY_CTX->txHashBuilder, subctx->numAssetGroups);
+
+// 	subctx->ui_step = HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY;
+// 	signTxMint_handleTopLevelData_ui_runStep();
+// }
+
+// enum {
+// 	HANDLE_ASSET_GROUP_STEP_DISPLAY = 9300,
+// 	HANDLE_ASSET_GROUP_STEP_RESPOND,
+// 	HANDLE_ASSET_GROUP_STEP_INVALID,
+// };
+
+// static void signTxMint_handleAssetGroup_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+
+// 	ui_callback_fn_t* this_fn = signTxMint_handleAssetGroup_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_ASSET_GROUP_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_ASSET_GROUP_STEP_INVALID);
+// }
+
+// static void signTxMint_handleAssetGroupAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_MINT_ASSET_GROUP);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	mint_context_t* subctx = accessSubcontext();
+// 	{
+// 		token_group_t* tokenGroup = &subctx->stateData.tokenGroup;
+
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		uint8_t candidatePolicyId[MINTING_POLICY_ID_SIZE] = {0};
+// 		view_parseBuffer(candidatePolicyId, &view, MINTING_POLICY_ID_SIZE);
+
+// 		if (subctx->currentAssetGroup > 0) {
+// 			// compare with previous value before overwriting it
+// 			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
+// 			                 tokenGroup->policyId, MINTING_POLICY_ID_SIZE,
+// 			                 candidatePolicyId, MINTING_POLICY_ID_SIZE
+// 			         ), ERR_INVALID_DATA);
+// 		}
+
+// 		STATIC_ASSERT(SIZEOF(tokenGroup->policyId) >= MINTING_POLICY_ID_SIZE, "wrong policyId length");
+// 		memmove(tokenGroup->policyId, candidatePolicyId, MINTING_POLICY_ID_SIZE);
+
+// 		uint32_t numTokens = parse_u4be(&view);
+// 		VALIDATE(numTokens <= OUTPUT_TOKENS_IN_GROUP_MAX, ERR_INVALID_DATA);
+// 		VALIDATE(numTokens > 0, ERR_INVALID_DATA);
+// 		STATIC_ASSERT(OUTPUT_TOKENS_IN_GROUP_MAX <= UINT16_MAX, "wrong max token amounts in a group");
+// 		ASSERT_TYPE(subctx->numTokens, uint16_t);
+// 		subctx->numTokens = (uint16_t) numTokens;
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	{
+// 		// add tokengroup to tx
+// 		TRACE("Adding token group hash to tx hash");
+// 		txHashBuilder_addMint_tokenGroup(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.tokenGroup.policyId, MINTING_POLICY_ID_SIZE,
+// 		        subctx->numTokens
+// 		);
+// 		TRACE();
+// 	}
+
+// 	subctx->ui_step = HANDLE_ASSET_GROUP_STEP_RESPOND;
+// 	signTxMint_handleAssetGroup_ui_runStep();
+// }
+
+// enum {
+// 	HANDLE_TOKEN_STEP_DISPLAY_NAME = 9400,
+// 	HANDLE_TOKEN_STEP_DISPLAY_AMOUNT,
+// 	HANDLE_TOKEN_STEP_RESPOND,
+// 	HANDLE_TOKEN_STEP_INVALID,
+// };
+
+
+// static void signTxMint_handleToken_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	ui_callback_fn_t* this_fn = signTxMint_handleToken_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_NAME) {
+// 		ui_displayAssetFingerprintScreen(
+// 		        &subctx->stateData.tokenGroup,
+// 		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_AMOUNT) {
+// 		ui_displayTokenAmountMintScreen(
+// 		        &subctx->stateData.tokenGroup,
+// 		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
+// 		        subctx->stateData.token.amount,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_TOKEN_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		ASSERT(subctx->currentToken < subctx->numTokens);
+// 		subctx->currentToken++;
+
+// 		if (subctx->currentToken == subctx->numTokens) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_TOKEN_STEP_INVALID);
+// }
+
+// static void signTxMint_handleTokenAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_MINT_TOKEN);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	mint_context_t* subctx = accessSubcontext();
+// 	{
+// 		mint_token_amount_t* token = &subctx->stateData.token;
+
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		const size_t candidateAssetNameSize = parse_u4be(&view);
+// 		VALIDATE(candidateAssetNameSize <= ASSET_NAME_SIZE_MAX, ERR_INVALID_DATA);
+// 		uint8_t candidateAssetNameBytes[ASSET_NAME_SIZE_MAX] = {0};
+// 		view_parseBuffer(candidateAssetNameBytes, &view, candidateAssetNameSize);
+
+// 		if (subctx->currentToken > 0) {
+// 			// compare with previous value before overwriting it
+// 			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
+// 			                 token->assetNameBytes, token->assetNameSize,
+// 			                 candidateAssetNameBytes, candidateAssetNameSize
+// 			         ), ERR_INVALID_DATA);
+// 		}
+
+// 		token->assetNameSize = candidateAssetNameSize;
+// 		STATIC_ASSERT(SIZEOF(token->assetNameBytes) >= ASSET_NAME_SIZE_MAX, "wrong asset name buffer size");
+// 		memmove(token->assetNameBytes, candidateAssetNameBytes, candidateAssetNameSize);
+
+// 		token->amount = parse_int64be(&view);
+// 		TRACE_INT64(token->amount);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (subctx->mintSecurityPolicy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_TOKEN_STEP_DISPLAY_NAME);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_TOKEN_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	{
+// 		// add tokengroup to tx
+// 		TRACE("Adding token group hash to tx hash");
+// 		txHashBuilder_addMint_token(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
+// 		        subctx->stateData.token.amount
+// 		);
+// 		TRACE();
+// 	}
+
+// 	signTxMint_handleToken_ui_runStep();
+// }
+
+// enum {
+// 	HANDLE_CONFIRM_STEP_FINAL_CONFIRM = 9500,
+// 	HANDLE_CONFIRM_STEP_RESPOND,
+// 	HANDLE_CONFIRM_STEP_INVALID,
+// };
+
+// static void signTxMint_handleConfirm_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	ui_callback_fn_t* this_fn = signTxMint_handleConfirm_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm",
+// 		        "mint?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
+// }
+
+// static void signTxMint_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
+// {
+// 	{
+// 		//sanity checks
+// 		CHECK_STATE(STATE_MINT_CONFIRM);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	{
+// 		// no data to receive
+// 		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	mint_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxMintConfirm(subctx->mintSecurityPolicy);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxMint_handleConfirm_ui_runStep();
+// }
+
+// enum {
+// 	APDU_INSTRUCTION_TOP_LEVEL_DATA = 0x30,
+// 	APDU_INSTRUCTION_ASSET_GROUP = 0x31,
+// 	APDU_INSTRUCTION_TOKEN = 0x32,
+// 	APDU_INSTRUCTION_CONFIRM = 0x33,
+// };
+
+// bool signTxMint_isValidInstruction(uint8_t p2)
+// {
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
+// 	case APDU_INSTRUCTION_ASSET_GROUP:
+// 	case APDU_INSTRUCTION_TOKEN:
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		return true;
+
+// 	default:
+// 		return false;
+// 	}
+// }
+
+// void signTxMint_init()
+// {
+// 	{
+// 		explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
+// 	}
+
+// 	accessSubcontext()->state = STATE_MINT_TOP_LEVEL_DATA;
+// }
+
+// void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
+// 		signTxMint_handleTopLevelDataAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_ASSET_GROUP:
+// 		signTxMint_handleAssetGroupAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_TOKEN:
+// 		signTxMint_handleTokenAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		signTxMint_handleConfirmAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	default:
+// 		// this is not supposed to be called with invalid p2
+// 		ASSERT(false);
+// 	}
+// }
+
+// bool signTxMint_isFinished()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("Mint submachine state: %d", subctx->state);
+// 	// we are also asserting that the state is valid
+// 	switch (subctx->state) {
+// 	case STATE_MINT_FINISHED:
+// 		return true;
+
+// 	case STATE_MINT_TOP_LEVEL_DATA:
+// 	case STATE_MINT_ASSET_GROUP:
+// 	case STATE_MINT_TOKEN:
+// 	case STATE_MINT_CONFIRM:
+// 		return false;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
diff --git a/src/signTxMint.h b/src/signTxMint.h
index d1dc56f..b5f03e2 100644
--- a/src/signTxMint.h
+++ b/src/signTxMint.h
@@ -1,58 +1,58 @@
-#ifndef H_CARDANO_APP_SIGN_TX_MINT
-#define H_CARDANO_APP_SIGN_TX_MINT
+// #ifndef H_CARDANO_APP_SIGN_TX_MINT
+// #define H_CARDANO_APP_SIGN_TX_MINT
 
-#include "common.h"
-#include "cardano.h"
-#include "addressUtilsShelley.h"
-#include "securityPolicyType.h"
+// #include "common.h"
+// #include "cardano.h"
+// #include "addressUtilsShelley.h"
+// #include "securityPolicyType.h"
 
-#define ASSET_GROUPS_MAX 1000
-#define TOKENS_IN_GROUP_MAX 1000
+// #define ASSET_GROUPS_MAX 1000
+// #define TOKENS_IN_GROUP_MAX 1000
 
-// SIGN_STAGE_BODY_OUTPUTS = 25
-typedef enum {
-	STATE_MINT_TOP_LEVEL_DATA = 2510,
-	STATE_MINT_ASSET_GROUP = 2511,
-	STATE_MINT_TOKEN = 2512,
-	STATE_MINT_CONFIRM = 2513,
-	STATE_MINT_FINISHED = 2514
-} sign_tx_mint_state_t;
+// // SIGN_STAGE_BODY_OUTPUTS = 25
+// typedef enum {
+// 	STATE_MINT_TOP_LEVEL_DATA = 2510,
+// 	STATE_MINT_ASSET_GROUP = 2511,
+// 	STATE_MINT_TOKEN = 2512,
+// 	STATE_MINT_CONFIRM = 2513,
+// 	STATE_MINT_FINISHED = 2514
+// } sign_tx_mint_state_t;
 
-typedef struct {
-	uint8_t assetNameBytes[ASSET_NAME_SIZE_MAX];
-	size_t assetNameSize;
-	int64_t amount;
-} mint_token_amount_t;
+// typedef struct {
+// 	uint8_t assetNameBytes[ASSET_NAME_SIZE_MAX];
+// 	size_t assetNameSize;
+// 	int64_t amount;
+// } mint_token_amount_t;
 
 
-typedef struct {
-	sign_tx_mint_state_t state;
+// typedef struct {
+// 	sign_tx_mint_state_t state;
 
-	int ui_step;
+// 	int ui_step;
 
-	uint16_t numAssetGroups;
-	uint16_t currentAssetGroup;
-	uint16_t numTokens;
-	uint16_t currentToken;
+// 	uint16_t numAssetGroups;
+// 	uint16_t currentAssetGroup;
+// 	uint16_t numTokens;
+// 	uint16_t currentToken;
 
-	// this affects whether amounts and tokens are shown
-	security_policy_t mintSecurityPolicy;
+// 	// this affects whether amounts and tokens are shown
+// 	security_policy_t mintSecurityPolicy;
 
-	union {
-		struct {
-			token_group_t tokenGroup;
-			mint_token_amount_t token;
-		};
-	} stateData;
+// 	union {
+// 		struct {
+// 			token_group_t tokenGroup;
+// 			mint_token_amount_t token;
+// 		};
+// 	} stateData;
 
-} mint_context_t;
+// } mint_context_t;
 
 
-bool signTxMint_isValidInstruction(uint8_t p2);
+// bool signTxMint_isValidInstruction(uint8_t p2);
 
-void signTxMint_init();
-void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
+// void signTxMint_init();
+// void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
 
-bool signTxMint_isFinished();
+// bool signTxMint_isFinished();
 
-#endif // H_CARDANO_APP_SIGN_TX_MINT
+// #endif // H_CARDANO_APP_SIGN_TX_MINT
diff --git a/src/signTxPoolRegistration.c b/src/signTxPoolRegistration.c
index de3a445..93317df 100644
--- a/src/signTxPoolRegistration.c
+++ b/src/signTxPoolRegistration.c
@@ -1,1498 +1,1498 @@
-#include "signTx.h"
-#include "state.h"
-#include "cardano.h"
-#include "addressUtilsShelley.h"
-#include "keyDerivation.h"
-#include "uiHelpers.h"
-#include "signTxUtils.h"
-#include "uiScreens.h"
-#include "txHashBuilder.h"
-#include "textUtils.h"
-#include "hexUtils.h"
-#include "bufView.h"
-#include "securityPolicy.h"
-#include "signTxPoolRegistration.h"
-
-static ins_sign_tx_context_t* ctx = &(instructionState.signTxContext);
-static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
-
-static pool_registration_context_t* accessSubcontext()
-{
-	return &BODY_CTX->stageContext.pool_registration_subctx;
-}
-
-bool signTxPoolRegistration_isFinished()
-{
-	// we are also asserting that the state is valid
-	switch (accessSubcontext()->state) {
-	case STAKE_POOL_REGISTRATION_FINISHED:
-		return true;
-
-	case STAKE_POOL_REGISTRATION_INIT:
-	case STAKE_POOL_REGISTRATION_POOL_KEY:
-	case STAKE_POOL_REGISTRATION_VRF_KEY:
-	case STAKE_POOL_REGISTRATION_FINANCIALS:
-	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
-	case STAKE_POOL_REGISTRATION_OWNERS:
-	case STAKE_POOL_REGISTRATION_RELAYS:
-	case STAKE_POOL_REGISTRATION_METADATA:
-	case STAKE_POOL_REGISTRATION_CONFIRM:
-		return false;
-
-	default:
-		ASSERT(false);
-	}
-}
-
-void signTxPoolRegistration_init()
-{
-	explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
-
-	accessSubcontext()->state = STAKE_POOL_REGISTRATION_INIT;
-}
-
-static inline void CHECK_STATE(sign_tx_pool_registration_state_t expected)
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("Pool registration certificate stage: current %d, expected %d", subctx->state, expected);
-	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
-}
-
-static inline void advanceState()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("Advancing pool registration certificate state from: %d", subctx->state);
-
-	switch (subctx->state) {
-
-	case STAKE_POOL_REGISTRATION_INIT:
-		subctx->state = STAKE_POOL_REGISTRATION_POOL_KEY;
-		break;
-
-	case STAKE_POOL_REGISTRATION_POOL_KEY:
-		subctx->state = STAKE_POOL_REGISTRATION_VRF_KEY;
-		break;
-
-	case STAKE_POOL_REGISTRATION_VRF_KEY:
-		subctx->state = STAKE_POOL_REGISTRATION_FINANCIALS;
-		break;
-
-	case STAKE_POOL_REGISTRATION_FINANCIALS:
-		subctx->state = STAKE_POOL_REGISTRATION_REWARD_ACCOUNT;
-		break;
-
-	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
-		txHashBuilder_addPoolRegistrationCertificate_enterOwners(&BODY_CTX->txHashBuilder);
-		subctx->state = STAKE_POOL_REGISTRATION_OWNERS;
-
-		if (subctx->numOwners > 0) {
-			break;
-		}
-
-	// intentional fallthrough
-
-	case STAKE_POOL_REGISTRATION_OWNERS:
-		ASSERT(subctx->currentOwner == subctx->numOwners);
-
-		txHashBuilder_addPoolRegistrationCertificate_enterRelays(&BODY_CTX->txHashBuilder);
-		subctx->state = STAKE_POOL_REGISTRATION_RELAYS;
-
-		if (subctx->numRelays > 0) {
-			break;
-		}
-
-	// intentional fallthrough
-
-	case STAKE_POOL_REGISTRATION_RELAYS:
-		ASSERT(subctx->currentRelay == subctx->numRelays);
-
-		subctx->state = STAKE_POOL_REGISTRATION_METADATA;
-		break;
-
-	case STAKE_POOL_REGISTRATION_METADATA:
-		subctx->state = STAKE_POOL_REGISTRATION_CONFIRM;
-		break;
-
-	case STAKE_POOL_REGISTRATION_CONFIRM:
-		subctx->state = STAKE_POOL_REGISTRATION_FINISHED;
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	TRACE("Advancing pool registration certificate state to: %d", subctx->state);
-}
-
-
-// ============================== INIT ==============================
-
-enum {
-	HANDLE_POOL_INIT_STEP_DISPLAY = 6100,
-	HANDLE_POOL_INIT_STEP_RESPOND,
-	HANDLE_POOL_INIT_STEP_INVALID,
-} ;
-
-static void handlePoolInit_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolInit_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_INIT_STEP_DISPLAY) {
-		ui_displayPaginatedText(
-		        "Pool registration",
-		        "certificate",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_INIT_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_INIT_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleInitAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_INIT);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	pool_registration_context_t* subctx = accessSubcontext();
-	{
-		// initialization
-		subctx->currentOwner = 0;
-		subctx->currentRelay = 0;
-
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		struct {
-			uint8_t numOwners[4];
-			uint8_t numRelays[4];
-		}* wireHeader = (void*) wireDataBuffer;
-
-		// can't use SIZEOF because it fails for x86 for fuzzing
-		VALIDATE(wireDataSize == sizeof(*wireHeader), ERR_INVALID_DATA);
-
-		uint64_t numOwners = u4be_read(wireHeader->numOwners);
-		uint64_t numRelays = u4be_read(wireHeader->numRelays);
-		TRACE(
-		        "num owners, relays: %d %d",
-		        subctx->numOwners, subctx->numRelays
-		);
-
-		VALIDATE(subctx->numOwners <= POOL_MAX_OWNERS, ERR_INVALID_DATA);
-		VALIDATE(subctx->numRelays <= POOL_MAX_RELAYS, ERR_INVALID_DATA);
-		ASSERT_TYPE(subctx->numOwners, uint16_t);
-		ASSERT_TYPE(subctx->numRelays, uint16_t);
-		subctx->numOwners = (uint16_t) numOwners;
-		subctx->numRelays = (uint16_t) numRelays;
-	}
-	{
-		security_policy_t policy = policyForSignTxStakePoolRegistrationInit(
-		                                   commonTxData->txSigningMode,
-		                                   subctx->numOwners
-		                           );
-		TRACE("Policy: %d", (int) policy);
-		ENSURE_NOT_DENIED(policy);
-	}
-	{
-		txHashBuilder_poolRegistrationCertificate_enter(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->numOwners, subctx->numRelays
-		);
-	}
-
-	subctx->ui_step = HANDLE_POOL_INIT_STEP_DISPLAY;
-	handlePoolInit_ui_runStep();
-}
-
-// ============================== POOL KEY HASH / ID ==============================
-
-static void _toPoolKeyHash(const pool_id_t* poolId, uint8_t* poolKeyHash)
-{
-	switch (poolId->keyReferenceType) {
-
-	case KEY_REFERENCE_HASH: {
-		STATIC_ASSERT(SIZEOF(poolId->hash) == POOL_KEY_HASH_LENGTH, "wrong pool key hash length");
-		memmove(poolKeyHash, poolId->hash, POOL_KEY_HASH_LENGTH);
-		break;
-	}
-	case KEY_REFERENCE_PATH: {
-		bip44_pathToKeyHash(&poolId->path, poolKeyHash, POOL_KEY_HASH_LENGTH);
-		break;
-	}
-	default:
-		ASSERT(false);
-	}
-}
-
-enum {
-	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH = 6200,
-	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID,
-	HANDLE_POOL_KEY_STEP_RESPOND,
-	HANDLE_POOL_KEY_STEP_INVALID,
-} ;
-
-static void handlePoolKey_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH) {
-		ui_displayPathScreen(
-		        "Pool ID path",
-		        &subctx->stateData.poolId.path,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID) {
-		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
-
-		ui_displayBech32Screen(
-		        "Pool ID",
-		        "pool",
-		        poolKeyHash, SIZEOF(poolKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_KEY_STEP_INVALID);
-}
-
-static void _parsePoolId(read_view_t* view)
-{
-	pool_id_t* key = &accessSubcontext()->stateData.poolId;
-
-	key->keyReferenceType = parse_u1be(view);
-
-	switch (key->keyReferenceType) {
-
-	case KEY_REFERENCE_HASH: {
-		STATIC_ASSERT(SIZEOF(key->hash) == POOL_KEY_HASH_LENGTH, "wrong pool id key hash size");
-		view_parseBuffer(key->hash, view, POOL_KEY_HASH_LENGTH);
-		TRACE_BUFFER(key->hash, SIZEOF(key->hash));
-		break;
-	}
-
-	case KEY_REFERENCE_PATH: {
-		view_skipBytes(view, bip44_parseFromWire(&key->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
-		BIP44_PRINTF(&key->path);
-		PRINTF("\n");
-		break;
-	}
-
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handlePoolKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_POOL_KEY);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		_parsePoolId(&view);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxStakePoolRegistrationPoolId(
-	                                   commonTxData->txSigningMode,
-	                                   &subctx->stateData.poolId
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// key derivation must not be done before DENY security policy is enforced
-		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
-
-		txHashBuilder_poolRegistrationCertificate_poolKeyHash(
-		        &BODY_CTX->txHashBuilder,
-		        poolKeyHash, SIZEOF(poolKeyHash)
-		);
-	}
-	{
-		// ui step depends not only on security policy, but also on signing mode
-		int displayUiStep = HANDLE_POOL_KEY_STEP_INVALID;
-		switch (commonTxData->txSigningMode) {
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID;
-			break;
-
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH;
-			break;
-
-		default:
-			ASSERT(false);
-		}
-		ASSERT(displayUiStep != HANDLE_POOL_KEY_STEP_INVALID);
-
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayUiStep);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handlePoolKey_ui_runStep();
-}
-
-// ============================== VRF KEY HASH ==============================
-
-enum {
-	HANDLE_POOL_VRF_KEY_STEP_DISPLAY = 6300,
-	HANDLE_POOL_VRF_KEY_STEP_RESPOND,
-	HANDLE_POOL_VRF_KEY_STEP_INVALID,
-} ;
-
-static void handlePoolVrfKey_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolVrfKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_DISPLAY) {
-		ui_displayBech32Screen(
-		        "VRF key hash",
-		        "vrf_vk",
-		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_VRF_KEY_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleVrfKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_VRF_KEY);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	pool_registration_context_t* subctx = accessSubcontext();
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		VALIDATE(wireDataSize == SIZEOF(subctx->stateData.vrfKeyHash), ERR_INVALID_DATA);
-
-		{
-			STATIC_ASSERT(SIZEOF(subctx->stateData.vrfKeyHash) == VRF_KEY_HASH_LENGTH, "wrong vrfKeyHash size");
-			memmove(subctx->stateData.vrfKeyHash, wireDataBuffer, VRF_KEY_HASH_LENGTH);
-			// nothing to validate, all values are valid
-		}
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationVrfKey(
-	                                   commonTxData->txSigningMode
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash)
-		);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_VRF_KEY_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_VRF_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handlePoolVrfKey_ui_runStep();
-}
-
-// ============================== POOL FINANCIALS ==============================
-
-enum {
-	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE = 6400,
-	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST,
-	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN,
-	HANDLE_POOL_FINANCIALS_STEP_RESPOND,
-	HANDLE_POOL_FINANCIALS_STEP_INVALID,
-} ;
-
-static void handlePoolFinancials_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolFinancials_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE) {
-		ui_displayAdaAmountScreen(
-		        "Pledge",
-		        subctx->stateData.pledge,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST) {
-		ui_displayAdaAmountScreen(
-		        "Cost",
-		        subctx->stateData.cost,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN) {
-		ui_displayPoolMarginScreen(
-		        subctx->stateData.marginNumerator,
-		        subctx->stateData.marginDenominator,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_FINANCIALS_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handlePoolFinancialsAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_FINANCIALS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	pool_registration_context_t* subctx = accessSubcontext();
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		struct {
-			uint8_t pledge[8];
-			uint8_t cost[8];
-			uint8_t marginNumerator[8];
-			uint8_t marginDenominator[8];
-		}* wireHeader = (void*) wireDataBuffer;
-
-		VALIDATE(wireDataSize == SIZEOF(*wireHeader), ERR_INVALID_DATA);
-
-		{
-			ASSERT_TYPE(subctx->stateData.pledge, uint64_t);
-			subctx->stateData.pledge = u8be_read(wireHeader->pledge);
-			TRACE_ADA_AMOUNT("pledge ", subctx->stateData.pledge);
-			VALIDATE(subctx->stateData.pledge < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
-
-			ASSERT_TYPE(subctx->stateData.cost, uint64_t);
-			subctx->stateData.cost = u8be_read(wireHeader->cost);
-			TRACE_ADA_AMOUNT("cost ", subctx->stateData.cost);
-			VALIDATE(subctx->stateData.cost < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
-
-			ASSERT_TYPE(subctx->stateData.marginNumerator, uint64_t);
-			subctx->stateData.marginNumerator = u8be_read(wireHeader->marginNumerator);
-			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginNumerator, 8);
-			VALIDATE(subctx->stateData.marginNumerator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
-
-			ASSERT_TYPE(subctx->stateData.marginDenominator, uint64_t);
-			subctx->stateData.marginDenominator = u8be_read(wireHeader->marginDenominator);
-			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginDenominator, 8);
-			VALIDATE(subctx->stateData.marginDenominator != 0, ERR_INVALID_DATA);
-			VALIDATE(subctx->stateData.marginDenominator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
-			VALIDATE(subctx->stateData.marginNumerator <= subctx->stateData.marginDenominator, ERR_INVALID_DATA);
-		}
-	}
-	{
-		txHashBuilder_poolRegistrationCertificate_financials(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.pledge, subctx->stateData.cost,
-		        subctx->stateData.marginNumerator, subctx->stateData.marginDenominator
-		);
-	}
-
-	subctx->ui_step = HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE;
-	handlePoolFinancials_ui_runStep();
-}
-
-// ============================== POOL REWARD ACCOUNT ==============================
-
-enum {
-	HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY = 6500,
-	HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND,
-	HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID,
-};
-
-static void handlePoolRewardAccount_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolRewardAccount_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY) {
-		ui_displayRewardAccountScreen(
-		        &subctx->stateData.poolRewardAccount,
-		        commonTxData->networkId,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID);
-}
-
-static void _parsePoolRewardAccount(read_view_t* view)
-{
-	reward_account_t* rewardAccount = &accessSubcontext()->stateData.poolRewardAccount;
-
-	rewardAccount->keyReferenceType = parse_u1be(view);
-
-	switch (rewardAccount->keyReferenceType) {
-
-	case KEY_REFERENCE_HASH: {
-		STATIC_ASSERT(SIZEOF(rewardAccount->hashBuffer) == REWARD_ACCOUNT_SIZE, "wrong reward account hash buffer size");
-		view_parseBuffer(rewardAccount->hashBuffer, view, REWARD_ACCOUNT_SIZE);
-		TRACE_BUFFER(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
-
-		const uint8_t header = getAddressHeader(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
-		VALIDATE(getAddressType(header) == REWARD_KEY || getAddressType(header) == REWARD_SCRIPT, ERR_INVALID_DATA);
-		VALIDATE(getNetworkId(header) == commonTxData->networkId, ERR_INVALID_DATA);
-		break;
-	}
-
-	case KEY_REFERENCE_PATH: {
-		view_skipBytes(view, bip44_parseFromWire(&rewardAccount->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
-		BIP44_PRINTF(&rewardAccount->path);
-		PRINTF("\n");
-		break;
-	}
-
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleRewardAccountAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_REWARD_ACCOUNT);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		_parsePoolRewardAccount(&view);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxStakePoolRegistrationRewardAccount(
-	                                   commonTxData->txSigningMode,
-	                                   &subctx->stateData.poolRewardAccount
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// key derivation must not be done before DENY security policy is enforced
-		uint8_t rewardAccountBuffer[REWARD_ACCOUNT_SIZE] = {0};
-		rewardAccountToBuffer(&subctx->stateData.poolRewardAccount, commonTxData->networkId, rewardAccountBuffer);
-
-		txHashBuilder_poolRegistrationCertificate_rewardAccount(
-		        &BODY_CTX->txHashBuilder,
-		        rewardAccountBuffer, SIZEOF(rewardAccountBuffer)
-		);
-	}
-
-	{
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handlePoolRewardAccount_ui_runStep();
-}
-
-// ============================== OWNER ==============================
-
-enum {
-	HANDLE_OWNER_STEP_DISPLAY = 6600,
-	HANDLE_OWNER_STEP_RESPOND,
-	HANDLE_OWNER_STEP_INVALID,
-};
-
-static void handleOwner_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleOwner_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_OWNER_STEP_DISPLAY) {
-		ui_displayPoolOwnerScreen(&subctx->stateData.owner, subctx->currentOwner, commonTxData->networkId, this_fn);
-	}
-	UI_STEP(HANDLE_OWNER_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		subctx->currentOwner++;
-		if (subctx->currentOwner == subctx->numOwners) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_OWNER_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void _addOwnerToTxHash()
-{
-	pool_owner_t* owner = &accessSubcontext()->stateData.owner;
-
-	uint8_t ownerKeyHash[ADDRESS_KEY_HASH_LENGTH] = {0};
-
-	switch (owner->keyReferenceType) {
-
-	case KEY_REFERENCE_PATH:
-		bip44_pathToKeyHash(&owner->path, ownerKeyHash, SIZEOF(ownerKeyHash));
-		break;
-
-	case KEY_REFERENCE_HASH:
-		memmove(ownerKeyHash, owner->keyHash, SIZEOF(ownerKeyHash));
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	// add data to tx
-	TRACE("Adding owner to tx hash");
-	txHashBuilder_addPoolRegistrationCertificate_addOwner(
-	        &BODY_CTX->txHashBuilder,
-	        ownerKeyHash, SIZEOF(ownerKeyHash)
-	);
-	TRACE();
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleOwnerAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_OWNERS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	pool_owner_t* owner = &subctx->stateData.owner;
-
-	explicit_bzero(owner, SIZEOF(*owner));
-
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		owner->keyReferenceType = parse_u1be(&view);
-		switch (owner->keyReferenceType) {
-
-		case KEY_REFERENCE_HASH: {
-			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
-			view_parseBuffer(owner->keyHash, &view, ADDRESS_KEY_HASH_LENGTH);
-			TRACE_BUFFER(owner->keyHash, SIZEOF(owner->keyHash));
-			break;
-		}
-
-		case KEY_REFERENCE_PATH: {
-			view_skipBytes(&view, bip44_parseFromWire(&owner->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
-			// further validation of the path in security policy below
-			TRACE("Owner given by path:");
-			BIP44_PRINTF(&owner->path);
-			PRINTF("\n");
-
-			subctx->numOwnersGivenByPath++;
-			VALIDATE(!ctx->poolOwnerByPath, ERR_INVALID_DATA);
-			ctx->poolOwnerByPath = true;
-			memmove(&ctx->poolOwnerPath, &owner->path, SIZEOF(owner->path));
-			break;
-		}
-
-		default:
-			THROW(ERR_INVALID_DATA);
-		}
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationOwner(commonTxData->txSigningMode, owner, subctx->numOwnersGivenByPath);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	_addOwnerToTxHash();
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_OWNER_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_OWNER_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handleOwner_ui_runStep();
-}
-
-
-// ============================== RELAY ==============================
-
-enum {
-	HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER = 6700,
-	HANDLE_RELAY_IP_STEP_DISPLAY_IPV4,
-	HANDLE_RELAY_IP_STEP_DISPLAY_IPV6,
-	HANDLE_RELAY_IP_STEP_DISPLAY_PORT,
-	HANDLE_RELAY_IP_STEP_RESPOND,
-	HANDLE_RELAY_IP_STEP_INVALID,
-};
-
-static void handleRelay_ip_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleRelay_ip_ui_runStep;
-
-	pool_relay_t* relay = &subctx->stateData.relay;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER) {
-		ui_displayPoolRelayScreen(
-		        relay,
-		        subctx->currentRelay,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV4) {
-		ui_displayIpv4Screen(
-		        &relay->ipv4,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV6) {
-		ui_displayIpv6Screen(
-		        &relay->ipv6,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_PORT) {
-		ui_displayIpPortScreen(
-		        &relay->port,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		subctx->currentRelay++;
-		TRACE("current relay %d", subctx->currentRelay);
-
-		if (subctx->currentRelay == subctx->numRelays) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_RELAY_IP_STEP_INVALID);
-}
-
-enum {
-	HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER = 6800,
-	HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME,
-	HANDLE_RELAY_DNS_STEP_DISPLAY_PORT,
-	HANDLE_RELAY_DNS_STEP_RESPOND,
-	HANDLE_RELAY_DNS_STEP_INVALID,
-};
-
-static void handleRelay_dns_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleRelay_dns_ui_runStep;
-
-	pool_relay_t* relay = &subctx->stateData.relay;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER) {
-		ui_displayPoolRelayScreen(
-		        relay,
-		        subctx->currentRelay,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME) {
-		char dnsNameStr[1 + DNS_NAME_SIZE_MAX] = {0};
-		explicit_bzero(dnsNameStr, SIZEOF(dnsNameStr));
-		ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
-		memmove(dnsNameStr, relay->dnsName, relay->dnsNameSize);
-		dnsNameStr[relay->dnsNameSize] = '\0';
-		ASSERT(strlen(dnsNameStr) == relay->dnsNameSize);
-
-		ui_displayPaginatedText(
-		        "DNS name",
-		        dnsNameStr,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_PORT) {
-		if (relay->format == RELAY_MULTIPLE_HOST_NAME) {
-			// nothing to display in this step, so we skip it
-			UI_STEP_JUMP(HANDLE_RELAY_DNS_STEP_RESPOND);
-		}
-
-		ui_displayIpPortScreen(
-		        &relay->port,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_DNS_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		subctx->currentRelay++;
-		TRACE("current relay %d", subctx->currentRelay);
-
-		if (subctx->currentRelay == subctx->numRelays) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_RELAY_DNS_STEP_INVALID);
-}
-
-static void _parsePort(ipport_t* port, read_view_t* view)
-{
-	uint8_t isPortGiven = parse_u1be(view);
-	if (isPortGiven == ITEM_INCLUDED_YES) {
-		port->isNull = false;
-		ASSERT_TYPE(port->number, uint16_t);
-		port->number = parse_u2be(view);
-		TRACE("Port: %u", port->number);
-	} else {
-		VALIDATE(isPortGiven == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
-		port->isNull = true;
-	}
-}
-
-static void _parseIpv4(ipv4_t* ipv4, read_view_t* view)
-{
-	uint8_t isIpv4Given = parse_u1be(view);
-	if (isIpv4Given == ITEM_INCLUDED_YES) {
-		ipv4->isNull = false;
-		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
-		view_parseBuffer(ipv4->ip, view, IPV4_SIZE);
-		TRACE("ipv4");
-		TRACE_BUFFER(ipv4->ip, IPV4_SIZE);
-	} else {
-		VALIDATE(isIpv4Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
-		ipv4->isNull = true;
-	}
-}
-
-static void _parseIpv6(ipv6_t* ipv6, read_view_t* view)
-{
-	uint8_t isIpv6Given = parse_u1be(view);
-	if (isIpv6Given == ITEM_INCLUDED_YES) {
-		ipv6->isNull = false;
-		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
-		view_parseBuffer(ipv6->ip, view, IPV6_SIZE);
-		TRACE("ipv6");
-		TRACE_BUFFER(ipv6->ip, IPV6_SIZE);
-	} else {
-		VALIDATE(isIpv6Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
-		ipv6->isNull = true;
-	}
-}
-
-static void _parseDnsName(pool_relay_t* relay, read_view_t* view)
-{
-	relay->dnsNameSize = view_remainingSize(view);
-	VALIDATE(relay->dnsNameSize <= DNS_NAME_SIZE_MAX, ERR_INVALID_DATA);
-	VALIDATE(str_isAllowedDnsName(VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)), ERR_INVALID_DATA);
-
-	STATIC_ASSERT(SIZEOF(relay->dnsName) == DNS_NAME_SIZE_MAX, "wrong dns name buffer size");
-	view_parseBuffer(relay->dnsName, view, relay->dnsNameSize);
-}
-
-/*
-wire data:
-1B relay format
-
-format 0 single_host_addr:
-1B + [2B port] + 1B + [4B ipv4] + 1B + [16B ipv6]
-
-format 1 single_host_name:
-1B + [2B port] + [0-64B dns_name]
-
-format 2 multi_host_name:
-[0-64B dns_name]
-*/
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleRelayAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_RELAYS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	pool_relay_t* relay = &accessSubcontext()->stateData.relay;
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		relay->format = parse_u1be(&view);
-		TRACE("Relay format %u", relay->format);
-		switch (relay->format) {
-
-		// validation differs from the CDDL spec
-		// the CDDL spec allows combinations of parameters that lead
-		// to meaningless relays that are ignored by nodes
-		// so we only allow meaningful relays
-
-		case RELAY_SINGLE_HOST_IP: {
-			_parsePort(&relay->port, &view);
-			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
-			_parseIpv4(&relay->ipv4, &view);
-			_parseIpv6(&relay->ipv6, &view);
-			VALIDATE(!relay->ipv4.isNull || !relay->ipv6.isNull, ERR_INVALID_DATA);
-			break;
-		}
-
-		case RELAY_SINGLE_HOST_NAME: {
-			_parsePort(&relay->port, &view);
-			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
-			_parseDnsName(relay, &view);
-			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
-			break;
-		}
-
-		case RELAY_MULTIPLE_HOST_NAME: {
-			_parseDnsName(relay, &view);
-			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
-			break;
-		}
-
-		default:
-			THROW(ERR_INVALID_DATA);
-		}
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationRelay(commonTxData->txSigningMode, relay);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	TRACE("Adding relay format %d to tx hash", (int) relay->format);
-	txHashBuilder_addPoolRegistrationCertificate_addRelay(&BODY_CTX->txHashBuilder, relay);
-
-	{
-		int respondStep = -1;
-		int displayStep = -1;
-		void (*uiFn)() = NULL;
-
-		switch (relay->format) {
-
-		case RELAY_SINGLE_HOST_IP: {
-			respondStep = HANDLE_RELAY_IP_STEP_RESPOND;
-			displayStep = HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER;
-			uiFn = handleRelay_ip_ui_runStep;
-			break;
-		}
-
-		case RELAY_SINGLE_HOST_NAME:
-		case RELAY_MULTIPLE_HOST_NAME: {
-			respondStep = HANDLE_RELAY_DNS_STEP_RESPOND;
-			displayStep = HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER;
-			uiFn = handleRelay_dns_ui_runStep;
-			break;
-		}
-
-		default:
-			THROW(ERR_INVALID_DATA);
-		}
-
-		ASSERT(respondStep != -1);
-		ASSERT(displayStep != -1);
-		ASSERT(uiFn != NULL);
-
-		// select UI steps and call ui handler
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, respondStep);
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayStep);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-
-		uiFn();
-	}
-}
-
-
-// ============================== METADATA ==============================
-
-enum {
-	HANDLE_NULL_METADATA_STEP_DISPLAY = 6900,
-	HANDLE_NULL_METADATA_STEP_RESPOND,
-	HANDLE_NULL_METADATA_STEP_INVALID,
-};
-
-static void handleNullMetadata_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleNullMetadata_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_NULL_METADATA_STEP_DISPLAY) {
-		ui_displayPaginatedText(
-		        "No metadata",
-		        "(anonymous pool)",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_NULL_METADATA_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_NULL_METADATA_STEP_INVALID);
-}
-
-enum {
-	HANDLE_METADATA_STEP_DISPLAY_URL = 7000,
-	HANDLE_METADATA_STEP_DISPLAY_HASH,
-	HANDLE_METADATA_STEP_RESPOND,
-	HANDLE_METADATA_STEP_INVALID,
-};
-
-static void handleMetadata_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleMetadata_ui_runStep;
-
-	pool_metadata_t* md = &subctx->stateData.metadata;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_URL) {
-		char metadataUrlStr[1 + POOL_METADATA_URL_LENGTH_MAX] = {0};
-		explicit_bzero(metadataUrlStr, SIZEOF(metadataUrlStr));
-		ASSERT(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX);
-		memmove(metadataUrlStr, md->url, md->urlSize);
-		metadataUrlStr[md->urlSize] = '\0';
-		ASSERT(strlen(metadataUrlStr) == md->urlSize);
-
-		ui_displayPaginatedText(
-		        "Pool metadata url",
-		        metadataUrlStr,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_HASH) {
-		char metadataHashHex[1 + 2 * POOL_METADATA_HASH_LENGTH] = {0};
-		explicit_bzero(metadataHashHex, SIZEOF(metadataHashHex));
-		size_t len = str_formatMetadata(
-		                     md->hash, SIZEOF(md->hash),
-		                     metadataHashHex, SIZEOF(metadataHashHex)
-		             );
-		ASSERT(len + 1 == SIZEOF(metadataHashHex));
-
-		ui_displayPaginatedText(
-		        "Pool metadata hash",
-		        metadataHashHex,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_METADATA_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_METADATA_STEP_INVALID);
-}
-
-static void handleNullMetadata()
-{
-	security_policy_t policy = policyForSignTxStakePoolRegistrationNoMetadata();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// add null metadata to certificate
-		TRACE("Adding null pool metadata to tx hash");
-		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(&BODY_CTX->txHashBuilder);
-	}
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NULL_METADATA_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NULL_METADATA_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handleNullMetadata_ui_runStep();
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handlePoolMetadataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_METADATA);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	explicit_bzero(&subctx->stateData.metadata, SIZEOF(subctx->stateData.metadata));
-
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		pool_metadata_t* md = &subctx->stateData.metadata;
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		{
-			// deal with null metadata
-			uint8_t includeMetadataByte = parse_u1be(&view);
-			int includeMetadata = signTx_parseIncluded(includeMetadataByte);
-
-			if (!includeMetadata) {
-				VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-				handleNullMetadata();
-				return;
-			}
-		}
-		{
-			STATIC_ASSERT(SIZEOF(md->hash) == POOL_METADATA_HASH_LENGTH, "wrong pool metadata buffer size");
-			view_parseBuffer(md->hash, &view, POOL_METADATA_HASH_LENGTH);
-		}
-		{
-			md->urlSize = view_remainingSize(&view);
-			VALIDATE(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX, ERR_INVALID_DATA);
-			STATIC_ASSERT(SIZEOF(md->url) >= POOL_METADATA_URL_LENGTH_MAX, "wrong pool metada url size");
-			view_parseBuffer(md->url, &view, md->urlSize);
-
-			// whitespace not allowed
-			VALIDATE(str_isPrintableAsciiWithoutSpaces(md->url, md->urlSize), ERR_INVALID_DATA);
-		}
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationMetadata();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// add metadata to tx
-		TRACE("Adding metadata hash to tx hash");
-		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.metadata.url, subctx->stateData.metadata.urlSize,
-		        subctx->stateData.metadata.hash, SIZEOF(subctx->stateData.metadata.hash)
-		);
-	}
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_METADATA_STEP_DISPLAY_URL);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_METADATA_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handleMetadata_ui_runStep();
-}
-
-// ============================== CONFIRM ==============================
-
-enum {
-	HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS = 7100,
-	HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS,
-	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
-	HANDLE_CONFIRM_STEP_RESPOND,
-	HANDLE_CONFIRM_STEP_INVALID,
-};
-
-static void signTxPoolRegistration_handleConfirm_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxPoolRegistration_handleConfirm_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	// we display potencially suspicious facts about the certificate
-	// that have not been explicitly shown to the user before:
-	// missing owners or relays
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS) {
-		if (subctx->numOwners == 0) {
-			ui_displayPaginatedText(
-			        "No",
-			        "pool owners",
-			        this_fn
-			);
-		} else {
-			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS);
-		}
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS) {
-		bool isOperator = commonTxData->txSigningMode == SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR;
-		if ((subctx->numRelays == 0) && isOperator) {
-			ui_displayPaginatedText(
-			        "No",
-			        "pool relays",
-			        this_fn
-			);
-		} else {
-			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
-		}
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm stake",
-		        "pool registration?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		//sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_CONFIRM);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	{
-		// no data to receive
-		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxStakePoolRegistrationConfirm(subctx->numOwners, subctx->numRelays);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxPoolRegistration_handleConfirm_ui_runStep();
-}
-
-
-// ============================== main APDU handler ==============================
-
-enum {
-	APDU_INSTRUCTION_INIT = 0x30,
-	APDU_INSTRUCTION_POOL_KEY = 0x31,
-	APDU_INSTRUCTION_VRF_KEY = 0x32,
-	APDU_INSTRUCTION_FINANCIALS = 0x33,
-	APDU_INSTRUCTION_REWARD_ACCOUNT = 0x34,
-	APDU_INSTRUCTION_OWNERS = 0x35,
-	APDU_INSTRUCTION_RELAYS = 0x36,
-	APDU_INSTRUCTION_METADATA = 0x37,
-	APDU_INSTRUCTION_CONFIRMATION = 0x38
-};
-
-bool signTxPoolRegistration_isValidInstruction(uint8_t p2)
-{
-	switch (p2) {
-	case APDU_INSTRUCTION_INIT:
-	case APDU_INSTRUCTION_POOL_KEY:
-	case APDU_INSTRUCTION_VRF_KEY:
-	case APDU_INSTRUCTION_FINANCIALS:
-	case APDU_INSTRUCTION_REWARD_ACCOUNT:
-	case APDU_INSTRUCTION_OWNERS:
-	case APDU_INSTRUCTION_RELAYS:
-	case APDU_INSTRUCTION_METADATA:
-	case APDU_INSTRUCTION_CONFIRMATION:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	TRACE("p2 = 0x%x", p2);
-	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-
-	switch (p2) {
-	case APDU_INSTRUCTION_INIT:
-		signTxPoolRegistration_handleInitAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_POOL_KEY:
-		signTxPoolRegistration_handlePoolKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_VRF_KEY:
-		signTxPoolRegistration_handleVrfKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_FINANCIALS:
-		signTxPoolRegistration_handlePoolFinancialsAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_REWARD_ACCOUNT:
-		signTxPoolRegistration_handleRewardAccountAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_OWNERS:
-		signTxPoolRegistration_handleOwnerAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_RELAYS:
-		signTxPoolRegistration_handleRelayAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_METADATA:
-		signTxPoolRegistration_handlePoolMetadataAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_CONFIRMATION:
-		signTxPoolRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	default:
-		// this is not supposed to be called with invalid p2
-		ASSERT(false);
-	}
-}
+// #include "signTx.h"
+// #include "state.h"
+// #include "cardano.h"
+// #include "addressUtilsShelley.h"
+// #include "keyDerivation.h"
+// #include "uiHelpers.h"
+// #include "signTxUtils.h"
+// #include "uiScreens.h"
+// #include "txHashBuilder.h"
+// #include "textUtils.h"
+// #include "hexUtils.h"
+// #include "bufView.h"
+// #include "securityPolicy.h"
+// #include "signTxPoolRegistration.h"
+
+// static ins_sign_tx_context_t* ctx = &(instructionState.signTxContext);
+// static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
+
+// static pool_registration_context_t* accessSubcontext()
+// {
+// 	return &BODY_CTX->stageContext.pool_registration_subctx;
+// }
+
+// bool signTxPoolRegistration_isFinished()
+// {
+// 	// we are also asserting that the state is valid
+// 	switch (accessSubcontext()->state) {
+// 	case STAKE_POOL_REGISTRATION_FINISHED:
+// 		return true;
+
+// 	case STAKE_POOL_REGISTRATION_INIT:
+// 	case STAKE_POOL_REGISTRATION_POOL_KEY:
+// 	case STAKE_POOL_REGISTRATION_VRF_KEY:
+// 	case STAKE_POOL_REGISTRATION_FINANCIALS:
+// 	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
+// 	case STAKE_POOL_REGISTRATION_OWNERS:
+// 	case STAKE_POOL_REGISTRATION_RELAYS:
+// 	case STAKE_POOL_REGISTRATION_METADATA:
+// 	case STAKE_POOL_REGISTRATION_CONFIRM:
+// 		return false;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// void signTxPoolRegistration_init()
+// {
+// 	explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
+
+// 	accessSubcontext()->state = STAKE_POOL_REGISTRATION_INIT;
+// }
+
+// static inline void CHECK_STATE(sign_tx_pool_registration_state_t expected)
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("Pool registration certificate stage: current %d, expected %d", subctx->state, expected);
+// 	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
+// }
+
+// static inline void advanceState()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("Advancing pool registration certificate state from: %d", subctx->state);
+
+// 	switch (subctx->state) {
+
+// 	case STAKE_POOL_REGISTRATION_INIT:
+// 		subctx->state = STAKE_POOL_REGISTRATION_POOL_KEY;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_POOL_KEY:
+// 		subctx->state = STAKE_POOL_REGISTRATION_VRF_KEY;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_VRF_KEY:
+// 		subctx->state = STAKE_POOL_REGISTRATION_FINANCIALS;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_FINANCIALS:
+// 		subctx->state = STAKE_POOL_REGISTRATION_REWARD_ACCOUNT;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
+// 		txHashBuilder_addPoolRegistrationCertificate_enterOwners(&BODY_CTX->txHashBuilder);
+// 		subctx->state = STAKE_POOL_REGISTRATION_OWNERS;
+
+// 		if (subctx->numOwners > 0) {
+// 			break;
+// 		}
+
+// 	// intentional fallthrough
+
+// 	case STAKE_POOL_REGISTRATION_OWNERS:
+// 		ASSERT(subctx->currentOwner == subctx->numOwners);
+
+// 		txHashBuilder_addPoolRegistrationCertificate_enterRelays(&BODY_CTX->txHashBuilder);
+// 		subctx->state = STAKE_POOL_REGISTRATION_RELAYS;
+
+// 		if (subctx->numRelays > 0) {
+// 			break;
+// 		}
+
+// 	// intentional fallthrough
+
+// 	case STAKE_POOL_REGISTRATION_RELAYS:
+// 		ASSERT(subctx->currentRelay == subctx->numRelays);
+
+// 		subctx->state = STAKE_POOL_REGISTRATION_METADATA;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_METADATA:
+// 		subctx->state = STAKE_POOL_REGISTRATION_CONFIRM;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_CONFIRM:
+// 		subctx->state = STAKE_POOL_REGISTRATION_FINISHED;
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	TRACE("Advancing pool registration certificate state to: %d", subctx->state);
+// }
+
+
+// // ============================== INIT ==============================
+
+// enum {
+// 	HANDLE_POOL_INIT_STEP_DISPLAY = 6100,
+// 	HANDLE_POOL_INIT_STEP_RESPOND,
+// 	HANDLE_POOL_INIT_STEP_INVALID,
+// } ;
+
+// static void handlePoolInit_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolInit_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_INIT_STEP_DISPLAY) {
+// 		ui_displayPaginatedText(
+// 		        "Pool registration",
+// 		        "certificate",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_INIT_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_INIT_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleInitAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_INIT);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	{
+// 		// initialization
+// 		subctx->currentOwner = 0;
+// 		subctx->currentRelay = 0;
+
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		struct {
+// 			uint8_t numOwners[4];
+// 			uint8_t numRelays[4];
+// 		}* wireHeader = (void*) wireDataBuffer;
+
+// 		// can't use SIZEOF because it fails for x86 for fuzzing
+// 		VALIDATE(wireDataSize == sizeof(*wireHeader), ERR_INVALID_DATA);
+
+// 		uint64_t numOwners = u4be_read(wireHeader->numOwners);
+// 		uint64_t numRelays = u4be_read(wireHeader->numRelays);
+// 		TRACE(
+// 		        "num owners, relays: %d %d",
+// 		        subctx->numOwners, subctx->numRelays
+// 		);
+
+// 		VALIDATE(subctx->numOwners <= POOL_MAX_OWNERS, ERR_INVALID_DATA);
+// 		VALIDATE(subctx->numRelays <= POOL_MAX_RELAYS, ERR_INVALID_DATA);
+// 		ASSERT_TYPE(subctx->numOwners, uint16_t);
+// 		ASSERT_TYPE(subctx->numRelays, uint16_t);
+// 		subctx->numOwners = (uint16_t) numOwners;
+// 		subctx->numRelays = (uint16_t) numRelays;
+// 	}
+// 	{
+// 		security_policy_t policy = policyForSignTxStakePoolRegistrationInit(
+// 		                                   commonTxData->txSigningMode,
+// 		                                   subctx->numOwners
+// 		                           );
+// 		TRACE("Policy: %d", (int) policy);
+// 		ENSURE_NOT_DENIED(policy);
+// 	}
+// 	{
+// 		txHashBuilder_poolRegistrationCertificate_enter(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->numOwners, subctx->numRelays
+// 		);
+// 	}
+
+// 	subctx->ui_step = HANDLE_POOL_INIT_STEP_DISPLAY;
+// 	handlePoolInit_ui_runStep();
+// }
+
+// // ============================== POOL KEY HASH / ID ==============================
+
+// static void _toPoolKeyHash(const pool_id_t* poolId, uint8_t* poolKeyHash)
+// {
+// 	switch (poolId->keyReferenceType) {
+
+// 	case KEY_REFERENCE_HASH: {
+// 		STATIC_ASSERT(SIZEOF(poolId->hash) == POOL_KEY_HASH_LENGTH, "wrong pool key hash length");
+// 		memmove(poolKeyHash, poolId->hash, POOL_KEY_HASH_LENGTH);
+// 		break;
+// 	}
+// 	case KEY_REFERENCE_PATH: {
+// 		bip44_pathToKeyHash(&poolId->path, poolKeyHash, POOL_KEY_HASH_LENGTH);
+// 		break;
+// 	}
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// enum {
+// 	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH = 6200,
+// 	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID,
+// 	HANDLE_POOL_KEY_STEP_RESPOND,
+// 	HANDLE_POOL_KEY_STEP_INVALID,
+// } ;
+
+// static void handlePoolKey_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH) {
+// 		ui_displayPathScreen(
+// 		        "Pool ID path",
+// 		        &subctx->stateData.poolId.path,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID) {
+// 		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
+
+// 		ui_displayBech32Screen(
+// 		        "Pool ID",
+// 		        "pool",
+// 		        poolKeyHash, SIZEOF(poolKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_KEY_STEP_INVALID);
+// }
+
+// static void _parsePoolId(read_view_t* view)
+// {
+// 	pool_id_t* key = &accessSubcontext()->stateData.poolId;
+
+// 	key->keyReferenceType = parse_u1be(view);
+
+// 	switch (key->keyReferenceType) {
+
+// 	case KEY_REFERENCE_HASH: {
+// 		STATIC_ASSERT(SIZEOF(key->hash) == POOL_KEY_HASH_LENGTH, "wrong pool id key hash size");
+// 		view_parseBuffer(key->hash, view, POOL_KEY_HASH_LENGTH);
+// 		TRACE_BUFFER(key->hash, SIZEOF(key->hash));
+// 		break;
+// 	}
+
+// 	case KEY_REFERENCE_PATH: {
+// 		view_skipBytes(view, bip44_parseFromWire(&key->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
+// 		BIP44_PRINTF(&key->path);
+// 		PRINTF("\n");
+// 		break;
+// 	}
+
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handlePoolKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_POOL_KEY);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		_parsePoolId(&view);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationPoolId(
+// 	                                   commonTxData->txSigningMode,
+// 	                                   &subctx->stateData.poolId
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// key derivation must not be done before DENY security policy is enforced
+// 		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
+
+// 		txHashBuilder_poolRegistrationCertificate_poolKeyHash(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        poolKeyHash, SIZEOF(poolKeyHash)
+// 		);
+// 	}
+// 	{
+// 		// ui step depends not only on security policy, but also on signing mode
+// 		int displayUiStep = HANDLE_POOL_KEY_STEP_INVALID;
+// 		switch (commonTxData->txSigningMode) {
+// 		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID;
+// 			break;
+
+// 		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH;
+// 			break;
+
+// 		default:
+// 			ASSERT(false);
+// 		}
+// 		ASSERT(displayUiStep != HANDLE_POOL_KEY_STEP_INVALID);
+
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayUiStep);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handlePoolKey_ui_runStep();
+// }
+
+// // ============================== VRF KEY HASH ==============================
+
+// enum {
+// 	HANDLE_POOL_VRF_KEY_STEP_DISPLAY = 6300,
+// 	HANDLE_POOL_VRF_KEY_STEP_RESPOND,
+// 	HANDLE_POOL_VRF_KEY_STEP_INVALID,
+// } ;
+
+// static void handlePoolVrfKey_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolVrfKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_DISPLAY) {
+// 		ui_displayBech32Screen(
+// 		        "VRF key hash",
+// 		        "vrf_vk",
+// 		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_VRF_KEY_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleVrfKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_VRF_KEY);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		VALIDATE(wireDataSize == SIZEOF(subctx->stateData.vrfKeyHash), ERR_INVALID_DATA);
+
+// 		{
+// 			STATIC_ASSERT(SIZEOF(subctx->stateData.vrfKeyHash) == VRF_KEY_HASH_LENGTH, "wrong vrfKeyHash size");
+// 			memmove(subctx->stateData.vrfKeyHash, wireDataBuffer, VRF_KEY_HASH_LENGTH);
+// 			// nothing to validate, all values are valid
+// 		}
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationVrfKey(
+// 	                                   commonTxData->txSigningMode
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash)
+// 		);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_VRF_KEY_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_VRF_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handlePoolVrfKey_ui_runStep();
+// }
+
+// // ============================== POOL FINANCIALS ==============================
+
+// enum {
+// 	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE = 6400,
+// 	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST,
+// 	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN,
+// 	HANDLE_POOL_FINANCIALS_STEP_RESPOND,
+// 	HANDLE_POOL_FINANCIALS_STEP_INVALID,
+// } ;
+
+// static void handlePoolFinancials_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolFinancials_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE) {
+// 		ui_displayAdaAmountScreen(
+// 		        "Pledge",
+// 		        subctx->stateData.pledge,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST) {
+// 		ui_displayAdaAmountScreen(
+// 		        "Cost",
+// 		        subctx->stateData.cost,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN) {
+// 		ui_displayPoolMarginScreen(
+// 		        subctx->stateData.marginNumerator,
+// 		        subctx->stateData.marginDenominator,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_FINANCIALS_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handlePoolFinancialsAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_FINANCIALS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		struct {
+// 			uint8_t pledge[8];
+// 			uint8_t cost[8];
+// 			uint8_t marginNumerator[8];
+// 			uint8_t marginDenominator[8];
+// 		}* wireHeader = (void*) wireDataBuffer;
+
+// 		VALIDATE(wireDataSize == SIZEOF(*wireHeader), ERR_INVALID_DATA);
+
+// 		{
+// 			ASSERT_TYPE(subctx->stateData.pledge, uint64_t);
+// 			subctx->stateData.pledge = u8be_read(wireHeader->pledge);
+// 			TRACE_ADA_AMOUNT("pledge ", subctx->stateData.pledge);
+// 			VALIDATE(subctx->stateData.pledge < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
+
+// 			ASSERT_TYPE(subctx->stateData.cost, uint64_t);
+// 			subctx->stateData.cost = u8be_read(wireHeader->cost);
+// 			TRACE_ADA_AMOUNT("cost ", subctx->stateData.cost);
+// 			VALIDATE(subctx->stateData.cost < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
+
+// 			ASSERT_TYPE(subctx->stateData.marginNumerator, uint64_t);
+// 			subctx->stateData.marginNumerator = u8be_read(wireHeader->marginNumerator);
+// 			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginNumerator, 8);
+// 			VALIDATE(subctx->stateData.marginNumerator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
+
+// 			ASSERT_TYPE(subctx->stateData.marginDenominator, uint64_t);
+// 			subctx->stateData.marginDenominator = u8be_read(wireHeader->marginDenominator);
+// 			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginDenominator, 8);
+// 			VALIDATE(subctx->stateData.marginDenominator != 0, ERR_INVALID_DATA);
+// 			VALIDATE(subctx->stateData.marginDenominator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
+// 			VALIDATE(subctx->stateData.marginNumerator <= subctx->stateData.marginDenominator, ERR_INVALID_DATA);
+// 		}
+// 	}
+// 	{
+// 		txHashBuilder_poolRegistrationCertificate_financials(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.pledge, subctx->stateData.cost,
+// 		        subctx->stateData.marginNumerator, subctx->stateData.marginDenominator
+// 		);
+// 	}
+
+// 	subctx->ui_step = HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE;
+// 	handlePoolFinancials_ui_runStep();
+// }
+
+// // ============================== POOL REWARD ACCOUNT ==============================
+
+// enum {
+// 	HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY = 6500,
+// 	HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND,
+// 	HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID,
+// };
+
+// static void handlePoolRewardAccount_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolRewardAccount_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY) {
+// 		ui_displayRewardAccountScreen(
+// 		        &subctx->stateData.poolRewardAccount,
+// 		        commonTxData->networkId,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID);
+// }
+
+// static void _parsePoolRewardAccount(read_view_t* view)
+// {
+// 	reward_account_t* rewardAccount = &accessSubcontext()->stateData.poolRewardAccount;
+
+// 	rewardAccount->keyReferenceType = parse_u1be(view);
+
+// 	switch (rewardAccount->keyReferenceType) {
+
+// 	case KEY_REFERENCE_HASH: {
+// 		STATIC_ASSERT(SIZEOF(rewardAccount->hashBuffer) == REWARD_ACCOUNT_SIZE, "wrong reward account hash buffer size");
+// 		view_parseBuffer(rewardAccount->hashBuffer, view, REWARD_ACCOUNT_SIZE);
+// 		TRACE_BUFFER(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
+
+// 		const uint8_t header = getAddressHeader(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
+// 		VALIDATE(getAddressType(header) == REWARD_KEY || getAddressType(header) == REWARD_SCRIPT, ERR_INVALID_DATA);
+// 		VALIDATE(getNetworkId(header) == commonTxData->networkId, ERR_INVALID_DATA);
+// 		break;
+// 	}
+
+// 	case KEY_REFERENCE_PATH: {
+// 		view_skipBytes(view, bip44_parseFromWire(&rewardAccount->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
+// 		BIP44_PRINTF(&rewardAccount->path);
+// 		PRINTF("\n");
+// 		break;
+// 	}
+
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleRewardAccountAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_REWARD_ACCOUNT);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		_parsePoolRewardAccount(&view);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationRewardAccount(
+// 	                                   commonTxData->txSigningMode,
+// 	                                   &subctx->stateData.poolRewardAccount
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// key derivation must not be done before DENY security policy is enforced
+// 		uint8_t rewardAccountBuffer[REWARD_ACCOUNT_SIZE] = {0};
+// 		rewardAccountToBuffer(&subctx->stateData.poolRewardAccount, commonTxData->networkId, rewardAccountBuffer);
+
+// 		txHashBuilder_poolRegistrationCertificate_rewardAccount(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        rewardAccountBuffer, SIZEOF(rewardAccountBuffer)
+// 		);
+// 	}
+
+// 	{
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handlePoolRewardAccount_ui_runStep();
+// }
+
+// // ============================== OWNER ==============================
+
+// enum {
+// 	HANDLE_OWNER_STEP_DISPLAY = 6600,
+// 	HANDLE_OWNER_STEP_RESPOND,
+// 	HANDLE_OWNER_STEP_INVALID,
+// };
+
+// static void handleOwner_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleOwner_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_OWNER_STEP_DISPLAY) {
+// 		ui_displayPoolOwnerScreen(&subctx->stateData.owner, subctx->currentOwner, commonTxData->networkId, this_fn);
+// 	}
+// 	UI_STEP(HANDLE_OWNER_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		subctx->currentOwner++;
+// 		if (subctx->currentOwner == subctx->numOwners) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_OWNER_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void _addOwnerToTxHash()
+// {
+// 	pool_owner_t* owner = &accessSubcontext()->stateData.owner;
+
+// 	uint8_t ownerKeyHash[ADDRESS_KEY_HASH_LENGTH] = {0};
+
+// 	switch (owner->keyReferenceType) {
+
+// 	case KEY_REFERENCE_PATH:
+// 		bip44_pathToKeyHash(&owner->path, ownerKeyHash, SIZEOF(ownerKeyHash));
+// 		break;
+
+// 	case KEY_REFERENCE_HASH:
+// 		memmove(ownerKeyHash, owner->keyHash, SIZEOF(ownerKeyHash));
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	// add data to tx
+// 	TRACE("Adding owner to tx hash");
+// 	txHashBuilder_addPoolRegistrationCertificate_addOwner(
+// 	        &BODY_CTX->txHashBuilder,
+// 	        ownerKeyHash, SIZEOF(ownerKeyHash)
+// 	);
+// 	TRACE();
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleOwnerAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_OWNERS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	pool_owner_t* owner = &subctx->stateData.owner;
+
+// 	explicit_bzero(owner, SIZEOF(*owner));
+
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		owner->keyReferenceType = parse_u1be(&view);
+// 		switch (owner->keyReferenceType) {
+
+// 		case KEY_REFERENCE_HASH: {
+// 			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
+// 			view_parseBuffer(owner->keyHash, &view, ADDRESS_KEY_HASH_LENGTH);
+// 			TRACE_BUFFER(owner->keyHash, SIZEOF(owner->keyHash));
+// 			break;
+// 		}
+
+// 		case KEY_REFERENCE_PATH: {
+// 			view_skipBytes(&view, bip44_parseFromWire(&owner->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
+// 			// further validation of the path in security policy below
+// 			TRACE("Owner given by path:");
+// 			BIP44_PRINTF(&owner->path);
+// 			PRINTF("\n");
+
+// 			subctx->numOwnersGivenByPath++;
+// 			VALIDATE(!ctx->poolOwnerByPath, ERR_INVALID_DATA);
+// 			ctx->poolOwnerByPath = true;
+// 			memmove(&ctx->poolOwnerPath, &owner->path, SIZEOF(owner->path));
+// 			break;
+// 		}
+
+// 		default:
+// 			THROW(ERR_INVALID_DATA);
+// 		}
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationOwner(commonTxData->txSigningMode, owner, subctx->numOwnersGivenByPath);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	_addOwnerToTxHash();
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_OWNER_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_OWNER_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handleOwner_ui_runStep();
+// }
+
+
+// // ============================== RELAY ==============================
+
+// enum {
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER = 6700,
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_IPV4,
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_IPV6,
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_PORT,
+// 	HANDLE_RELAY_IP_STEP_RESPOND,
+// 	HANDLE_RELAY_IP_STEP_INVALID,
+// };
+
+// static void handleRelay_ip_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleRelay_ip_ui_runStep;
+
+// 	pool_relay_t* relay = &subctx->stateData.relay;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER) {
+// 		ui_displayPoolRelayScreen(
+// 		        relay,
+// 		        subctx->currentRelay,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV4) {
+// 		ui_displayIpv4Screen(
+// 		        &relay->ipv4,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV6) {
+// 		ui_displayIpv6Screen(
+// 		        &relay->ipv6,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_PORT) {
+// 		ui_displayIpPortScreen(
+// 		        &relay->port,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		subctx->currentRelay++;
+// 		TRACE("current relay %d", subctx->currentRelay);
+
+// 		if (subctx->currentRelay == subctx->numRelays) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_RELAY_IP_STEP_INVALID);
+// }
+
+// enum {
+// 	HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER = 6800,
+// 	HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME,
+// 	HANDLE_RELAY_DNS_STEP_DISPLAY_PORT,
+// 	HANDLE_RELAY_DNS_STEP_RESPOND,
+// 	HANDLE_RELAY_DNS_STEP_INVALID,
+// };
+
+// static void handleRelay_dns_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleRelay_dns_ui_runStep;
+
+// 	pool_relay_t* relay = &subctx->stateData.relay;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER) {
+// 		ui_displayPoolRelayScreen(
+// 		        relay,
+// 		        subctx->currentRelay,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME) {
+// 		char dnsNameStr[1 + DNS_NAME_SIZE_MAX] = {0};
+// 		explicit_bzero(dnsNameStr, SIZEOF(dnsNameStr));
+// 		ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
+// 		memmove(dnsNameStr, relay->dnsName, relay->dnsNameSize);
+// 		dnsNameStr[relay->dnsNameSize] = '\0';
+// 		ASSERT(strlen(dnsNameStr) == relay->dnsNameSize);
+
+// 		ui_displayPaginatedText(
+// 		        "DNS name",
+// 		        dnsNameStr,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_PORT) {
+// 		if (relay->format == RELAY_MULTIPLE_HOST_NAME) {
+// 			// nothing to display in this step, so we skip it
+// 			UI_STEP_JUMP(HANDLE_RELAY_DNS_STEP_RESPOND);
+// 		}
+
+// 		ui_displayIpPortScreen(
+// 		        &relay->port,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		subctx->currentRelay++;
+// 		TRACE("current relay %d", subctx->currentRelay);
+
+// 		if (subctx->currentRelay == subctx->numRelays) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_RELAY_DNS_STEP_INVALID);
+// }
+
+// static void _parsePort(ipport_t* port, read_view_t* view)
+// {
+// 	uint8_t isPortGiven = parse_u1be(view);
+// 	if (isPortGiven == ITEM_INCLUDED_YES) {
+// 		port->isNull = false;
+// 		ASSERT_TYPE(port->number, uint16_t);
+// 		port->number = parse_u2be(view);
+// 		TRACE("Port: %u", port->number);
+// 	} else {
+// 		VALIDATE(isPortGiven == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
+// 		port->isNull = true;
+// 	}
+// }
+
+// static void _parseIpv4(ipv4_t* ipv4, read_view_t* view)
+// {
+// 	uint8_t isIpv4Given = parse_u1be(view);
+// 	if (isIpv4Given == ITEM_INCLUDED_YES) {
+// 		ipv4->isNull = false;
+// 		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
+// 		view_parseBuffer(ipv4->ip, view, IPV4_SIZE);
+// 		TRACE("ipv4");
+// 		TRACE_BUFFER(ipv4->ip, IPV4_SIZE);
+// 	} else {
+// 		VALIDATE(isIpv4Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
+// 		ipv4->isNull = true;
+// 	}
+// }
+
+// static void _parseIpv6(ipv6_t* ipv6, read_view_t* view)
+// {
+// 	uint8_t isIpv6Given = parse_u1be(view);
+// 	if (isIpv6Given == ITEM_INCLUDED_YES) {
+// 		ipv6->isNull = false;
+// 		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
+// 		view_parseBuffer(ipv6->ip, view, IPV6_SIZE);
+// 		TRACE("ipv6");
+// 		TRACE_BUFFER(ipv6->ip, IPV6_SIZE);
+// 	} else {
+// 		VALIDATE(isIpv6Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
+// 		ipv6->isNull = true;
+// 	}
+// }
+
+// static void _parseDnsName(pool_relay_t* relay, read_view_t* view)
+// {
+// 	relay->dnsNameSize = view_remainingSize(view);
+// 	VALIDATE(relay->dnsNameSize <= DNS_NAME_SIZE_MAX, ERR_INVALID_DATA);
+// 	VALIDATE(str_isAllowedDnsName(VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)), ERR_INVALID_DATA);
+
+// 	STATIC_ASSERT(SIZEOF(relay->dnsName) == DNS_NAME_SIZE_MAX, "wrong dns name buffer size");
+// 	view_parseBuffer(relay->dnsName, view, relay->dnsNameSize);
+// }
+
+// /*
+// wire data:
+// 1B relay format
+
+// format 0 single_host_addr:
+// 1B + [2B port] + 1B + [4B ipv4] + 1B + [16B ipv6]
+
+// format 1 single_host_name:
+// 1B + [2B port] + [0-64B dns_name]
+
+// format 2 multi_host_name:
+// [0-64B dns_name]
+// */
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleRelayAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_RELAYS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	pool_relay_t* relay = &accessSubcontext()->stateData.relay;
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		relay->format = parse_u1be(&view);
+// 		TRACE("Relay format %u", relay->format);
+// 		switch (relay->format) {
+
+// 		// validation differs from the CDDL spec
+// 		// the CDDL spec allows combinations of parameters that lead
+// 		// to meaningless relays that are ignored by nodes
+// 		// so we only allow meaningful relays
+
+// 		case RELAY_SINGLE_HOST_IP: {
+// 			_parsePort(&relay->port, &view);
+// 			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
+// 			_parseIpv4(&relay->ipv4, &view);
+// 			_parseIpv6(&relay->ipv6, &view);
+// 			VALIDATE(!relay->ipv4.isNull || !relay->ipv6.isNull, ERR_INVALID_DATA);
+// 			break;
+// 		}
+
+// 		case RELAY_SINGLE_HOST_NAME: {
+// 			_parsePort(&relay->port, &view);
+// 			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
+// 			_parseDnsName(relay, &view);
+// 			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
+// 			break;
+// 		}
+
+// 		case RELAY_MULTIPLE_HOST_NAME: {
+// 			_parseDnsName(relay, &view);
+// 			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
+// 			break;
+// 		}
+
+// 		default:
+// 			THROW(ERR_INVALID_DATA);
+// 		}
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationRelay(commonTxData->txSigningMode, relay);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	TRACE("Adding relay format %d to tx hash", (int) relay->format);
+// 	txHashBuilder_addPoolRegistrationCertificate_addRelay(&BODY_CTX->txHashBuilder, relay);
+
+// 	{
+// 		int respondStep = -1;
+// 		int displayStep = -1;
+// 		void (*uiFn)() = NULL;
+
+// 		switch (relay->format) {
+
+// 		case RELAY_SINGLE_HOST_IP: {
+// 			respondStep = HANDLE_RELAY_IP_STEP_RESPOND;
+// 			displayStep = HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER;
+// 			uiFn = handleRelay_ip_ui_runStep;
+// 			break;
+// 		}
+
+// 		case RELAY_SINGLE_HOST_NAME:
+// 		case RELAY_MULTIPLE_HOST_NAME: {
+// 			respondStep = HANDLE_RELAY_DNS_STEP_RESPOND;
+// 			displayStep = HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER;
+// 			uiFn = handleRelay_dns_ui_runStep;
+// 			break;
+// 		}
+
+// 		default:
+// 			THROW(ERR_INVALID_DATA);
+// 		}
+
+// 		ASSERT(respondStep != -1);
+// 		ASSERT(displayStep != -1);
+// 		ASSERT(uiFn != NULL);
+
+// 		// select UI steps and call ui handler
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, respondStep);
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayStep);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+
+// 		uiFn();
+// 	}
+// }
+
+
+// // ============================== METADATA ==============================
+
+// enum {
+// 	HANDLE_NULL_METADATA_STEP_DISPLAY = 6900,
+// 	HANDLE_NULL_METADATA_STEP_RESPOND,
+// 	HANDLE_NULL_METADATA_STEP_INVALID,
+// };
+
+// static void handleNullMetadata_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleNullMetadata_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_NULL_METADATA_STEP_DISPLAY) {
+// 		ui_displayPaginatedText(
+// 		        "No metadata",
+// 		        "(anonymous pool)",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_NULL_METADATA_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_NULL_METADATA_STEP_INVALID);
+// }
+
+// enum {
+// 	HANDLE_METADATA_STEP_DISPLAY_URL = 7000,
+// 	HANDLE_METADATA_STEP_DISPLAY_HASH,
+// 	HANDLE_METADATA_STEP_RESPOND,
+// 	HANDLE_METADATA_STEP_INVALID,
+// };
+
+// static void handleMetadata_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleMetadata_ui_runStep;
+
+// 	pool_metadata_t* md = &subctx->stateData.metadata;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_URL) {
+// 		char metadataUrlStr[1 + POOL_METADATA_URL_LENGTH_MAX] = {0};
+// 		explicit_bzero(metadataUrlStr, SIZEOF(metadataUrlStr));
+// 		ASSERT(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX);
+// 		memmove(metadataUrlStr, md->url, md->urlSize);
+// 		metadataUrlStr[md->urlSize] = '\0';
+// 		ASSERT(strlen(metadataUrlStr) == md->urlSize);
+
+// 		ui_displayPaginatedText(
+// 		        "Pool metadata url",
+// 		        metadataUrlStr,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_HASH) {
+// 		char metadataHashHex[1 + 2 * POOL_METADATA_HASH_LENGTH] = {0};
+// 		explicit_bzero(metadataHashHex, SIZEOF(metadataHashHex));
+// 		size_t len = str_formatMetadata(
+// 		                     md->hash, SIZEOF(md->hash),
+// 		                     metadataHashHex, SIZEOF(metadataHashHex)
+// 		             );
+// 		ASSERT(len + 1 == SIZEOF(metadataHashHex));
+
+// 		ui_displayPaginatedText(
+// 		        "Pool metadata hash",
+// 		        metadataHashHex,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_METADATA_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_METADATA_STEP_INVALID);
+// }
+
+// static void handleNullMetadata()
+// {
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationNoMetadata();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// add null metadata to certificate
+// 		TRACE("Adding null pool metadata to tx hash");
+// 		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(&BODY_CTX->txHashBuilder);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NULL_METADATA_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NULL_METADATA_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handleNullMetadata_ui_runStep();
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handlePoolMetadataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_METADATA);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	explicit_bzero(&subctx->stateData.metadata, SIZEOF(subctx->stateData.metadata));
+
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		pool_metadata_t* md = &subctx->stateData.metadata;
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		{
+// 			// deal with null metadata
+// 			uint8_t includeMetadataByte = parse_u1be(&view);
+// 			int includeMetadata = signTx_parseIncluded(includeMetadataByte);
+
+// 			if (!includeMetadata) {
+// 				VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 				handleNullMetadata();
+// 				return;
+// 			}
+// 		}
+// 		{
+// 			STATIC_ASSERT(SIZEOF(md->hash) == POOL_METADATA_HASH_LENGTH, "wrong pool metadata buffer size");
+// 			view_parseBuffer(md->hash, &view, POOL_METADATA_HASH_LENGTH);
+// 		}
+// 		{
+// 			md->urlSize = view_remainingSize(&view);
+// 			VALIDATE(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX, ERR_INVALID_DATA);
+// 			STATIC_ASSERT(SIZEOF(md->url) >= POOL_METADATA_URL_LENGTH_MAX, "wrong pool metada url size");
+// 			view_parseBuffer(md->url, &view, md->urlSize);
+
+// 			// whitespace not allowed
+// 			VALIDATE(str_isPrintableAsciiWithoutSpaces(md->url, md->urlSize), ERR_INVALID_DATA);
+// 		}
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationMetadata();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// add metadata to tx
+// 		TRACE("Adding metadata hash to tx hash");
+// 		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.metadata.url, subctx->stateData.metadata.urlSize,
+// 		        subctx->stateData.metadata.hash, SIZEOF(subctx->stateData.metadata.hash)
+// 		);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_METADATA_STEP_DISPLAY_URL);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_METADATA_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handleMetadata_ui_runStep();
+// }
+
+// // ============================== CONFIRM ==============================
+
+// enum {
+// 	HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS = 7100,
+// 	HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS,
+// 	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
+// 	HANDLE_CONFIRM_STEP_RESPOND,
+// 	HANDLE_CONFIRM_STEP_INVALID,
+// };
+
+// static void signTxPoolRegistration_handleConfirm_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxPoolRegistration_handleConfirm_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	// we display potencially suspicious facts about the certificate
+// 	// that have not been explicitly shown to the user before:
+// 	// missing owners or relays
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS) {
+// 		if (subctx->numOwners == 0) {
+// 			ui_displayPaginatedText(
+// 			        "No",
+// 			        "pool owners",
+// 			        this_fn
+// 			);
+// 		} else {
+// 			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS);
+// 		}
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS) {
+// 		bool isOperator = commonTxData->txSigningMode == SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR;
+// 		if ((subctx->numRelays == 0) && isOperator) {
+// 			ui_displayPaginatedText(
+// 			        "No",
+// 			        "pool relays",
+// 			        this_fn
+// 			);
+// 		} else {
+// 			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
+// 		}
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm stake",
+// 		        "pool registration?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		//sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_CONFIRM);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	{
+// 		// no data to receive
+// 		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationConfirm(subctx->numOwners, subctx->numRelays);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxPoolRegistration_handleConfirm_ui_runStep();
+// }
+
+
+// // ============================== main APDU handler ==============================
+
+// enum {
+// 	APDU_INSTRUCTION_INIT = 0x30,
+// 	APDU_INSTRUCTION_POOL_KEY = 0x31,
+// 	APDU_INSTRUCTION_VRF_KEY = 0x32,
+// 	APDU_INSTRUCTION_FINANCIALS = 0x33,
+// 	APDU_INSTRUCTION_REWARD_ACCOUNT = 0x34,
+// 	APDU_INSTRUCTION_OWNERS = 0x35,
+// 	APDU_INSTRUCTION_RELAYS = 0x36,
+// 	APDU_INSTRUCTION_METADATA = 0x37,
+// 	APDU_INSTRUCTION_CONFIRMATION = 0x38
+// };
+
+// bool signTxPoolRegistration_isValidInstruction(uint8_t p2)
+// {
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_INIT:
+// 	case APDU_INSTRUCTION_POOL_KEY:
+// 	case APDU_INSTRUCTION_VRF_KEY:
+// 	case APDU_INSTRUCTION_FINANCIALS:
+// 	case APDU_INSTRUCTION_REWARD_ACCOUNT:
+// 	case APDU_INSTRUCTION_OWNERS:
+// 	case APDU_INSTRUCTION_RELAYS:
+// 	case APDU_INSTRUCTION_METADATA:
+// 	case APDU_INSTRUCTION_CONFIRMATION:
+// 		return true;
+
+// 	default:
+// 		return false;
+// 	}
+// }
+
+// void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	TRACE("p2 = 0x%x", p2);
+// 	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_INIT:
+// 		signTxPoolRegistration_handleInitAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_POOL_KEY:
+// 		signTxPoolRegistration_handlePoolKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_VRF_KEY:
+// 		signTxPoolRegistration_handleVrfKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_FINANCIALS:
+// 		signTxPoolRegistration_handlePoolFinancialsAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_REWARD_ACCOUNT:
+// 		signTxPoolRegistration_handleRewardAccountAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_OWNERS:
+// 		signTxPoolRegistration_handleOwnerAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_RELAYS:
+// 		signTxPoolRegistration_handleRelayAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_METADATA:
+// 		signTxPoolRegistration_handlePoolMetadataAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_CONFIRMATION:
+// 		signTxPoolRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	default:
+// 		// this is not supposed to be called with invalid p2
+// 		ASSERT(false);
+// 	}
+// }
diff --git a/src/signTxPoolRegistration.h b/src/signTxPoolRegistration.h
index 21eb19c..7323d90 100644
--- a/src/signTxPoolRegistration.h
+++ b/src/signTxPoolRegistration.h
@@ -1,86 +1,86 @@
-#ifndef H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
-#define H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
-
-#include "common.h"
-#include "cardano.h"
-#include "txHashBuilder.h"
-
-#define POOL_MAX_OWNERS 1000
-#define POOL_MAX_RELAYS 1000
-
-// SIGN_STAGE_BODY_CERTIFICATES = 28
-// CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION = 3
-typedef enum {
-	STAKE_POOL_REGISTRATION_INIT = 2830,
-	STAKE_POOL_REGISTRATION_POOL_KEY = 2831,
-	STAKE_POOL_REGISTRATION_VRF_KEY = 2832,
-	STAKE_POOL_REGISTRATION_FINANCIALS = 2833,
-	STAKE_POOL_REGISTRATION_REWARD_ACCOUNT = 2834,
-	STAKE_POOL_REGISTRATION_OWNERS = 2835,
-	STAKE_POOL_REGISTRATION_RELAYS = 2836,
-	STAKE_POOL_REGISTRATION_METADATA = 2837,
-	STAKE_POOL_REGISTRATION_CONFIRM = 2838,
-	STAKE_POOL_REGISTRATION_FINISHED = 2839,
-} sign_tx_pool_registration_state_t;
-
-typedef struct {
-	key_reference_type_t keyReferenceType;
-	union {
-		bip44_path_t path;
-		uint8_t hash[POOL_KEY_HASH_LENGTH];
-	};
-} pool_id_t;
-
-typedef struct {
-	key_reference_type_t keyReferenceType;
-	union {
-		bip44_path_t path;
-		uint8_t keyHash[ADDRESS_KEY_HASH_LENGTH];
-	};
-} pool_owner_t;
-
-typedef struct {
-	uint8_t url[POOL_METADATA_URL_LENGTH_MAX];
-	size_t urlSize;
-	uint8_t hash[POOL_METADATA_HASH_LENGTH];
-} pool_metadata_t;
-
-
-typedef struct {
-	sign_tx_pool_registration_state_t state;
-
-	int ui_step;
-
-	uint16_t currentOwner;
-	uint16_t numOwnersGivenByPath;
-	uint16_t currentRelay;
-
-	uint16_t numOwners;
-	uint16_t numRelays;
-
-	// this holds data valid only through the processing of a single APDU
-	union {
-		pool_id_t poolId;
-		uint8_t vrfKeyHash[VRF_KEY_HASH_LENGTH];
-		struct {
-			uint64_t pledge;
-			uint64_t cost;
-			uint64_t marginNumerator;
-			uint64_t marginDenominator;
-		};
-		reward_account_t poolRewardAccount;
-		pool_owner_t owner;
-		pool_relay_t relay;
-		pool_metadata_t metadata;
-	} stateData;
-} pool_registration_context_t;
-
-
-void signTxPoolRegistration_init();
-
-bool signTxPoolRegistration_isValidInstruction(uint8_t p2);
-void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
-
-bool signTxPoolRegistration_isFinished();
-
-#endif // H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
+// #ifndef H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
+// #define H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
+
+// #include "common.h"
+// #include "cardano.h"
+// #include "txHashBuilder.h"
+
+// #define POOL_MAX_OWNERS 1000
+// #define POOL_MAX_RELAYS 1000
+
+// // SIGN_STAGE_BODY_CERTIFICATES = 28
+// // CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION = 3
+// typedef enum {
+// 	STAKE_POOL_REGISTRATION_INIT = 2830,
+// 	STAKE_POOL_REGISTRATION_POOL_KEY = 2831,
+// 	STAKE_POOL_REGISTRATION_VRF_KEY = 2832,
+// 	STAKE_POOL_REGISTRATION_FINANCIALS = 2833,
+// 	STAKE_POOL_REGISTRATION_REWARD_ACCOUNT = 2834,
+// 	STAKE_POOL_REGISTRATION_OWNERS = 2835,
+// 	STAKE_POOL_REGISTRATION_RELAYS = 2836,
+// 	STAKE_POOL_REGISTRATION_METADATA = 2837,
+// 	STAKE_POOL_REGISTRATION_CONFIRM = 2838,
+// 	STAKE_POOL_REGISTRATION_FINISHED = 2839,
+// } sign_tx_pool_registration_state_t;
+
+// typedef struct {
+// 	key_reference_type_t keyReferenceType;
+// 	union {
+// 		bip44_path_t path;
+// 		uint8_t hash[POOL_KEY_HASH_LENGTH];
+// 	};
+// } pool_id_t;
+
+// typedef struct {
+// 	key_reference_type_t keyReferenceType;
+// 	union {
+// 		bip44_path_t path;
+// 		uint8_t keyHash[ADDRESS_KEY_HASH_LENGTH];
+// 	};
+// } pool_owner_t;
+
+// typedef struct {
+// 	uint8_t url[POOL_METADATA_URL_LENGTH_MAX];
+// 	size_t urlSize;
+// 	uint8_t hash[POOL_METADATA_HASH_LENGTH];
+// } pool_metadata_t;
+
+
+// typedef struct {
+// 	sign_tx_pool_registration_state_t state;
+
+// 	int ui_step;
+
+// 	uint16_t currentOwner;
+// 	uint16_t numOwnersGivenByPath;
+// 	uint16_t currentRelay;
+
+// 	uint16_t numOwners;
+// 	uint16_t numRelays;
+
+// 	// this holds data valid only through the processing of a single APDU
+// 	union {
+// 		pool_id_t poolId;
+// 		uint8_t vrfKeyHash[VRF_KEY_HASH_LENGTH];
+// 		struct {
+// 			uint64_t pledge;
+// 			uint64_t cost;
+// 			uint64_t marginNumerator;
+// 			uint64_t marginDenominator;
+// 		};
+// 		reward_account_t poolRewardAccount;
+// 		pool_owner_t owner;
+// 		pool_relay_t relay;
+// 		pool_metadata_t metadata;
+// 	} stateData;
+// } pool_registration_context_t;
+
+
+// void signTxPoolRegistration_init();
+
+// bool signTxPoolRegistration_isValidInstruction(uint8_t p2);
+// void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
+
+// bool signTxPoolRegistration_isFinished();
+
+// #endif // H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
diff --git a/src/state.h b/src/state.h
index 8549086..829112d 100644
--- a/src/state.h
+++ b/src/state.h
@@ -4,18 +4,18 @@
 #include "getVersion.h"
 #include "getPublicKeys.h"
 #include "deriveAddress.h"
-#include "deriveNativeScriptHash.h"
+// #include "deriveNativeScriptHash.h"
 #include "signTx.h"
-#include "signOpCert.h"
+// #include "signOpCert.h"
 
 
 typedef union {
 	// Here should go states of all instructions
 	ins_get_keys_context_t getKeysContext;
 	ins_derive_address_context_t deriveAddressContext;
-	ins_derive_native_script_hash_context_t deriveNativeScriptHashContext;
+	// ins_derive_native_script_hash_context_t deriveNativeScriptHashContext;
 	ins_sign_tx_context_t signTxContext;
-	ins_sign_op_cert_context_t signOpCertContext;
+	// ins_sign_op_cert_context_t signOpCertContext;
 } instructionState_t;
 
 // Note(instructions are uint8_t but we have a special INS_NONE value
diff --git a/src/txHashBuilder.c b/src/txHashBuilder.c
index 9749fb5..7ba4796 100644
--- a/src/txHashBuilder.c
+++ b/src/txHashBuilder.c
@@ -112,8 +112,8 @@ void txHashBuilder_init(
 		builder->includeValidityIntervalStart = includeValidityIntervalStart;
 		if (includeValidityIntervalStart) numItems++;
 
-		builder->includeMint = includeMint;
-		if (includeMint) numItems++;
+		// builder->includeMint = includeMint;
+		// if (includeMint) numItems++;
 
 		builder->includeScriptDataHash = includeScriptDataHash;
 		if (includeScriptDataHash) numItems++;
@@ -460,8 +460,8 @@ void txHashBuilder_enterCertificates(tx_hash_builder_t* builder)
 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->remainingCertificates);
 	}
 
-	builder->poolCertificateData.remainingOwners = 0;
-	builder->poolCertificateData.remainingRelays = 0;
+	// builder->poolCertificateData.remainingOwners = 0;
+	// builder->poolCertificateData.remainingRelays = 0;
 
 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
 }
@@ -574,432 +574,432 @@ void txHashBuilder_addCertificate_delegation(
 	}
 }
 
-void txHashBuilder_addCertificate_poolRetirement(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize,
-        uint64_t epoch
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
-	ASSERT(builder->remainingCertificates > 0);
-	builder->remainingCertificates--;
-
-	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
-
-	// Array(3)[
-	//   Unsigned[4]
-	//   Bytes[poolKeyHash]
-	//   Unsigned[epoch]
-	// ]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 4);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
-			BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
-		}
-		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, epoch);
-	}
-}
-
-void txHashBuilder_poolRegistrationCertificate_enter(
-        tx_hash_builder_t* builder,
-        uint16_t numOwners, uint16_t numRelays
-)
-{
-	_TRACE("state = %d, remainingCertificates = %u", builder->state, builder->remainingCertificates);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
-	ASSERT(builder->remainingCertificates > 0);
-	builder->remainingCertificates--;
-
-	ASSERT(builder->poolCertificateData.remainingOwners == 0);
-	builder->poolCertificateData.remainingOwners = numOwners;
-	ASSERT(builder->poolCertificateData.remainingRelays == 0);
-	builder->poolCertificateData.remainingRelays = numRelays;
-
-	// Array(10)[
-	//   Unsigned[3]
-
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 10);
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 3);
-		}
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT;
-}
-
-void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT);
-
-	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
-
-	//   Bytes[pool_keyhash]          // also called operator in CDDL specs and pool id in user interfaces
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
-		BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH;
-}
-
-void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* vrfKeyHash, size_t vrfKeyHashSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH);
-
-	ASSERT(vrfKeyHashSize == VRF_KEY_HASH_LENGTH);
-
-	//   Bytes[vrf_keyhash]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, vrfKeyHashSize);
-		BUILDER_APPEND_DATA(vrfKeyHash, vrfKeyHashSize);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF;
-}
-
-void txHashBuilder_poolRegistrationCertificate_financials(
-        tx_hash_builder_t* builder,
-        uint64_t pledge, uint64_t cost,
-        uint64_t marginNumerator, uint64_t marginDenominator
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF);
-
-	//   Unsigned[pledge]
-	//   Unsigned[cost]
-	//   Tag(30) Array(2)[
-	//     Unsigned[marginDenominator]
-	//     Unsigned[marginNumerator]
-	//   ]
-	{
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, pledge);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, cost);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_TAG, 30);
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginNumerator);
-			}
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginDenominator);
-			}
-		}
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS;
-}
-
-void txHashBuilder_poolRegistrationCertificate_rewardAccount(
-        tx_hash_builder_t* builder,
-        uint8_t* rewardAccount, size_t rewardAccountSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS);
-
-	ASSERT(rewardAccountSize == REWARD_ACCOUNT_SIZE);
-
-	//   Bytes[rewardAccount]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, rewardAccountSize);
-		BUILDER_APPEND_DATA(rewardAccount, rewardAccountSize);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT);
-
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingOwners);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addOwner(
-        tx_hash_builder_t* builder,
-        const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
-)
-{
-	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
-	ASSERT(builder->poolCertificateData.remainingOwners > 0);
-	builder->poolCertificateData.remainingOwners--;
-
-	ASSERT(stakingKeyHashSize == ADDRESS_KEY_HASH_LENGTH);
-
-	// Bytes[poolKeyHash]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, stakingKeyHashSize);
-		BUILDER_APPEND_DATA(stakingKeyHash, stakingKeyHashSize);
-	}
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
-
-	// enter empty owners if none were received (and none were expected)
-	if (builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT) {
-		ASSERT(builder->poolCertificateData.remainingOwners == 0);
-		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
-	}
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
-	ASSERT(builder->poolCertificateData.remainingOwners == 0);
-
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingRelays);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS;
-}
-
-static void _relay_addPort(tx_hash_builder_t* builder, ipport_t* port)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	//   Unsigned[port] / Null
-	if (port->isNull) {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	} else {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, port->number);
-	}
-}
-
-static void _relay_addIpv4(tx_hash_builder_t* builder, ipv4_t* ipv4)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	//   Bytes[ipv4] / Null
-	if (ipv4->isNull) {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	} else {
-		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV4_SIZE);
-		BUILDER_APPEND_DATA(ipv4->ip, IPV4_SIZE);
-	}
-}
-
-static void _relay_addIpv6(tx_hash_builder_t* builder, const ipv6_t* ipv6)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	//   Bytes[ipv6] / Null
-	if (ipv6->isNull) {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	} else {
-		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV6_SIZE);
-
-		// serialized as 4 big-endian uint32
-		// we need a local copy of the data to make the following pointer tricks work
-		// the copy is created by memmove instead of struct assignment to avoid compiler optimizing it away
-		uint8_t ipBuffer[IPV6_SIZE] = {0};
-		memmove(ipBuffer, ipv6->ip, SIZEOF(ipBuffer));
-		STATIC_ASSERT(SIZEOF(ipBuffer) == 16, "wrong ipv6 size");
-
-		uint32_t* as_uint32 = (uint32_t*) ipBuffer;
-		for (size_t i = 0; i < 4; i++) {
-			uint8_t chunk[4] = {0};
-			u4be_write(chunk, as_uint32[i]);
-			BUILDER_APPEND_DATA(chunk, 4);
-		}
-	}
-}
-
-static void _relay_addDnsName(tx_hash_builder_t* builder, pool_relay_t* relay)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
-
-	//   Text[dnsName]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, relay->dnsNameSize);
-		BUILDER_APPEND_DATA(relay->dnsName, relay->dnsNameSize);
-	}
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addRelay(
-        tx_hash_builder_t* builder,
-        pool_relay_t* relay
-)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-	ASSERT(builder->poolCertificateData.remainingRelays > 0);
-	builder->poolCertificateData.remainingRelays--;
-
-	switch (relay->format) {
-	case RELAY_SINGLE_HOST_IP: {
-		// Array(4)[
-		//   Unsigned[0]
-		//   Unsigned[port] / Null
-		//   Bytes[ipv4] / Null
-		//   Bytes[ipv6] / Null
-		// ]
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 4);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 0);
-			}
-			_relay_addPort(builder, &relay->port);
-			_relay_addIpv4(builder, &relay->ipv4);
-			_relay_addIpv6(builder, &relay->ipv6);
-		}
-		break;
-	}
-	case RELAY_SINGLE_HOST_NAME: {
-		// Array(3)[
-		//   Unsigned[1]
-		//   Unsigned[port] / Null
-		//   Text[dnsName]
-		// ]
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 1);
-			}
-			_relay_addPort(builder, &relay->port);
-			_relay_addDnsName(builder, relay);
-		}
-		break;
-	}
-	case RELAY_MULTIPLE_HOST_NAME: {
-		// Array(2)[
-		//   Unsigned[2]
-		//   Text[dnsName]
-		// ]
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 2);
-			}
-			_relay_addDnsName(builder, relay);
-		}
-		break;
-	}
-	default:
-		ASSERT(false);
-	}
-}
-
-// enter empty owners or relays if none were received
-static void addPoolMetadata_updateState(tx_hash_builder_t* builder)
-{
-	switch (builder->state) {
-	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT:
-		// skipping owners is only possible if none were expected
-		ASSERT(builder->poolCertificateData.remainingOwners == 0);
-		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
-
-	// intentional fallthrough
-
-	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS:
-		// skipping relays is only possible if none were expected
-		ASSERT(builder->poolCertificateData.remainingRelays == 0);
-		txHashBuilder_addPoolRegistrationCertificate_enterRelays(builder);
-
-	// intentional fallthrough
-
-	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS:
-		// all relays should have been received
-		ASSERT(builder->poolCertificateData.remainingRelays == 0);
-		break; // we want to be here
-
-	default:
-		ASSERT(false);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
-        tx_hash_builder_t* builder,
-        const uint8_t* url, size_t urlSize,
-        const uint8_t* metadataHash, size_t metadataHashSize
-)
-{
-	_TRACE("state = %d", builder->state);
-	ASSERT(metadataHashSize == POOL_METADATA_HASH_LENGTH);
-
-	// we allow this to be called immediately after pool params have been added
-	// if there are no owners or relays in the tx
-	addPoolMetadata_updateState(builder);
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
-
-	// Array(2)[
-	//   Tstr[url]
-	//   Bytes[metadataHash]
-	// ]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, urlSize);
-			BUILDER_APPEND_DATA(url, urlSize);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, metadataHashSize);
-			BUILDER_APPEND_DATA(metadataHash, metadataHashSize);
-		}
-	}
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
-        tx_hash_builder_t* builder
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	addPoolMetadata_updateState(builder);
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	}
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
-}
+// void txHashBuilder_addCertificate_poolRetirement(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize,
+//         uint64_t epoch
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
+// 	ASSERT(builder->remainingCertificates > 0);
+// 	builder->remainingCertificates--;
+
+// 	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
+
+// 	// Array(3)[
+// 	//   Unsigned[4]
+// 	//   Bytes[poolKeyHash]
+// 	//   Unsigned[epoch]
+// 	// ]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 4);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
+// 			BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
+// 		}
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, epoch);
+// 	}
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_enter(
+//         tx_hash_builder_t* builder,
+//         uint16_t numOwners, uint16_t numRelays
+// )
+// {
+// 	_TRACE("state = %d, remainingCertificates = %u", builder->state, builder->remainingCertificates);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
+// 	ASSERT(builder->remainingCertificates > 0);
+// 	builder->remainingCertificates--;
+
+// 	ASSERT(builder->poolCertificateData.remainingOwners == 0);
+// 	builder->poolCertificateData.remainingOwners = numOwners;
+// 	ASSERT(builder->poolCertificateData.remainingRelays == 0);
+// 	builder->poolCertificateData.remainingRelays = numRelays;
+
+// 	// Array(10)[
+// 	//   Unsigned[3]
+
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 10);
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 3);
+// 		}
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT);
+
+// 	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
+
+// 	//   Bytes[pool_keyhash]          // also called operator in CDDL specs and pool id in user interfaces
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
+// 		BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* vrfKeyHash, size_t vrfKeyHashSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH);
+
+// 	ASSERT(vrfKeyHashSize == VRF_KEY_HASH_LENGTH);
+
+// 	//   Bytes[vrf_keyhash]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, vrfKeyHashSize);
+// 		BUILDER_APPEND_DATA(vrfKeyHash, vrfKeyHashSize);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_financials(
+//         tx_hash_builder_t* builder,
+//         uint64_t pledge, uint64_t cost,
+//         uint64_t marginNumerator, uint64_t marginDenominator
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF);
+
+// 	//   Unsigned[pledge]
+// 	//   Unsigned[cost]
+// 	//   Tag(30) Array(2)[
+// 	//     Unsigned[marginDenominator]
+// 	//     Unsigned[marginNumerator]
+// 	//   ]
+// 	{
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, pledge);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, cost);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_TAG, 30);
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginNumerator);
+// 			}
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginDenominator);
+// 			}
+// 		}
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_rewardAccount(
+//         tx_hash_builder_t* builder,
+//         uint8_t* rewardAccount, size_t rewardAccountSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS);
+
+// 	ASSERT(rewardAccountSize == REWARD_ACCOUNT_SIZE);
+
+// 	//   Bytes[rewardAccount]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, rewardAccountSize);
+// 		BUILDER_APPEND_DATA(rewardAccount, rewardAccountSize);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT);
+
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingOwners);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addOwner(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
+// )
+// {
+// 	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
+// 	ASSERT(builder->poolCertificateData.remainingOwners > 0);
+// 	builder->poolCertificateData.remainingOwners--;
+
+// 	ASSERT(stakingKeyHashSize == ADDRESS_KEY_HASH_LENGTH);
+
+// 	// Bytes[poolKeyHash]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, stakingKeyHashSize);
+// 		BUILDER_APPEND_DATA(stakingKeyHash, stakingKeyHashSize);
+// 	}
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
+
+// 	// enter empty owners if none were received (and none were expected)
+// 	if (builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT) {
+// 		ASSERT(builder->poolCertificateData.remainingOwners == 0);
+// 		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
+// 	}
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
+// 	ASSERT(builder->poolCertificateData.remainingOwners == 0);
+
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingRelays);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS;
+// }
+
+// static void _relay_addPort(tx_hash_builder_t* builder, ipport_t* port)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	//   Unsigned[port] / Null
+// 	if (port->isNull) {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	} else {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, port->number);
+// 	}
+// }
+
+// static void _relay_addIpv4(tx_hash_builder_t* builder, ipv4_t* ipv4)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	//   Bytes[ipv4] / Null
+// 	if (ipv4->isNull) {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	} else {
+// 		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV4_SIZE);
+// 		BUILDER_APPEND_DATA(ipv4->ip, IPV4_SIZE);
+// 	}
+// }
+
+// static void _relay_addIpv6(tx_hash_builder_t* builder, const ipv6_t* ipv6)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	//   Bytes[ipv6] / Null
+// 	if (ipv6->isNull) {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	} else {
+// 		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV6_SIZE);
+
+// 		// serialized as 4 big-endian uint32
+// 		// we need a local copy of the data to make the following pointer tricks work
+// 		// the copy is created by memmove instead of struct assignment to avoid compiler optimizing it away
+// 		uint8_t ipBuffer[IPV6_SIZE] = {0};
+// 		memmove(ipBuffer, ipv6->ip, SIZEOF(ipBuffer));
+// 		STATIC_ASSERT(SIZEOF(ipBuffer) == 16, "wrong ipv6 size");
+
+// 		uint32_t* as_uint32 = (uint32_t*) ipBuffer;
+// 		for (size_t i = 0; i < 4; i++) {
+// 			uint8_t chunk[4] = {0};
+// 			u4be_write(chunk, as_uint32[i]);
+// 			BUILDER_APPEND_DATA(chunk, 4);
+// 		}
+// 	}
+// }
+
+// static void _relay_addDnsName(tx_hash_builder_t* builder, pool_relay_t* relay)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
+
+// 	//   Text[dnsName]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, relay->dnsNameSize);
+// 		BUILDER_APPEND_DATA(relay->dnsName, relay->dnsNameSize);
+// 	}
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addRelay(
+//         tx_hash_builder_t* builder,
+//         pool_relay_t* relay
+// )
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+// 	ASSERT(builder->poolCertificateData.remainingRelays > 0);
+// 	builder->poolCertificateData.remainingRelays--;
+
+// 	switch (relay->format) {
+// 	case RELAY_SINGLE_HOST_IP: {
+// 		// Array(4)[
+// 		//   Unsigned[0]
+// 		//   Unsigned[port] / Null
+// 		//   Bytes[ipv4] / Null
+// 		//   Bytes[ipv6] / Null
+// 		// ]
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 4);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 0);
+// 			}
+// 			_relay_addPort(builder, &relay->port);
+// 			_relay_addIpv4(builder, &relay->ipv4);
+// 			_relay_addIpv6(builder, &relay->ipv6);
+// 		}
+// 		break;
+// 	}
+// 	case RELAY_SINGLE_HOST_NAME: {
+// 		// Array(3)[
+// 		//   Unsigned[1]
+// 		//   Unsigned[port] / Null
+// 		//   Text[dnsName]
+// 		// ]
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 1);
+// 			}
+// 			_relay_addPort(builder, &relay->port);
+// 			_relay_addDnsName(builder, relay);
+// 		}
+// 		break;
+// 	}
+// 	case RELAY_MULTIPLE_HOST_NAME: {
+// 		// Array(2)[
+// 		//   Unsigned[2]
+// 		//   Text[dnsName]
+// 		// ]
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 2);
+// 			}
+// 			_relay_addDnsName(builder, relay);
+// 		}
+// 		break;
+// 	}
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// // enter empty owners or relays if none were received
+// static void addPoolMetadata_updateState(tx_hash_builder_t* builder)
+// {
+// 	switch (builder->state) {
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT:
+// 		// skipping owners is only possible if none were expected
+// 		ASSERT(builder->poolCertificateData.remainingOwners == 0);
+// 		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
+
+// 	// intentional fallthrough
+
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS:
+// 		// skipping relays is only possible if none were expected
+// 		ASSERT(builder->poolCertificateData.remainingRelays == 0);
+// 		txHashBuilder_addPoolRegistrationCertificate_enterRelays(builder);
+
+// 	// intentional fallthrough
+
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS:
+// 		// all relays should have been received
+// 		ASSERT(builder->poolCertificateData.remainingRelays == 0);
+// 		break; // we want to be here
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* url, size_t urlSize,
+//         const uint8_t* metadataHash, size_t metadataHashSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+// 	ASSERT(metadataHashSize == POOL_METADATA_HASH_LENGTH);
+
+// 	// we allow this to be called immediately after pool params have been added
+// 	// if there are no owners or relays in the tx
+// 	addPoolMetadata_updateState(builder);
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
+
+// 	// Array(2)[
+// 	//   Tstr[url]
+// 	//   Bytes[metadataHash]
+// 	// ]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, urlSize);
+// 			BUILDER_APPEND_DATA(url, urlSize);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, metadataHashSize);
+// 			BUILDER_APPEND_DATA(metadataHash, metadataHashSize);
+// 		}
+// 	}
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
+//         tx_hash_builder_t* builder
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	addPoolMetadata_updateState(builder);
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	}
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
+// }
 
 static void txHashBuilder_assertCanLeaveCertificates(tx_hash_builder_t* builder)
 {
@@ -1160,89 +1160,89 @@ static void txHashBuilder_assertCanLeaveValidityIntervalStart(tx_hash_builder_t*
 	}
 }
 
-void txHashBuilder_enterMint(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
-	ASSERT(builder->includeMint);
-
-	{
-		// Enter mint
-		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, TX_BODY_KEY_MINT);
-	}
-	builder->state = TX_HASH_BUILDER_IN_MINT;
-}
-
-void txHashBuilder_addMint_topLevelData(
-        tx_hash_builder_t* builder, uint16_t numAssetGroups
-)
-{
-	_TRACE("state = %u", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_MINT);
-
-	builder->multiassetData.remainingAssetGroups = numAssetGroups;
-	// Map(numAssetGroups)[
-	//   { * policy_id => { * asset_name => uint } }
-	// ]
-	BUILDER_APPEND_CBOR(CBOR_TYPE_MAP, numAssetGroups);
-	ASSERT(numAssetGroups > 0);
-	builder->state = TX_HASH_BUILDER_IN_MINT_ASSET_GROUP;
-}
-
-void txHashBuilder_addMint_tokenGroup(
-        tx_hash_builder_t* builder,
-        const uint8_t* policyIdBuffer, size_t policyIdSize,
-        uint16_t numTokens
-)
-{
-	ASSERT(policyIdSize == MINTING_POLICY_ID_SIZE);
-
-	addTokenGroup(builder, policyIdBuffer, policyIdSize, numTokens,
-	              TX_HASH_BUILDER_IN_MINT_ASSET_GROUP, TX_HASH_BUILDER_IN_MINT_TOKEN);
-}
-
-void txHashBuilder_addMint_token(
-        tx_hash_builder_t* builder,
-        const uint8_t* assetNameBuffer, size_t assetNameSize,
-        int64_t amount
-)
-{
-	ASSERT(assetNameSize <= ASSET_NAME_SIZE_MAX);
-
-	addToken(builder, assetNameBuffer, assetNameSize, amount,
-	         TX_HASH_BUILDER_IN_MINT_TOKEN,
-	         TX_HASH_BUILDER_IN_MINT_ASSET_GROUP,
-	         TX_HASH_BUILDER_IN_MINT,
-	         amount < 0 ? CBOR_TYPE_NEGATIVE : CBOR_TYPE_UNSIGNED);
-}
-
-static void txHashBuilder_assertCanLeaveMint(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %u, remainingMintAssetGroups = %u, remainingMintTokens = %u",
-	       builder->state, builder->multiassetData.remainingAssetGroups, builder->multiassetData.remainingTokens);
-
-	switch (builder->state) {
-	case TX_HASH_BUILDER_IN_MINT:
-		ASSERT(builder->multiassetData.remainingAssetGroups == 0);
-		ASSERT(builder->multiassetData.remainingTokens == 0);
-		break;
-
-	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
-	case TX_HASH_BUILDER_IN_AUX_DATA:
-	case TX_HASH_BUILDER_IN_WITHDRAWALS:
-	case TX_HASH_BUILDER_IN_CERTIFICATES:
-	case TX_HASH_BUILDER_IN_TTL:
-	case TX_HASH_BUILDER_IN_FEE:
-		txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
-		ASSERT(!builder->includeMint);
-		break;
-
-	default:
-		ASSERT(false);
-	}
-}
+// void txHashBuilder_enterMint(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
+// 	ASSERT(builder->includeMint);
+
+// 	{
+// 		// Enter mint
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, TX_BODY_KEY_MINT);
+// 	}
+// 	builder->state = TX_HASH_BUILDER_IN_MINT;
+// }
+
+// void txHashBuilder_addMint_topLevelData(
+//         tx_hash_builder_t* builder, uint16_t numAssetGroups
+// )
+// {
+// 	_TRACE("state = %u", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_MINT);
+
+// 	builder->multiassetData.remainingAssetGroups = numAssetGroups;
+// 	// Map(numAssetGroups)[
+// 	//   { * policy_id => { * asset_name => uint } }
+// 	// ]
+// 	BUILDER_APPEND_CBOR(CBOR_TYPE_MAP, numAssetGroups);
+// 	ASSERT(numAssetGroups > 0);
+// 	builder->state = TX_HASH_BUILDER_IN_MINT_ASSET_GROUP;
+// }
+
+// void txHashBuilder_addMint_tokenGroup(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* policyIdBuffer, size_t policyIdSize,
+//         uint16_t numTokens
+// )
+// {
+// 	ASSERT(policyIdSize == MINTING_POLICY_ID_SIZE);
+
+// 	addTokenGroup(builder, policyIdBuffer, policyIdSize, numTokens,
+// 	              TX_HASH_BUILDER_IN_MINT_ASSET_GROUP, TX_HASH_BUILDER_IN_MINT_TOKEN);
+// }
+
+// void txHashBuilder_addMint_token(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* assetNameBuffer, size_t assetNameSize,
+//         int64_t amount
+// )
+// {
+// 	ASSERT(assetNameSize <= ASSET_NAME_SIZE_MAX);
+
+// 	addToken(builder, assetNameBuffer, assetNameSize, amount,
+// 	         TX_HASH_BUILDER_IN_MINT_TOKEN,
+// 	         TX_HASH_BUILDER_IN_MINT_ASSET_GROUP,
+// 	         TX_HASH_BUILDER_IN_MINT,
+// 	         amount < 0 ? CBOR_TYPE_NEGATIVE : CBOR_TYPE_UNSIGNED);
+// }
+
+// static void txHashBuilder_assertCanLeaveMint(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %u, remainingMintAssetGroups = %u, remainingMintTokens = %u",
+// 	       builder->state, builder->multiassetData.remainingAssetGroups, builder->multiassetData.remainingTokens);
+
+// 	switch (builder->state) {
+// 	// case TX_HASH_BUILDER_IN_MINT:
+// 	// 	ASSERT(builder->multiassetData.remainingAssetGroups == 0);
+// 	// 	ASSERT(builder->multiassetData.remainingTokens == 0);
+// 	// 	break;
+
+// 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
+// 	case TX_HASH_BUILDER_IN_AUX_DATA:
+// 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES:
+// 	case TX_HASH_BUILDER_IN_TTL:
+// 	case TX_HASH_BUILDER_IN_FEE:
+// 		txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
+// 		ASSERT(!builder->includeMint);
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
 
 void txHashBuilder_addScriptDataHash(
         tx_hash_builder_t* builder,
@@ -1252,7 +1252,7 @@ void txHashBuilder_addScriptDataHash(
 	_TRACE("state = %d", builder->state);
 
 	ASSERT(scriptHashDataSize == SCRIPT_DATA_HASH_LENGTH);
-	txHashBuilder_assertCanLeaveMint(builder);
+	txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
 	ASSERT(builder->includeScriptDataHash);
 
 	{
@@ -1271,14 +1271,14 @@ static void txHashBuilder_assertCanLeaveScriptDataHash(tx_hash_builder_t* builde
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
 		break;
 
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
 	case TX_HASH_BUILDER_IN_CERTIFICATES:
 	case TX_HASH_BUILDER_IN_TTL:
 	case TX_HASH_BUILDER_IN_FEE:
-		txHashBuilder_assertCanLeaveMint(builder);
+		txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
 		ASSERT(!builder->includeScriptDataHash);
 		break;
 
@@ -1342,7 +1342,7 @@ static void txHashBuilder_assertCanLeaveCollaterals(tx_hash_builder_t* builder)
 		break;
 
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
@@ -1408,7 +1408,7 @@ static void txHashBuilder_assertCanLeaveRequiredSigners(tx_hash_builder_t* build
 
 	case TX_HASH_BUILDER_IN_COLLATERALS:
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
@@ -1450,7 +1450,7 @@ static void txHashBuilder_assertCanLeaveNetworkId(tx_hash_builder_t* builder)
 	case TX_HASH_BUILDER_IN_REQUIRED_SIGNERS:
 	case TX_HASH_BUILDER_IN_COLLATERALS:
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
diff --git a/src/txHashBuilder.h b/src/txHashBuilder.h
index 7420c97..fcb16ba 100644
--- a/src/txHashBuilder.h
+++ b/src/txHashBuilder.h
@@ -14,7 +14,7 @@ enum {
 	// TX_BODY_KEY_UPDATE = 6, // not used
 	TX_BODY_KEY_AUX_DATA = 7,
 	TX_BODY_KEY_VALIDITY_INTERVAL_START = 8,
-	TX_BODY_KEY_MINT = 9,
+	// TX_BODY_KEY_MINT = 9,
 	TX_BODY_KEY_SCRIPT_HASH_DATA = 11,
 	TX_BODY_KEY_COLLATERALS = 13,
 	TX_BODY_KEY_REQUIRED_SIGNERS = 14,
@@ -42,21 +42,21 @@ typedef enum {
 	TX_HASH_BUILDER_IN_FEE = 400,
 	TX_HASH_BUILDER_IN_TTL = 500,
 	TX_HASH_BUILDER_IN_CERTIFICATES = 600,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT = 610,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH = 611,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF = 612,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS = 613,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT = 614,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS = 615,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS = 616,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA = 617,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT = 610,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH = 611,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF = 612,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS = 613,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT = 614,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS = 615,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS = 616,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA = 617,
 	TX_HASH_BUILDER_IN_WITHDRAWALS = 700,
 	TX_HASH_BUILDER_IN_AUX_DATA = 800,
 	TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START = 900,
-	TX_HASH_BUILDER_IN_MINT = 1000,
-	TX_HASH_BUILDER_IN_MINT_TOP_LEVEL_DATA = 1010,
-	TX_HASH_BUILDER_IN_MINT_ASSET_GROUP = 1011,
-	TX_HASH_BUILDER_IN_MINT_TOKEN = 1012,
+	// TX_HASH_BUILDER_IN_MINT = 1000,
+	// TX_HASH_BUILDER_IN_MINT_TOP_LEVEL_DATA = 1010,
+	// TX_HASH_BUILDER_IN_MINT_ASSET_GROUP = 1011,
+	// TX_HASH_BUILDER_IN_MINT_TOKEN = 1012,
 	TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH = 1100,
 	TX_HASH_BUILDER_IN_COLLATERALS = 1200,
 	TX_HASH_BUILDER_IN_REQUIRED_SIGNERS = 1300,
@@ -79,10 +79,10 @@ typedef struct {
 	bool includeNetworkId;
 
 	union {
-		struct {
-			uint16_t remainingOwners;
-			uint16_t remainingRelays;
-		} poolCertificateData;
+		// struct {
+		// 	uint16_t remainingOwners;
+		// 	uint16_t remainingRelays;
+		// } poolCertificateData;
 
 		struct {
 			uint16_t remainingAssetGroups;
@@ -159,51 +159,51 @@ void txHashBuilder_addCertificate_delegation(
         const uint8_t* stakingKeyHash, size_t stakingKeyHashSize,
         const uint8_t* poolKeyHash, size_t poolKeyHashSize
 );
-void txHashBuilder_addCertificate_poolRetirement(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize,
-        uint64_t epoch
-);
+// void txHashBuilder_addCertificate_poolRetirement(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize,
+//         uint64_t epoch
+// );
 
-void txHashBuilder_poolRegistrationCertificate_enter(
-        tx_hash_builder_t* builder,
-        uint16_t numOwners, uint16_t numRelays
-);
-void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize
-);
-void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* vrfKeyHash, size_t vrfKeyHashSize
-);
-void txHashBuilder_poolRegistrationCertificate_financials(
-        tx_hash_builder_t* builder,
-        uint64_t pledge, uint64_t cost,
-        uint64_t marginNumerator, uint64_t marginDenominator
-);
-void txHashBuilder_poolRegistrationCertificate_rewardAccount(
-        tx_hash_builder_t* builder,
-        uint8_t* rewardAccount, size_t rewardAccountSize
-);
-void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder);
-void txHashBuilder_addPoolRegistrationCertificate_addOwner(
-        tx_hash_builder_t* builder,
-        const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
-);
-void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder);
-void txHashBuilder_addPoolRegistrationCertificate_addRelay(
-        tx_hash_builder_t* builder,
-        pool_relay_t* relay
-);
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
-        tx_hash_builder_t* builder,
-        const uint8_t* url, size_t urlSize,
-        const uint8_t* metadataHash, size_t metadataHashSize
-);
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
-        tx_hash_builder_t* builder
-);
+// void txHashBuilder_poolRegistrationCertificate_enter(
+//         tx_hash_builder_t* builder,
+//         uint16_t numOwners, uint16_t numRelays
+// );
+// void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize
+// );
+// void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* vrfKeyHash, size_t vrfKeyHashSize
+// );
+// void txHashBuilder_poolRegistrationCertificate_financials(
+//         tx_hash_builder_t* builder,
+//         uint64_t pledge, uint64_t cost,
+//         uint64_t marginNumerator, uint64_t marginDenominator
+// );
+// void txHashBuilder_poolRegistrationCertificate_rewardAccount(
+//         tx_hash_builder_t* builder,
+//         uint8_t* rewardAccount, size_t rewardAccountSize
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder);
+// void txHashBuilder_addPoolRegistrationCertificate_addOwner(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder);
+// void txHashBuilder_addPoolRegistrationCertificate_addRelay(
+//         tx_hash_builder_t* builder,
+//         pool_relay_t* relay
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* url, size_t urlSize,
+//         const uint8_t* metadataHash, size_t metadataHashSize
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
+//         tx_hash_builder_t* builder
+// );
 
 void txHashBuilder_enterWithdrawals(tx_hash_builder_t* builder);
 void txHashBuilder_addWithdrawal(
@@ -222,20 +222,20 @@ void txHashBuilder_addValidityIntervalStart(
         uint64_t validityIntervalStart
 );
 
-void txHashBuilder_enterMint(tx_hash_builder_t* builder);
-void txHashBuilder_addMint_topLevelData(
-        tx_hash_builder_t* builder, uint16_t numAssetGroups
-);
-void txHashBuilder_addMint_tokenGroup(
-        tx_hash_builder_t* builder,
-        const uint8_t* policyIdBuffer, size_t policyIdSize,
-        uint16_t numTokens
-);
-void txHashBuilder_addMint_token(
-        tx_hash_builder_t* builder,
-        const uint8_t* assetNameBuffer, size_t assetNameSize,
-        int64_t amount
-);
+// void txHashBuilder_enterMint(tx_hash_builder_t* builder);
+// void txHashBuilder_addMint_topLevelData(
+//         tx_hash_builder_t* builder, uint16_t numAssetGroups
+// );
+// void txHashBuilder_addMint_tokenGroup(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* policyIdBuffer, size_t policyIdSize,
+//         uint16_t numTokens
+// );
+// void txHashBuilder_addMint_token(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* assetNameBuffer, size_t assetNameSize,
+//         int64_t amount
+// );
 
 void txHashBuilder_addScriptDataHash(
         tx_hash_builder_t* builder,
diff --git a/src/txHashBuilder_test.c b/src/txHashBuilder_test.c
index cbb1927..53a9f9c 100644
--- a/src/txHashBuilder_test.c
+++ b/src/txHashBuilder_test.c
@@ -1,435 +1,435 @@
-#ifdef DEVEL
-
-#include "txHashBuilder.h"
-#include "cardano.h"
-#include "hexUtils.h"
-#include "textUtils.h"
-#include "testUtils.h"
-
-
-static struct {
-	const char* txHashHex;
-	int index;
-} inputs[] = {
-	{
-		"0B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
-		0
-	},
-	{
-		"1B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
-		1
-	},
-	{
-		"2B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
-		2
-	},
-	{
-		"3B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
-		3
-	},
-};
-
-static struct {
-	const char* rawAddressHex;
-	uint64_t amount;
-} outputs[] = {
-	{
-		"82D818582183581C6EE5BB111C8771CE03278E624056A12C9CFB353EB112E8ABF21FA4FEA0001A74EEE408",
-		100
-	},
-	{
-		"009493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
-		200
-	},
-	{
-		"409493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E87688F509738",
-		300
-	},
-	{
-		"609493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E",
-		400
-	},
-	{
-		"609493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E",
-		500
-	},
-};
-
-static struct {
-	const char* stakingKeyHash;
-} registrationCertificates[] = {
-	{
-		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC"
-	},
-};
-
-static struct {
-	const char* stakingKeyHash;
-} deregistrationCertificates[] = {
-	{
-		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC"
-	},
-	{
-		"337B62CFFF6403A06A3ACBC34F8C46003C69FE79A3628CEFA9C47251"
-	},
-};
-
-static struct {
-	const char* stakingKeyHash;
-	const char* poolKeyHash;
-} delegationCertificates[] = {
-	{
-		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
-		"0D13015CDBCDBD0889CE276192A1601F2D4D20B8392D4EF4F9A754E2"
-	},
-	{
-		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
-		"1D13015CDBCDBD0889CE276192A1601F2D4D20B8392D4EF4F9A754E2"
-	},
-	{
-		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
-		"2D13015CDBCDBD0889CE276192A1601F2D4D20B8392D4EF4F9A754E2"
-	},
-};
-
-static struct {
-	const char* rewardAddress;
-	uint64_t amount;
-} withdrawals[] = {
-	{
-		"E032C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
-		666
-	}
-};
-
-static const char* expectedHex = "a185a8ec05862e17cae482c1d5407f3f3dae472212e8b7fb06e7ae8322e9529e";
-
-typedef void(*addTokenGroupFun)(tx_hash_builder_t* builder,
-                                const uint8_t* policyIdBuffer, size_t policyIdSize,
-                                uint16_t numTokens);
-typedef void(*addTokenFun)(tx_hash_builder_t* builder,
-                           const uint8_t* assetNameBuffer, size_t assetNameSize,
-                           uint64_t amount);
-
-static void addTwoMultiassetTokenGroups(tx_hash_builder_t* builder,
-                                        addTokenGroupFun tokenGroupAdder, addTokenFun tokenAdder)
-{
-	// we reuse the buffers to avoid wasting stack
-	uint8_t policy[MINTING_POLICY_ID_SIZE] = {0};
-	explicit_bzero(policy, SIZEOF(policy));
-
-	uint8_t assetNameBuffer[ASSET_NAME_SIZE_MAX] = {0};
-	explicit_bzero(assetNameBuffer, SIZEOF(assetNameBuffer));
-
-	policy[0] = 1;
-	tokenGroupAdder(builder, policy, SIZEOF(policy), 2);
-
-	assetNameBuffer[0] = 11;
-	tokenAdder(builder, assetNameBuffer, SIZEOF(assetNameBuffer), 110);
-	assetNameBuffer[0] = 12;
-	tokenAdder(builder, assetNameBuffer, SIZEOF(assetNameBuffer), 120);
-
-	policy[0] = 2;
-	tokenGroupAdder(builder, policy, SIZEOF(policy), 2);
-
-	assetNameBuffer[0] = 21;
-	tokenAdder(builder, assetNameBuffer, SIZEOF(assetNameBuffer), 210);
-	assetNameBuffer[0] = 22;
-	// use a short buffer on purpose
-	tokenAdder(builder, assetNameBuffer, 1, 220);
-}
-
-static void addMintTokenProxy(tx_hash_builder_t* builder,
-                              const uint8_t* assetNameBuffer, size_t assetNameSize,
-                              uint64_t amount)
-{
-	txHashBuilder_addMint_token(builder, assetNameBuffer, assetNameSize, (int64_t)amount);
-}
-
-static void addMultiassetMint(tx_hash_builder_t* builder)
-{
-	txHashBuilder_addMint_topLevelData(builder, 2);
-	addTwoMultiassetTokenGroups(builder, &txHashBuilder_addMint_tokenGroup, &addMintTokenProxy);
-}
-
-static void outputTokenHandler(
-        tx_hash_builder_t* builder,
-        const uint8_t* assetNameBuffer, size_t assetNameSize,
-        uint64_t amount
-)
-{
-	txHashBuilder_addOutput_token(builder, assetNameBuffer, assetNameSize, amount, false);
-}
-
-
-static void addMultiassetOutput(tx_hash_builder_t* builder)
-{
-	uint8_t tmp[70] = {0};
-	size_t tmpSize = decode_hex(PTR_PIC(outputs[1].rawAddressHex), tmp, SIZEOF(tmp));
-	txHashBuilder_addOutput_topLevelData(
-	        builder,
-	        tmp, tmpSize,
-	        outputs[1].amount,
-	        2,
-	        false
-	);
-
-	addTwoMultiassetTokenGroups(builder, &txHashBuilder_addOutput_tokenGroup, &outputTokenHandler);
-}
-
-static void addOutputs(tx_hash_builder_t* builder)
-{
-	txHashBuilder_enterOutputs(builder);
-
-	addMultiassetOutput(builder);
-
-	ITERATE(it, outputs) {
-		uint8_t tmp[70] = {0};
-		size_t tmpSize = decode_hex(PTR_PIC(it->rawAddressHex), tmp, SIZEOF(tmp));
-		txHashBuilder_addOutput_topLevelData(
-		        builder,
-		        tmp, tmpSize,
-		        it->amount,
-		        0, false
-		);
-	}
-
-	// added for the second time to more thoroughly check the state machine
-	addMultiassetOutput(builder);
-}
-
-static void addPoolRegistrationCertificate(tx_hash_builder_t* builder)
-{
-	uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-	uint8_t vrfKeyHash[VRF_KEY_HASH_LENGTH] = {0};
-	uint64_t pledge = 500000000;
-	uint64_t cost = 340000000;
-	uint64_t marginNumerator = 1;
-	uint64_t marginDenominator = 1;
-	uint8_t rewardAccount[REWARD_ACCOUNT_SIZE] = {0};
-
-	size_t poolKeyHashSize = decode_hex(
-	                                 "5631EDE662CFB10FD5FD69B4667101DD289568E12BCF5F64D1C406FC",
-	                                 poolKeyHash, SIZEOF(poolKeyHash)
-	                         );
-	ASSERT(poolKeyHashSize == SIZEOF(poolKeyHash));
-
-	size_t vrfKeyHashSize = decode_hex(
-	                                "198890AD6C92E80FBDAB554DDA02DA9FB49D001BBD96181F3E07F7A6AB0D0640",
-	                                vrfKeyHash, SIZEOF(vrfKeyHash)
-	                        );
-	ASSERT(vrfKeyHashSize == SIZEOF(vrfKeyHash));
-
-	size_t rewardAccountSize = decode_hex(
-	                                   "E03A7F09D3DF4CF66A7399C2B05BFA234D5A29560C311FC5DB4C490711",
-	                                   rewardAccount, SIZEOF(rewardAccount)
-	                           );
-	ASSERT(rewardAccountSize == SIZEOF(rewardAccount));
-
-	txHashBuilder_poolRegistrationCertificate_enter(builder, 1, 3);
-	txHashBuilder_poolRegistrationCertificate_poolKeyHash(builder, poolKeyHash, SIZEOF(poolKeyHash));
-	txHashBuilder_poolRegistrationCertificate_vrfKeyHash(builder, vrfKeyHash, SIZEOF(vrfKeyHash));
-	txHashBuilder_poolRegistrationCertificate_financials(builder, pledge, cost, marginNumerator, marginDenominator);
-	txHashBuilder_poolRegistrationCertificate_rewardAccount(builder, rewardAccount, SIZEOF(rewardAccount));
-
-	txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
-
-	uint8_t owner1[28] = {0};
-	size_t owner1Size = decode_hex("3A7F09D3DF4CF66A7399C2B05BFA234D5A29560C311FC5DB4C490711", owner1, SIZEOF(owner1));
-	ASSERT(owner1Size == SIZEOF(owner1));
-
-	txHashBuilder_addPoolRegistrationCertificate_addOwner(builder, owner1, owner1Size);
-
-	txHashBuilder_addPoolRegistrationCertificate_enterRelays(builder);
-
-	{
-		pool_relay_t relay0;
-		relay0.format = 0;
-		relay0.port.isNull = false;
-		relay0.port.number = 1234;
-		relay0.ipv4.isNull = false;
-		decode_hex("08080808", relay0.ipv4.ip, IPV4_SIZE);
-		relay0.ipv6.isNull = true;
-		txHashBuilder_addPoolRegistrationCertificate_addRelay(builder, &relay0);
-	}
-	{
-		pool_relay_t relay1;
-		relay1.format = 1;
-		relay1.port.isNull = true;
-		// a valid DNS AAAA record, since dnsName actually is suppposed to be an A or AAAA record
-		const char* dnsName = "AAAA 2400:cb00:2049:1::a29f:1804";
-		relay1.dnsNameSize = str_textToBuffer(dnsName, relay1.dnsName, SIZEOF(relay1.dnsName));
-		txHashBuilder_addPoolRegistrationCertificate_addRelay(builder, &relay1);
-	}
-	{
-		pool_relay_t relay2;
-		relay2.format = 2;
-		// dnsName is not a valid DNS SRV record, but we don't validate it
-		const char* dnsName = "AAAA 2400:cb00:2049:1::a29f:1804";
-		relay2.dnsNameSize = str_textToBuffer(dnsName, relay2.dnsName, SIZEOF(relay2.dnsName));
-		txHashBuilder_addPoolRegistrationCertificate_addRelay(builder, &relay2);
-	}
-
-	uint8_t metadataHash[32] = {0};
-	size_t metadataHashSize = decode_hex("914C57C1F12BBF4A82B12D977D4F274674856A11ED4B9B95BD70F5D41C5064A6", metadataHash, SIZEOF(metadataHash));
-	ASSERT(metadataHashSize == SIZEOF(metadataHash));
-
-	const char* metadataUrl = "https://teststakepool.com";
-	uint8_t urlBuffer[DNS_NAME_SIZE_MAX] = {0};
-	size_t urlSize = str_textToBuffer(metadataUrl, urlBuffer, SIZEOF(urlBuffer));
-	ASSERT(urlSize <= DNS_NAME_SIZE_MAX);
-
-	txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(builder, urlBuffer, urlSize, metadataHash, metadataHashSize);
-}
-
-static void addPoolRetirementCertificate(tx_hash_builder_t* builder)
-{
-	uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-	uint64_t epoch = 1000;
-
-	size_t poolKeyHashSize = decode_hex(
-	                                 "5631EDE662CFB10FD5FD69B4667101DD289568E12BCF5F64D1C406FC",
-	                                 poolKeyHash, SIZEOF(poolKeyHash)
-	                         );
-	ASSERT(poolKeyHashSize == SIZEOF(poolKeyHash));
-
-	txHashBuilder_addCertificate_poolRetirement(
-	        builder,
-	        poolKeyHash, SIZEOF(poolKeyHash),
-	        epoch
-	);
-}
-
-static void addCertificates(tx_hash_builder_t* builder)
-{
-	txHashBuilder_enterCertificates(builder);
-
-	ITERATE(it, registrationCertificates) {
-		uint8_t tmp[70] = {0};
-		size_t tmpSize = decode_hex(PTR_PIC(it->stakingKeyHash), tmp, SIZEOF(tmp));
-		txHashBuilder_addCertificate_stakingHash(
-		        builder,
-		        CERTIFICATE_TYPE_STAKE_REGISTRATION,
-		        STAKE_CREDENTIAL_KEY_PATH,
-		        tmp, tmpSize
-		);
-	}
-
-	ITERATE(it, deregistrationCertificates) {
-		uint8_t tmp[70] = {0};
-		size_t tmpSize = decode_hex(PTR_PIC(it->stakingKeyHash), tmp, SIZEOF(tmp));
-		txHashBuilder_addCertificate_stakingHash(
-		        builder,
-		        CERTIFICATE_TYPE_STAKE_DEREGISTRATION,
-		        STAKE_CREDENTIAL_KEY_PATH,
-		        tmp, tmpSize
-		);
-	}
-
-	addPoolRegistrationCertificate(builder);
-
-	addPoolRetirementCertificate(builder);
-
-	ITERATE(it, delegationCertificates) {
-		uint8_t tmp_credential[70] = {0};
-		size_t tmpSize_credential = decode_hex(
-		                                    PTR_PIC(it->stakingKeyHash),
-		                                    tmp_credential, SIZEOF(tmp_credential)
-		                            );
-		uint8_t tmp_pool[70] = {0};
-		size_t tmpSize_pool = decode_hex(PTR_PIC(it->poolKeyHash), tmp_pool, SIZEOF(tmp_pool));
-		txHashBuilder_addCertificate_delegation(
-		        builder, STAKE_CREDENTIAL_KEY_PATH,
-		        tmp_credential, tmpSize_credential,
-		        tmp_pool, tmpSize_pool
-		);
-	}
-}
-
-static void addMint(tx_hash_builder_t* builder)
-{
-	txHashBuilder_enterMint(builder);
-
-	addMultiassetMint(builder);
-}
-
-void run_txHashBuilder_test()
-{
-	PRINTF("txHashBuilder test\n");
-	tx_hash_builder_t builder;
-
-	const size_t numCertificates = ARRAY_LEN(registrationCertificates) +
-	                               ARRAY_LEN(deregistrationCertificates) +
-	                               ARRAY_LEN(delegationCertificates) +
-	                               1 + // stake pool retirement certificate
-	                               1;  // stake pool registration certificate
-
-	txHashBuilder_init(&builder,
-	                   ARRAY_LEN(inputs), ARRAY_LEN(outputs) + 2, // +2 for multiasset outputs
-	                   true, // ttl
-	                   numCertificates, ARRAY_LEN(withdrawals),
-	                   true, // metadata
-	                   true, // validity interval start
-	                   true, // mint
-	                   false, // script hash data
-	                   0,	// collaterals not tested yet
-	                   0,	// required signers not tested yet
-	                   false // network id
-	                  );
-
-	txHashBuilder_enterInputs(&builder);
-	ITERATE(it, inputs) {
-		uint8_t tmp[TX_HASH_LENGTH] = {0};
-		size_t tmpSize = decode_hex(PTR_PIC(it->txHashHex), tmp, SIZEOF(tmp));
-		txHashBuilder_addInput(
-		        &builder,
-		        tmp, tmpSize,
-		        it->index
-		);
-	}
-
-	addOutputs(&builder);
-
-	txHashBuilder_addFee(&builder, 42);
-
-	txHashBuilder_addTtl(&builder, 235000);
-
-	addCertificates(&builder);
-
-	txHashBuilder_enterWithdrawals(&builder);
-
-	ITERATE(it, withdrawals) {
-		uint8_t tmp[70] = {0};
-		size_t tmpSize = decode_hex(PTR_PIC(it->rewardAddress), tmp, SIZEOF(tmp));
-		txHashBuilder_addWithdrawal(
-		        &builder,
-		        tmp, tmpSize,
-		        it->amount
-		);
-	}
-
-	{
-		const char auxDataHashHex[] = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
-		uint8_t tmp[AUX_DATA_HASH_LENGTH] = {0};
-		size_t tmpSize = decode_hex(auxDataHashHex, tmp, SIZEOF(tmp));
-		ASSERT(tmpSize == AUX_DATA_HASH_LENGTH);
-		txHashBuilder_addAuxData(&builder, tmp, tmpSize);
-	}
-
-	txHashBuilder_addValidityIntervalStart(&builder, 33);
-
-	addMint(&builder);
-
-	uint8_t result[TX_HASH_LENGTH] = {0};
-	txHashBuilder_finalize(&builder, result, SIZEOF(result));
-
-	uint8_t expected[TX_HASH_LENGTH] = {0};
-	decode_hex(expectedHex, expected, SIZEOF(expected));
-
-	PRINTF("result\n");
-	PRINTF("%.*h\n", 32, result);
-
-	EXPECT_EQ_BYTES(result, expected, 32);
-}
-
-#endif // DEVEL
+// #ifdef DEVEL
+
+// #include "txHashBuilder.h"
+// #include "cardano.h"
+// #include "hexUtils.h"
+// #include "textUtils.h"
+// #include "testUtils.h"
+
+
+// static struct {
+// 	const char* txHashHex;
+// 	int index;
+// } inputs[] = {
+// 	{
+// 		"0B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
+// 		0
+// 	},
+// 	{
+// 		"1B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
+// 		1
+// 	},
+// 	{
+// 		"2B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
+// 		2
+// 	},
+// 	{
+// 		"3B40265111D8BB3C3C608D95B3A0BF83461ACE32D79336579A1939B3AAD1C0B7",
+// 		3
+// 	},
+// };
+
+// static struct {
+// 	const char* rawAddressHex;
+// 	uint64_t amount;
+// } outputs[] = {
+// 	{
+// 		"82D818582183581C6EE5BB111C8771CE03278E624056A12C9CFB353EB112E8ABF21FA4FEA0001A74EEE408",
+// 		100
+// 	},
+// 	{
+// 		"009493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
+// 		200
+// 	},
+// 	{
+// 		"409493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E87688F509738",
+// 		300
+// 	},
+// 	{
+// 		"609493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E",
+// 		400
+// 	},
+// 	{
+// 		"609493315CD92EB5D8C4304E67B7E16AE36D61D34502694657811A2C8E",
+// 		500
+// 	},
+// };
+
+// static struct {
+// 	const char* stakingKeyHash;
+// } registrationCertificates[] = {
+// 	{
+// 		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC"
+// 	},
+// };
+
+// static struct {
+// 	const char* stakingKeyHash;
+// } deregistrationCertificates[] = {
+// 	{
+// 		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC"
+// 	},
+// 	{
+// 		"337B62CFFF6403A06A3ACBC34F8C46003C69FE79A3628CEFA9C47251"
+// 	},
+// };
+
+// static struct {
+// 	const char* stakingKeyHash;
+// 	const char* poolKeyHash;
+// } delegationCertificates[] = {
+// 	{
+// 		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
+// 		"0D13015CDBCDBD0889CE276192A1601F2D4D20B8392D4EF4F9A754E2"
+// 	},
+// 	{
+// 		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
+// 		"1D13015CDBCDBD0889CE276192A1601F2D4D20B8392D4EF4F9A754E2"
+// 	},
+// 	{
+// 		"32C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
+// 		"2D13015CDBCDBD0889CE276192A1601F2D4D20B8392D4EF4F9A754E2"
+// 	},
+// };
+
+// static struct {
+// 	const char* rewardAddress;
+// 	uint64_t amount;
+// } withdrawals[] = {
+// 	{
+// 		"E032C728D3861E164CAB28CB8F006448139C8F1740FFB8E7AA9E5232DC",
+// 		666
+// 	}
+// };
+
+// static const char* expectedHex = "a185a8ec05862e17cae482c1d5407f3f3dae472212e8b7fb06e7ae8322e9529e";
+
+// typedef void(*addTokenGroupFun)(tx_hash_builder_t* builder,
+//                                 const uint8_t* policyIdBuffer, size_t policyIdSize,
+//                                 uint16_t numTokens);
+// typedef void(*addTokenFun)(tx_hash_builder_t* builder,
+//                            const uint8_t* assetNameBuffer, size_t assetNameSize,
+//                            uint64_t amount);
+
+// static void addTwoMultiassetTokenGroups(tx_hash_builder_t* builder,
+//                                         addTokenGroupFun tokenGroupAdder, addTokenFun tokenAdder)
+// {
+// 	// we reuse the buffers to avoid wasting stack
+// 	uint8_t policy[MINTING_POLICY_ID_SIZE] = {0};
+// 	explicit_bzero(policy, SIZEOF(policy));
+
+// 	uint8_t assetNameBuffer[ASSET_NAME_SIZE_MAX] = {0};
+// 	explicit_bzero(assetNameBuffer, SIZEOF(assetNameBuffer));
+
+// 	policy[0] = 1;
+// 	tokenGroupAdder(builder, policy, SIZEOF(policy), 2);
+
+// 	assetNameBuffer[0] = 11;
+// 	tokenAdder(builder, assetNameBuffer, SIZEOF(assetNameBuffer), 110);
+// 	assetNameBuffer[0] = 12;
+// 	tokenAdder(builder, assetNameBuffer, SIZEOF(assetNameBuffer), 120);
+
+// 	policy[0] = 2;
+// 	tokenGroupAdder(builder, policy, SIZEOF(policy), 2);
+
+// 	assetNameBuffer[0] = 21;
+// 	tokenAdder(builder, assetNameBuffer, SIZEOF(assetNameBuffer), 210);
+// 	assetNameBuffer[0] = 22;
+// 	// use a short buffer on purpose
+// 	tokenAdder(builder, assetNameBuffer, 1, 220);
+// }
+
+// static void addMintTokenProxy(tx_hash_builder_t* builder,
+//                               const uint8_t* assetNameBuffer, size_t assetNameSize,
+//                               uint64_t amount)
+// {
+// 	txHashBuilder_addMint_token(builder, assetNameBuffer, assetNameSize, (int64_t)amount);
+// }
+
+// static void addMultiassetMint(tx_hash_builder_t* builder)
+// {
+// 	txHashBuilder_addMint_topLevelData(builder, 2);
+// 	addTwoMultiassetTokenGroups(builder, &txHashBuilder_addMint_tokenGroup, &addMintTokenProxy);
+// }
+
+// static void outputTokenHandler(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* assetNameBuffer, size_t assetNameSize,
+//         uint64_t amount
+// )
+// {
+// 	txHashBuilder_addOutput_token(builder, assetNameBuffer, assetNameSize, amount, false);
+// }
+
+
+// static void addMultiassetOutput(tx_hash_builder_t* builder)
+// {
+// 	uint8_t tmp[70] = {0};
+// 	size_t tmpSize = decode_hex(PTR_PIC(outputs[1].rawAddressHex), tmp, SIZEOF(tmp));
+// 	txHashBuilder_addOutput_topLevelData(
+// 	        builder,
+// 	        tmp, tmpSize,
+// 	        outputs[1].amount,
+// 	        2,
+// 	        false
+// 	);
+
+// 	addTwoMultiassetTokenGroups(builder, &txHashBuilder_addOutput_tokenGroup, &outputTokenHandler);
+// }
+
+// static void addOutputs(tx_hash_builder_t* builder)
+// {
+// 	txHashBuilder_enterOutputs(builder);
+
+// 	addMultiassetOutput(builder);
+
+// 	ITERATE(it, outputs) {
+// 		uint8_t tmp[70] = {0};
+// 		size_t tmpSize = decode_hex(PTR_PIC(it->rawAddressHex), tmp, SIZEOF(tmp));
+// 		txHashBuilder_addOutput_topLevelData(
+// 		        builder,
+// 		        tmp, tmpSize,
+// 		        it->amount,
+// 		        0, false
+// 		);
+// 	}
+
+// 	// added for the second time to more thoroughly check the state machine
+// 	addMultiassetOutput(builder);
+// }
+
+// static void addPoolRegistrationCertificate(tx_hash_builder_t* builder)
+// {
+// 	uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 	uint8_t vrfKeyHash[VRF_KEY_HASH_LENGTH] = {0};
+// 	uint64_t pledge = 500000000;
+// 	uint64_t cost = 340000000;
+// 	uint64_t marginNumerator = 1;
+// 	uint64_t marginDenominator = 1;
+// 	uint8_t rewardAccount[REWARD_ACCOUNT_SIZE] = {0};
+
+// 	size_t poolKeyHashSize = decode_hex(
+// 	                                 "5631EDE662CFB10FD5FD69B4667101DD289568E12BCF5F64D1C406FC",
+// 	                                 poolKeyHash, SIZEOF(poolKeyHash)
+// 	                         );
+// 	ASSERT(poolKeyHashSize == SIZEOF(poolKeyHash));
+
+// 	size_t vrfKeyHashSize = decode_hex(
+// 	                                "198890AD6C92E80FBDAB554DDA02DA9FB49D001BBD96181F3E07F7A6AB0D0640",
+// 	                                vrfKeyHash, SIZEOF(vrfKeyHash)
+// 	                        );
+// 	ASSERT(vrfKeyHashSize == SIZEOF(vrfKeyHash));
+
+// 	size_t rewardAccountSize = decode_hex(
+// 	                                   "E03A7F09D3DF4CF66A7399C2B05BFA234D5A29560C311FC5DB4C490711",
+// 	                                   rewardAccount, SIZEOF(rewardAccount)
+// 	                           );
+// 	ASSERT(rewardAccountSize == SIZEOF(rewardAccount));
+
+// 	txHashBuilder_poolRegistrationCertificate_enter(builder, 1, 3);
+// 	txHashBuilder_poolRegistrationCertificate_poolKeyHash(builder, poolKeyHash, SIZEOF(poolKeyHash));
+// 	txHashBuilder_poolRegistrationCertificate_vrfKeyHash(builder, vrfKeyHash, SIZEOF(vrfKeyHash));
+// 	txHashBuilder_poolRegistrationCertificate_financials(builder, pledge, cost, marginNumerator, marginDenominator);
+// 	txHashBuilder_poolRegistrationCertificate_rewardAccount(builder, rewardAccount, SIZEOF(rewardAccount));
+
+// 	txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
+
+// 	uint8_t owner1[28] = {0};
+// 	size_t owner1Size = decode_hex("3A7F09D3DF4CF66A7399C2B05BFA234D5A29560C311FC5DB4C490711", owner1, SIZEOF(owner1));
+// 	ASSERT(owner1Size == SIZEOF(owner1));
+
+// 	txHashBuilder_addPoolRegistrationCertificate_addOwner(builder, owner1, owner1Size);
+
+// 	txHashBuilder_addPoolRegistrationCertificate_enterRelays(builder);
+
+// 	{
+// 		pool_relay_t relay0;
+// 		relay0.format = 0;
+// 		relay0.port.isNull = false;
+// 		relay0.port.number = 1234;
+// 		relay0.ipv4.isNull = false;
+// 		decode_hex("08080808", relay0.ipv4.ip, IPV4_SIZE);
+// 		relay0.ipv6.isNull = true;
+// 		txHashBuilder_addPoolRegistrationCertificate_addRelay(builder, &relay0);
+// 	}
+// 	{
+// 		pool_relay_t relay1;
+// 		relay1.format = 1;
+// 		relay1.port.isNull = true;
+// 		// a valid DNS AAAA record, since dnsName actually is suppposed to be an A or AAAA record
+// 		const char* dnsName = "AAAA 2400:cb00:2049:1::a29f:1804";
+// 		relay1.dnsNameSize = str_textToBuffer(dnsName, relay1.dnsName, SIZEOF(relay1.dnsName));
+// 		txHashBuilder_addPoolRegistrationCertificate_addRelay(builder, &relay1);
+// 	}
+// 	{
+// 		pool_relay_t relay2;
+// 		relay2.format = 2;
+// 		// dnsName is not a valid DNS SRV record, but we don't validate it
+// 		const char* dnsName = "AAAA 2400:cb00:2049:1::a29f:1804";
+// 		relay2.dnsNameSize = str_textToBuffer(dnsName, relay2.dnsName, SIZEOF(relay2.dnsName));
+// 		txHashBuilder_addPoolRegistrationCertificate_addRelay(builder, &relay2);
+// 	}
+
+// 	uint8_t metadataHash[32] = {0};
+// 	size_t metadataHashSize = decode_hex("914C57C1F12BBF4A82B12D977D4F274674856A11ED4B9B95BD70F5D41C5064A6", metadataHash, SIZEOF(metadataHash));
+// 	ASSERT(metadataHashSize == SIZEOF(metadataHash));
+
+// 	const char* metadataUrl = "https://teststakepool.com";
+// 	uint8_t urlBuffer[DNS_NAME_SIZE_MAX] = {0};
+// 	size_t urlSize = str_textToBuffer(metadataUrl, urlBuffer, SIZEOF(urlBuffer));
+// 	ASSERT(urlSize <= DNS_NAME_SIZE_MAX);
+
+// 	txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(builder, urlBuffer, urlSize, metadataHash, metadataHashSize);
+// }
+
+// static void addPoolRetirementCertificate(tx_hash_builder_t* builder)
+// {
+// 	uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 	uint64_t epoch = 1000;
+
+// 	size_t poolKeyHashSize = decode_hex(
+// 	                                 "5631EDE662CFB10FD5FD69B4667101DD289568E12BCF5F64D1C406FC",
+// 	                                 poolKeyHash, SIZEOF(poolKeyHash)
+// 	                         );
+// 	ASSERT(poolKeyHashSize == SIZEOF(poolKeyHash));
+
+// 	txHashBuilder_addCertificate_poolRetirement(
+// 	        builder,
+// 	        poolKeyHash, SIZEOF(poolKeyHash),
+// 	        epoch
+// 	);
+// }
+
+// static void addCertificates(tx_hash_builder_t* builder)
+// {
+// 	txHashBuilder_enterCertificates(builder);
+
+// 	ITERATE(it, registrationCertificates) {
+// 		uint8_t tmp[70] = {0};
+// 		size_t tmpSize = decode_hex(PTR_PIC(it->stakingKeyHash), tmp, SIZEOF(tmp));
+// 		txHashBuilder_addCertificate_stakingHash(
+// 		        builder,
+// 		        CERTIFICATE_TYPE_STAKE_REGISTRATION,
+// 		        STAKE_CREDENTIAL_KEY_PATH,
+// 		        tmp, tmpSize
+// 		);
+// 	}
+
+// 	ITERATE(it, deregistrationCertificates) {
+// 		uint8_t tmp[70] = {0};
+// 		size_t tmpSize = decode_hex(PTR_PIC(it->stakingKeyHash), tmp, SIZEOF(tmp));
+// 		txHashBuilder_addCertificate_stakingHash(
+// 		        builder,
+// 		        CERTIFICATE_TYPE_STAKE_DEREGISTRATION,
+// 		        STAKE_CREDENTIAL_KEY_PATH,
+// 		        tmp, tmpSize
+// 		);
+// 	}
+
+// 	addPoolRegistrationCertificate(builder);
+
+// 	addPoolRetirementCertificate(builder);
+
+// 	ITERATE(it, delegationCertificates) {
+// 		uint8_t tmp_credential[70] = {0};
+// 		size_t tmpSize_credential = decode_hex(
+// 		                                    PTR_PIC(it->stakingKeyHash),
+// 		                                    tmp_credential, SIZEOF(tmp_credential)
+// 		                            );
+// 		uint8_t tmp_pool[70] = {0};
+// 		size_t tmpSize_pool = decode_hex(PTR_PIC(it->poolKeyHash), tmp_pool, SIZEOF(tmp_pool));
+// 		txHashBuilder_addCertificate_delegation(
+// 		        builder, STAKE_CREDENTIAL_KEY_PATH,
+// 		        tmp_credential, tmpSize_credential,
+// 		        tmp_pool, tmpSize_pool
+// 		);
+// 	}
+// }
+
+// static void addMint(tx_hash_builder_t* builder)
+// {
+// 	txHashBuilder_enterMint(builder);
+
+// 	addMultiassetMint(builder);
+// }
+
+// void run_txHashBuilder_test()
+// {
+// 	PRINTF("txHashBuilder test\n");
+// 	tx_hash_builder_t builder;
+
+// 	const size_t numCertificates = ARRAY_LEN(registrationCertificates) +
+// 	                               ARRAY_LEN(deregistrationCertificates) +
+// 	                               ARRAY_LEN(delegationCertificates) +
+// 	                               1 + // stake pool retirement certificate
+// 	                               1;  // stake pool registration certificate
+
+// 	txHashBuilder_init(&builder,
+// 	                   ARRAY_LEN(inputs), ARRAY_LEN(outputs) + 2, // +2 for multiasset outputs
+// 	                   true, // ttl
+// 	                   numCertificates, ARRAY_LEN(withdrawals),
+// 	                   true, // metadata
+// 	                   true, // validity interval start
+// 	                   true, // mint
+// 	                   false, // script hash data
+// 	                   0,	// collaterals not tested yet
+// 	                   0,	// required signers not tested yet
+// 	                   false // network id
+// 	                  );
+
+// 	txHashBuilder_enterInputs(&builder);
+// 	ITERATE(it, inputs) {
+// 		uint8_t tmp[TX_HASH_LENGTH] = {0};
+// 		size_t tmpSize = decode_hex(PTR_PIC(it->txHashHex), tmp, SIZEOF(tmp));
+// 		txHashBuilder_addInput(
+// 		        &builder,
+// 		        tmp, tmpSize,
+// 		        it->index
+// 		);
+// 	}
+
+// 	addOutputs(&builder);
+
+// 	txHashBuilder_addFee(&builder, 42);
+
+// 	txHashBuilder_addTtl(&builder, 235000);
+
+// 	addCertificates(&builder);
+
+// 	txHashBuilder_enterWithdrawals(&builder);
+
+// 	ITERATE(it, withdrawals) {
+// 		uint8_t tmp[70] = {0};
+// 		size_t tmpSize = decode_hex(PTR_PIC(it->rewardAddress), tmp, SIZEOF(tmp));
+// 		txHashBuilder_addWithdrawal(
+// 		        &builder,
+// 		        tmp, tmpSize,
+// 		        it->amount
+// 		);
+// 	}
+
+// 	{
+// 		const char auxDataHashHex[] = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
+// 		uint8_t tmp[AUX_DATA_HASH_LENGTH] = {0};
+// 		size_t tmpSize = decode_hex(auxDataHashHex, tmp, SIZEOF(tmp));
+// 		ASSERT(tmpSize == AUX_DATA_HASH_LENGTH);
+// 		txHashBuilder_addAuxData(&builder, tmp, tmpSize);
+// 	}
+
+// 	txHashBuilder_addValidityIntervalStart(&builder, 33);
+
+// 	addMint(&builder);
+
+// 	uint8_t result[TX_HASH_LENGTH] = {0};
+// 	txHashBuilder_finalize(&builder, result, SIZEOF(result));
+
+// 	uint8_t expected[TX_HASH_LENGTH] = {0};
+// 	decode_hex(expectedHex, expected, SIZEOF(expected));
+
+// 	PRINTF("result\n");
+// 	PRINTF("%.*h\n", 32, result);
+
+// 	EXPECT_EQ_BYTES(result, expected, 32);
+// }
+
+// #endif // DEVEL
diff --git a/src/uiScreens.c b/src/uiScreens.c
index 0374819..70177b4 100644
--- a/src/uiScreens.c
+++ b/src/uiScreens.c
@@ -5,7 +5,7 @@
 #include "ipUtils.h"
 #include "textUtils.h"
 #include "signTx.h"
-#include "signTxPoolRegistration.h"
+// #include "signTxPoolRegistration.h"
 #include "tokens.h"
 
 
@@ -162,10 +162,10 @@ void ui_displayGetPublicKeyPathScreen(
 )
 {
 	switch (bip44_classifyPath(path)) {
-	case PATH_POOL_COLD_KEY: {
-		ui_displayPathScreen("Export cold public key", path, callback);
-		return;
-	}
+	// case PATH_POOL_COLD_KEY: {
+	// 	ui_displayPathScreen("Export cold public key", path, callback);
+	// 	return;
+	// }
 
 	case PATH_ORDINARY_ACCOUNT: {
 		_ui_displayAccountWithDescriptionScreen("Export public key", path, true, callback);
@@ -526,28 +526,28 @@ void ui_displayTokenAmountOutputScreen(
 	);
 }
 
-void ui_displayTokenAmountMintScreen(
-        const token_group_t* tokenGroup,
-        const uint8_t* assetNameBytes, size_t assetNameSize,
-        int64_t tokenAmount,
-        ui_callback_fn_t callback
-)
-{
-	char tokenAmountStr[70] = {0};
-	explicit_bzero(tokenAmountStr, SIZEOF(tokenAmountStr));
-	str_formatTokenAmountMint(
-	        tokenGroup,
-	        assetNameBytes, assetNameSize,
-	        tokenAmount,
-	        tokenAmountStr, SIZEOF(tokenAmountStr)
-	);
-
-	ui_displayPaginatedText(
-	        "Token amount",
-	        tokenAmountStr,
-	        callback
-	);
-}
+// void ui_displayTokenAmountMintScreen(
+//         const token_group_t* tokenGroup,
+//         const uint8_t* assetNameBytes, size_t assetNameSize,
+//         int64_t tokenAmount,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char tokenAmountStr[70] = {0};
+// 	explicit_bzero(tokenAmountStr, SIZEOF(tokenAmountStr));
+// 	str_formatTokenAmountMint(
+// 	        tokenGroup,
+// 	        assetNameBytes, assetNameSize,
+// 	        tokenAmount,
+// 	        tokenAmountStr, SIZEOF(tokenAmountStr)
+// 	);
+
+// 	ui_displayPaginatedText(
+// 	        "Token amount",
+// 	        tokenAmountStr,
+// 	        callback
+// 	);
+// }
 
 void ui_displayUint64Screen(
         const char* firstLine,
@@ -643,195 +643,195 @@ void ui_displayNetworkParamsScreen(
 	);
 }
 
-void ui_displayPoolMarginScreen(
-        uint64_t marginNumerator, uint64_t marginDenominator,
-        ui_callback_fn_t callback
-)
-{
-	ASSERT(marginDenominator != 0);
-	ASSERT(marginNumerator <= marginDenominator);
-	ASSERT(marginDenominator <= MARGIN_DENOMINATOR_MAX);
-
-	char marginStr[20] = {0};
-	explicit_bzero(marginStr, SIZEOF(marginStr));
-
-	{
-		// marginPercentage is a multiple of 1/100th of 1%, i.e. the fractional part of the percentage has two digits
-		// adding marginDenominator / 2 to have a rounded result
-		uint64_t marginPercentage = (10000 * marginNumerator + (marginDenominator / 2)) / marginDenominator;
-		ASSERT(marginPercentage <= 10000);
-
-		const unsigned int percentage = (unsigned int) marginPercentage;
-
-		STATIC_ASSERT(sizeof(percentage) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(percentage), "signed type for %u");
-		snprintf(marginStr, SIZEOF(marginStr), "%u.%u %%", percentage / 100, percentage % 100);
-		ASSERT(strlen(marginStr) + 1 < SIZEOF(marginStr));
-	}
-
-	TRACE("%s", marginStr);
-
-	ui_displayPaginatedText(
-	        "Profit margin",
-	        marginStr,
-	        callback
-	);
-}
-
-void ui_displayPoolOwnerScreen(
-        const pool_owner_t* owner,
-        uint32_t ownerIndex,
-        uint8_t networkId,
-        ui_callback_fn_t callback
-)
-{
-	{
-		ASSERT(isValidNetworkId(networkId));
-		ASSERT(ownerIndex < POOL_MAX_OWNERS);
-	}
-	{
-		uint8_t rewardAddress[REWARD_ACCOUNT_SIZE] = {0};
-
-		switch (owner->keyReferenceType) {
-		case KEY_REFERENCE_PATH: {
-			ASSERT(bip44_isOrdinaryStakingKeyPath(&owner->path));
-
-			constructRewardAddressFromKeyPath(
-			        &owner->path, networkId, rewardAddress, SIZEOF(rewardAddress)
-			);
-			break;
-		}
-		case KEY_REFERENCE_HASH: {
-			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
-
-			constructRewardAddressFromHash(
-			        networkId, REWARD_HASH_SOURCE_KEY,
-			        owner->keyHash, SIZEOF(owner->keyHash),
-			        rewardAddress, SIZEOF(rewardAddress)
-			);
-			break;
-		}
-		default:
-			ASSERT(false);
-		}
-
-		char firstLine[20] = {0};
-		explicit_bzero(firstLine, SIZEOF(firstLine));
-		STATIC_ASSERT(sizeof(ownerIndex + 1) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(ownerIndex + 1), "signed type for %u");
-		// indexed from 0 as discuss with IOHK on Slack
-		snprintf(firstLine, SIZEOF(firstLine), "Owner #%u", ownerIndex);
-		// make sure all the information is displayed to the user
-		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
-
-		_displayRewardAccountWithDescriptionScreen(
-		        owner->keyReferenceType,
-		        &owner->path,
-		        rewardAddress,
-		        firstLine,
-		        callback
-		);
-	}
-}
-
-// displays pool relay index
-void ui_displayPoolRelayScreen(
-        const pool_relay_t* relay MARK_UNUSED,
-        size_t relayIndex,
-        ui_callback_fn_t callback
-)
-{
-	char firstLine[20] = {0};
-	explicit_bzero(firstLine, SIZEOF(firstLine));
-	{
-		STATIC_ASSERT(sizeof(relayIndex + 1) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(relayIndex + 1), "signed type for %u");
-		// indexed from 0 as discussed with IOHK on Slack
-		snprintf(firstLine, SIZEOF(firstLine), "Relay #%u", relayIndex);
-		// make sure all the information is displayed to the user
-		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
-	}
-
-	ui_displayPaginatedText(
-	        firstLine,
-	        "",
-	        callback
-	);
-}
-
-void ui_displayIpv4Screen(
-        const ipv4_t* ipv4,
-        ui_callback_fn_t callback
-)
-{
-	char ipStr[IPV4_STR_SIZE_MAX + 1] = {0};
-	explicit_bzero(ipStr, SIZEOF(ipStr));
-
-	if (ipv4->isNull) {
-		snprintf(ipStr, SIZEOF(ipStr), "(none)");
-	} else {
-		inet_ntop4(ipv4->ip, ipStr, SIZEOF(ipStr));
-	}
-
-	// make sure all the information is displayed to the user
-	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
-
-	ui_displayPaginatedText(
-	        "IPv4 address",
-	        ipStr,
-	        callback
-	);
-}
-
-void ui_displayIpv6Screen(
-        const ipv6_t* ipv6,
-        ui_callback_fn_t callback
-)
-{
-	char ipStr[IPV6_STR_SIZE_MAX + 1] = {0};
-	explicit_bzero(ipStr, SIZEOF(ipStr));
-
-	if (ipv6->isNull) {
-		snprintf(ipStr, SIZEOF(ipStr), "(none)");
-	} else {
-		inet_ntop6(ipv6->ip, ipStr, SIZEOF(ipStr));
-	}
-
-	// make sure all the information is displayed to the user
-	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
-
-	ui_displayPaginatedText(
-	        "IPv6 address",
-	        ipStr,
-	        callback
-	);
-}
-
-void ui_displayIpPortScreen(
-        const ipport_t* port,
-        ui_callback_fn_t callback
-)
-{
-	char portStr[1 + (sizeof "65536")] = {0};
-	explicit_bzero(portStr, SIZEOF(portStr));
-
-	if (port->isNull) {
-		snprintf(portStr, SIZEOF(portStr), "(none)");
-	} else {
-		STATIC_ASSERT(sizeof(port->number) <= sizeof(unsigned), "oversized variable for %u");
-		STATIC_ASSERT(!IS_SIGNED(port->number), "signed type for %u");
-		snprintf(portStr, SIZEOF(portStr), "%u", port->number);
-	}
-
-	// make sure all the information is displayed to the user
-	ASSERT(strlen(portStr) + 1 < SIZEOF(portStr));
-
-	ui_displayPaginatedText(
-	        "Port",
-	        portStr,
-	        callback
-	);
-}
+// void ui_displayPoolMarginScreen(
+//         uint64_t marginNumerator, uint64_t marginDenominator,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	ASSERT(marginDenominator != 0);
+// 	ASSERT(marginNumerator <= marginDenominator);
+// 	ASSERT(marginDenominator <= MARGIN_DENOMINATOR_MAX);
+
+// 	char marginStr[20] = {0};
+// 	explicit_bzero(marginStr, SIZEOF(marginStr));
+
+// 	{
+// 		// marginPercentage is a multiple of 1/100th of 1%, i.e. the fractional part of the percentage has two digits
+// 		// adding marginDenominator / 2 to have a rounded result
+// 		uint64_t marginPercentage = (10000 * marginNumerator + (marginDenominator / 2)) / marginDenominator;
+// 		ASSERT(marginPercentage <= 10000);
+
+// 		const unsigned int percentage = (unsigned int) marginPercentage;
+
+// 		STATIC_ASSERT(sizeof(percentage) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(percentage), "signed type for %u");
+// 		snprintf(marginStr, SIZEOF(marginStr), "%u.%u %%", percentage / 100, percentage % 100);
+// 		ASSERT(strlen(marginStr) + 1 < SIZEOF(marginStr));
+// 	}
+
+// 	TRACE("%s", marginStr);
+
+// 	ui_displayPaginatedText(
+// 	        "Profit margin",
+// 	        marginStr,
+// 	        callback
+// 	);
+// }
+
+// void ui_displayPoolOwnerScreen(
+//         const pool_owner_t* owner,
+//         uint32_t ownerIndex,
+//         uint8_t networkId,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	{
+// 		ASSERT(isValidNetworkId(networkId));
+// 		ASSERT(ownerIndex < POOL_MAX_OWNERS);
+// 	}
+// 	{
+// 		uint8_t rewardAddress[REWARD_ACCOUNT_SIZE] = {0};
+
+// 		switch (owner->keyReferenceType) {
+// 		case KEY_REFERENCE_PATH: {
+// 			ASSERT(bip44_isOrdinaryStakingKeyPath(&owner->path));
+
+// 			constructRewardAddressFromKeyPath(
+// 			        &owner->path, networkId, rewardAddress, SIZEOF(rewardAddress)
+// 			);
+// 			break;
+// 		}
+// 		case KEY_REFERENCE_HASH: {
+// 			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
+
+// 			constructRewardAddressFromHash(
+// 			        networkId, REWARD_HASH_SOURCE_KEY,
+// 			        owner->keyHash, SIZEOF(owner->keyHash),
+// 			        rewardAddress, SIZEOF(rewardAddress)
+// 			);
+// 			break;
+// 		}
+// 		default:
+// 			ASSERT(false);
+// 		}
+
+// 		char firstLine[20] = {0};
+// 		explicit_bzero(firstLine, SIZEOF(firstLine));
+// 		STATIC_ASSERT(sizeof(ownerIndex + 1) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(ownerIndex + 1), "signed type for %u");
+// 		// indexed from 0 as discuss with IOHK on Slack
+// 		snprintf(firstLine, SIZEOF(firstLine), "Owner #%u", ownerIndex);
+// 		// make sure all the information is displayed to the user
+// 		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
+
+// 		_displayRewardAccountWithDescriptionScreen(
+// 		        owner->keyReferenceType,
+// 		        &owner->path,
+// 		        rewardAddress,
+// 		        firstLine,
+// 		        callback
+// 		);
+// 	}
+// }
+
+// // displays pool relay index
+// void ui_displayPoolRelayScreen(
+//         const pool_relay_t* relay MARK_UNUSED,
+//         size_t relayIndex,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char firstLine[20] = {0};
+// 	explicit_bzero(firstLine, SIZEOF(firstLine));
+// 	{
+// 		STATIC_ASSERT(sizeof(relayIndex + 1) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(relayIndex + 1), "signed type for %u");
+// 		// indexed from 0 as discussed with IOHK on Slack
+// 		snprintf(firstLine, SIZEOF(firstLine), "Relay #%u", relayIndex);
+// 		// make sure all the information is displayed to the user
+// 		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
+// 	}
+
+// 	ui_displayPaginatedText(
+// 	        firstLine,
+// 	        "",
+// 	        callback
+// 	);
+// }
+
+// void ui_displayIpv4Screen(
+//         const ipv4_t* ipv4,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char ipStr[IPV4_STR_SIZE_MAX + 1] = {0};
+// 	explicit_bzero(ipStr, SIZEOF(ipStr));
+
+// 	if (ipv4->isNull) {
+// 		snprintf(ipStr, SIZEOF(ipStr), "(none)");
+// 	} else {
+// 		inet_ntop4(ipv4->ip, ipStr, SIZEOF(ipStr));
+// 	}
+
+// 	// make sure all the information is displayed to the user
+// 	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
+
+// 	ui_displayPaginatedText(
+// 	        "IPv4 address",
+// 	        ipStr,
+// 	        callback
+// 	);
+// }
+
+// void ui_displayIpv6Screen(
+//         const ipv6_t* ipv6,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char ipStr[IPV6_STR_SIZE_MAX + 1] = {0};
+// 	explicit_bzero(ipStr, SIZEOF(ipStr));
+
+// 	if (ipv6->isNull) {
+// 		snprintf(ipStr, SIZEOF(ipStr), "(none)");
+// 	} else {
+// 		inet_ntop6(ipv6->ip, ipStr, SIZEOF(ipStr));
+// 	}
+
+// 	// make sure all the information is displayed to the user
+// 	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
+
+// 	ui_displayPaginatedText(
+// 	        "IPv6 address",
+// 	        ipStr,
+// 	        callback
+// 	);
+// }
+
+// void ui_displayIpPortScreen(
+//         const ipport_t* port,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char portStr[1 + (sizeof "65536")] = {0};
+// 	explicit_bzero(portStr, SIZEOF(portStr));
+
+// 	if (port->isNull) {
+// 		snprintf(portStr, SIZEOF(portStr), "(none)");
+// 	} else {
+// 		STATIC_ASSERT(sizeof(port->number) <= sizeof(unsigned), "oversized variable for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(port->number), "signed type for %u");
+// 		snprintf(portStr, SIZEOF(portStr), "%u", port->number);
+// 	}
+
+// 	// make sure all the information is displayed to the user
+// 	ASSERT(strlen(portStr) + 1 < SIZEOF(portStr));
+
+// 	ui_displayPaginatedText(
+// 	        "Port",
+// 	        portStr,
+// 	        callback
+// 	);
+// }
 
 void ui_displayInputScreen(
         const char* screenHeader,
diff --git a/src/uiScreens.h b/src/uiScreens.h
index 2c23afe..38a5db7 100644
--- a/src/uiScreens.h
+++ b/src/uiScreens.h
@@ -5,7 +5,7 @@
 #include "addressUtilsShelley.h"
 #include "signTx.h"
 #include "signTxOutput.h"
-#include "signTxPoolRegistration.h"
+// #include "signTxPoolRegistration.h"
 
 __noinline_due_to_stack__
 void ui_displayBech32Screen(
@@ -89,13 +89,13 @@ void ui_displayTokenAmountOutputScreen(
         ui_callback_fn_t callback
 );
 
-__noinline_due_to_stack__
-void ui_displayTokenAmountMintScreen(
-        const token_group_t* tokenGroup,
-        const uint8_t* assetNameBytes, size_t assetNameSize,
-        int64_t tokenAmount,
-        ui_callback_fn_t callback
-);
+// __noinline_due_to_stack__
+// void ui_displayTokenAmountMintScreen(
+//         const token_group_t* tokenGroup,
+//         const uint8_t* assetNameBytes, size_t assetNameSize,
+//         int64_t tokenAmount,
+//         ui_callback_fn_t callback
+// );
 
 __noinline_due_to_stack__
 void ui_displayUint64Screen(
@@ -133,38 +133,38 @@ void ui_displayPoolMarginScreen(
         ui_callback_fn_t callback
 );
 
-__noinline_due_to_stack__
-void ui_displayPoolOwnerScreen(
-        const pool_owner_t* owner,
-        uint32_t ownerIndex,
-        uint8_t networkId,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayPoolRelayScreen(
-        const pool_relay_t* relay,
-        size_t relayIndex,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayIpv4Screen(
-        const ipv4_t* ipv4,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayIpv6Screen(
-        const ipv6_t* ipv6,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayIpPortScreen(
-        const ipport_t* port,
-        ui_callback_fn_t callback
-);
+// __noinline_due_to_stack__
+// void ui_displayPoolOwnerScreen(
+//         const pool_owner_t* owner,
+//         uint32_t ownerIndex,
+//         uint8_t networkId,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayPoolRelayScreen(
+//         const pool_relay_t* relay,
+//         size_t relayIndex,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayIpv4Screen(
+//         const ipv4_t* ipv4,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayIpv6Screen(
+//         const ipv6_t* ipv6,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayIpPortScreen(
+//         const ipport_t* port,
+//         ui_callback_fn_t callback
+// );
 
 __noinline_due_to_stack__
 void ui_displayInputScreen(
