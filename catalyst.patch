diff --git a/src/auxDataHashBuilder.c b/src/auxDataHashBuilder.c
index 2de2d13..f4340a5 100644
--- a/src/auxDataHashBuilder.c
+++ b/src/auxDataHashBuilder.c
@@ -1,265 +1,265 @@
-#include "common.h"
-#include "auxDataHashBuilder.h"
-#include "hash.h"
-#include "cbor.h"
-#include "cardano.h"
-#include "bufView.h"
-
-// this tracing is rarely needed
-// so we want to keep it turned off to avoid polluting the trace log
-
-//#define TRACE_AUX_DATA_HASH_BUILDER
-
-#ifdef TRACE_AUX_DATA_HASH_BUILDER
-#define _TRACE(...) TRACE(__VA_ARGS__)
-#else
-#define _TRACE(...)
-#endif // DEVEL
-
-enum {
-	HC_AUX_DATA =         (1u << 0), // aux data hash context
-	HC_CATALYST_PAYLOAD = (1u << 1)  // catalyst voting registration payload hash context
-};
-
-/*
-The following macros and functions have dual purpose:
-1. syntactic sugar for neat recording of hash computations;
-2. tracing of hash computations (allows to reconstruct bytestrings we are hashing via usbtool).
-*/
-
-#define APPEND_CBOR(hashContexts, type, value) \
-	if (hashContexts & HC_AUX_DATA) { \
-		blake2b_256_append_cbor_aux_data(&builder->auxDataHash, type, value, true); \
-	} \
-	if (hashContexts & HC_CATALYST_PAYLOAD) { \
-		blake2b_256_append_cbor_aux_data(&builder->catalystRegistrationData.payloadHash, type, value, false); \
-	}
-
-#define APPEND_DATA(hashContexts, buffer, bufferSize) \
-	if (hashContexts & HC_AUX_DATA) { \
-		blake2b_256_append_buffer_aux_data(&builder->auxDataHash, buffer, bufferSize, true); \
-	} \
-	if (hashContexts & HC_CATALYST_PAYLOAD) { \
-		blake2b_256_append_buffer_aux_data(&builder->catalystRegistrationData.payloadHash, buffer, bufferSize, false); \
-	}
-
-
-__noinline_due_to_stack__
-static void blake2b_256_append_cbor_aux_data(
-        blake2b_256_context_t* hashCtx,
-        uint8_t type, uint64_t value,
-        bool trace
-)
-{
-	uint8_t buffer[10] = {0};
-	size_t size = cbor_writeToken(type, value, buffer, SIZEOF(buffer));
-	if (trace) {
-		TRACE_BUFFER(buffer, size);
-	}
-	blake2b_256_append(hashCtx, buffer, size);
-}
-
-static void blake2b_256_append_buffer_aux_data(
-        blake2b_256_context_t* hashCtx,
-        const uint8_t* buffer, size_t bufferSize,
-        bool trace
-)
-{
-	ASSERT(bufferSize < BUFFER_SIZE_PARANOIA);
-
-	// keeping tracing within a function to be able to extract the serialized data
-	// by matching the function name where the tracing is invoked
-	if (trace) {
-		TRACE_BUFFER(buffer, bufferSize);
-	}
-	blake2b_256_append(hashCtx, buffer, bufferSize);
-}
-
-/* End of hash computation utilities. */
-
-void auxDataHashBuilder_init(
-        aux_data_hash_builder_t* builder
-)
-{
-	TRACE("Serializing tx auxiliary data");
-	blake2b_256_init(&builder->auxDataHash);
-	blake2b_256_init(&builder->catalystRegistrationData.payloadHash);
-
-	{
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 2);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_INIT;
-}
-
-void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_INIT);
-	{
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 2);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT;
-}
-
-void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT);
-	{
-		// map {61284: <payload>} is being hashed and signed in the catalyst voting registration
-		// this instruction introduces the beginning of this single-key dictionary
-		// the remainder of the payload serialization shares the tokens with the overall auxiliary data CBOR
-		APPEND_CBOR(HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 1)
-
-		// Enter the Catalyst voting key registration payload inner map
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD);
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 4);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT;
-}
-
-void auxDataHashBuilder_catalystRegistration_addVotingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(votingPubKeySize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY);
-		{
-			ASSERT(votingPubKeySize == PUBLIC_KEY_SIZE);
-			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, votingPubKeySize);
-			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, votingPubKeyBuffer, votingPubKeySize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY;
-}
-
-void auxDataHashBuilder_catalystRegistration_addStakingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(stakingPubKeySize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY);
-		{
-			ASSERT(stakingPubKeySize == PUBLIC_KEY_SIZE);
-			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, stakingPubKeySize);
-			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, stakingPubKeyBuffer, stakingPubKeySize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY;
-}
-
-void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* addressBuffer, size_t addressSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY);
-	ASSERT(addressSize <= BUFFER_SIZE_PARANOIA);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS);
-		{
-			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, addressSize);
-			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, addressBuffer, addressSize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS;
-}
-
-void auxDataHashBuilder_catalystRegistration_addNonce(
-        aux_data_hash_builder_t* builder,
-        uint64_t nonce
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS);
-	{
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE);
-		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, nonce);
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE;
-}
-
-void auxDataHashBuilder_catalystRegistration_finalizePayload(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
-
-	ASSERT(outSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
-	{
-		blake2b_256_finalize(&builder->catalystRegistrationData.payloadHash, outBuffer, outSize);
-	}
-}
-
-void auxDataHashBuilder_catalystRegistration_addSignature(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* signatureBuffer, size_t signatureSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(signatureSize < BUFFER_SIZE_PARANOIA);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
-	{
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_SIGNATURE);
-		{
-			ASSERT(signatureSize == ED25519_SIGNATURE_LENGTH);
-			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 1);
-			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, CATALYST_SIGNATURE_KEY);
-			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_BYTES, signatureSize);
-			APPEND_DATA(HC_AUX_DATA, signatureBuffer, signatureSize);
-		}
-	}
-	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE;
-}
-
-void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(
-        aux_data_hash_builder_t* builder
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE);
-	{
-		// auxiliary scripts currently hard-coded to an empty list
-		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 0);
-	}
-
-	builder->state = AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS;
-}
-
-void auxDataHashBuilder_finalize(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS);
-
-	ASSERT(outSize == AUX_DATA_HASH_LENGTH);
-	{
-		blake2b_256_finalize(&builder->auxDataHash, outBuffer, outSize);
-	}
-
-	builder->state = AUX_DATA_HASH_BUILDER_FINISHED;
-}
+// #include "common.h"
+// #include "auxDataHashBuilder.h"
+// #include "hash.h"
+// #include "cbor.h"
+// #include "cardano.h"
+// #include "bufView.h"
+
+// // this tracing is rarely needed
+// // so we want to keep it turned off to avoid polluting the trace log
+
+// //#define TRACE_AUX_DATA_HASH_BUILDER
+
+// #ifdef TRACE_AUX_DATA_HASH_BUILDER
+// #define _TRACE(...) TRACE(__VA_ARGS__)
+// #else
+// #define _TRACE(...)
+// #endif // DEVEL
+
+// enum {
+// 	HC_AUX_DATA =         (1u << 0), // aux data hash context
+// 	HC_CATALYST_PAYLOAD = (1u << 1)  // catalyst voting registration payload hash context
+// };
+
+// /*
+// The following macros and functions have dual purpose:
+// 1. syntactic sugar for neat recording of hash computations;
+// 2. tracing of hash computations (allows to reconstruct bytestrings we are hashing via usbtool).
+// */
+
+// #define APPEND_CBOR(hashContexts, type, value) \
+// 	if (hashContexts & HC_AUX_DATA) { \
+// 		blake2b_256_append_cbor_aux_data(&builder->auxDataHash, type, value, true); \
+// 	} \
+// 	if (hashContexts & HC_CATALYST_PAYLOAD) { \
+// 		blake2b_256_append_cbor_aux_data(&builder->catalystRegistrationData.payloadHash, type, value, false); \
+// 	}
+
+// #define APPEND_DATA(hashContexts, buffer, bufferSize) \
+// 	if (hashContexts & HC_AUX_DATA) { \
+// 		blake2b_256_append_buffer_aux_data(&builder->auxDataHash, buffer, bufferSize, true); \
+// 	} \
+// 	if (hashContexts & HC_CATALYST_PAYLOAD) { \
+// 		blake2b_256_append_buffer_aux_data(&builder->catalystRegistrationData.payloadHash, buffer, bufferSize, false); \
+// 	}
+
+
+// __noinline_due_to_stack__
+// static void blake2b_256_append_cbor_aux_data(
+//         blake2b_256_context_t* hashCtx,
+//         uint8_t type, uint64_t value,
+//         bool trace
+// )
+// {
+// 	uint8_t buffer[10] = {0};
+// 	size_t size = cbor_writeToken(type, value, buffer, SIZEOF(buffer));
+// 	if (trace) {
+// 		TRACE_BUFFER(buffer, size);
+// 	}
+// 	blake2b_256_append(hashCtx, buffer, size);
+// }
+
+// static void blake2b_256_append_buffer_aux_data(
+//         blake2b_256_context_t* hashCtx,
+//         const uint8_t* buffer, size_t bufferSize,
+//         bool trace
+// )
+// {
+// 	ASSERT(bufferSize < BUFFER_SIZE_PARANOIA);
+
+// 	// keeping tracing within a function to be able to extract the serialized data
+// 	// by matching the function name where the tracing is invoked
+// 	if (trace) {
+// 		TRACE_BUFFER(buffer, bufferSize);
+// 	}
+// 	blake2b_256_append(hashCtx, buffer, bufferSize);
+// }
+
+// /* End of hash computation utilities. */
+
+// void auxDataHashBuilder_init(
+//         aux_data_hash_builder_t* builder
+// )
+// {
+// 	TRACE("Serializing tx auxiliary data");
+// 	blake2b_256_init(&builder->auxDataHash);
+// 	blake2b_256_init(&builder->catalystRegistrationData.payloadHash);
+
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 2);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_INIT;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_INIT);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 2);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT);
+// 	{
+// 		// map {61284: <payload>} is being hashed and signed in the catalyst voting registration
+// 		// this instruction introduces the beginning of this single-key dictionary
+// 		// the remainder of the payload serialization shares the tokens with the overall auxiliary data CBOR
+// 		APPEND_CBOR(HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 1)
+
+// 		// Enter the Catalyst voting key registration payload inner map
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD);
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_MAP, 4);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addVotingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(votingPubKeySize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY);
+// 		{
+// 			ASSERT(votingPubKeySize == PUBLIC_KEY_SIZE);
+// 			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, votingPubKeySize);
+// 			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, votingPubKeyBuffer, votingPubKeySize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addStakingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(stakingPubKeySize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY);
+// 		{
+// 			ASSERT(stakingPubKeySize == PUBLIC_KEY_SIZE);
+// 			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, stakingPubKeySize);
+// 			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, stakingPubKeyBuffer, stakingPubKeySize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* addressBuffer, size_t addressSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY);
+// 	ASSERT(addressSize <= BUFFER_SIZE_PARANOIA);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS);
+// 		{
+// 			APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_BYTES, addressSize);
+// 			APPEND_DATA(HC_AUX_DATA | HC_CATALYST_PAYLOAD, addressBuffer, addressSize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addNonce(
+//         aux_data_hash_builder_t* builder,
+//         uint64_t nonce
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE);
+// 		APPEND_CBOR(HC_AUX_DATA | HC_CATALYST_PAYLOAD, CBOR_TYPE_UNSIGNED, nonce);
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_finalizePayload(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
+
+// 	ASSERT(outSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
+// 	{
+// 		blake2b_256_finalize(&builder->catalystRegistrationData.payloadHash, outBuffer, outSize);
+// 	}
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addSignature(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* signatureBuffer, size_t signatureSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(signatureSize < BUFFER_SIZE_PARANOIA);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE);
+// 	{
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, METADATA_KEY_CATALYST_SIGNATURE);
+// 		{
+// 			ASSERT(signatureSize == ED25519_SIGNATURE_LENGTH);
+// 			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_MAP, 1);
+// 			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_UNSIGNED, CATALYST_SIGNATURE_KEY);
+// 			APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_BYTES, signatureSize);
+// 			APPEND_DATA(HC_AUX_DATA, signatureBuffer, signatureSize);
+// 		}
+// 	}
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE;
+// }
+
+// void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(
+//         aux_data_hash_builder_t* builder
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE);
+// 	{
+// 		// auxiliary scripts currently hard-coded to an empty list
+// 		APPEND_CBOR(HC_AUX_DATA, CBOR_TYPE_ARRAY, 0);
+// 	}
+
+// 	builder->state = AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS;
+// }
+
+// void auxDataHashBuilder_finalize(aux_data_hash_builder_t* builder, uint8_t* outBuffer, size_t outSize)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS);
+
+// 	ASSERT(outSize == AUX_DATA_HASH_LENGTH);
+// 	{
+// 		blake2b_256_finalize(&builder->auxDataHash, outBuffer, outSize);
+// 	}
+
+// 	builder->state = AUX_DATA_HASH_BUILDER_FINISHED;
+// }
diff --git a/src/auxDataHashBuilder.h b/src/auxDataHashBuilder.h
index e32710d..e0270e7 100644
--- a/src/auxDataHashBuilder.h
+++ b/src/auxDataHashBuilder.h
@@ -1,87 +1,87 @@
-#ifndef H_CARDANO_APP_AUX_DATA_HASH_BUILDER
-#define H_CARDANO_APP_AUX_DATA_HASH_BUILDER
+// #ifndef H_CARDANO_APP_AUX_DATA_HASH_BUILDER
+// #define H_CARDANO_APP_AUX_DATA_HASH_BUILDER
 
-#include "cardano.h"
-#include "hash.h"
-#include "keyDerivation.h"
+// #include "cardano.h"
+// #include "hash.h"
+// #include "keyDerivation.h"
 
-enum {
-	METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD = 61284,
-	METADATA_KEY_CATALYST_SIGNATURE = 61285,
-};
+// enum {
+// 	METADATA_KEY_CATALYST_REGISTRATION_PAYLOAD = 61284,
+// 	METADATA_KEY_CATALYST_SIGNATURE = 61285,
+// };
 
-enum {
-	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY = 1,
-	CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY = 2,
-	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS = 3,
-	CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE = 4,
-};
+// enum {
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_KEY = 1,
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_STAKING_KEY = 2,
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_VOTING_REWARDS_ADDRESS = 3,
+// 	CATALYST_REGISTRATION_PAYLOAD_KEY_NONCE = 4,
+// };
 
-enum {
-	CATALYST_SIGNATURE_KEY = 1,
-};
+// enum {
+// 	CATALYST_SIGNATURE_KEY = 1,
+// };
 
-typedef enum {
-	AUX_DATA_HASH_BUILDER_INIT = 100,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT = 200,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT = 210,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY = 211,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY = 212,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS = 213,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE = 214,
-	AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE = 220,
-	AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS = 300,
-	AUX_DATA_HASH_BUILDER_FINISHED = 400,
-} aux_data_hash_builder_state_t;
+// typedef enum {
+// 	AUX_DATA_HASH_BUILDER_INIT = 100,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_REGISTRATION_INIT = 200,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_INIT = 210,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_KEY = 211,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_STAKING_KEY = 212,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_VOTING_REWARDS_ADDRESS = 213,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_PAYLOAD_NONCE = 214,
+// 	AUX_DATA_HASH_BUILDER_IN_CATALYST_SIGNATURE = 220,
+// 	AUX_DATA_HASH_BUILDER_IN_AUXILIARY_SCRIPTS = 300,
+// 	AUX_DATA_HASH_BUILDER_FINISHED = 400,
+// } aux_data_hash_builder_state_t;
 
-typedef struct {
-	struct {
-		blake2b_256_context_t payloadHash;
-	} catalystRegistrationData;
+// typedef struct {
+// 	struct {
+// 		blake2b_256_context_t payloadHash;
+// 	} catalystRegistrationData;
 
-	aux_data_hash_builder_state_t state;
-	blake2b_256_context_t auxDataHash;
-} aux_data_hash_builder_t;
+// 	aux_data_hash_builder_state_t state;
+// 	blake2b_256_context_t auxDataHash;
+// } aux_data_hash_builder_t;
 
 
-void auxDataHashBuilder_init(
-        aux_data_hash_builder_t* builder
-);
+// void auxDataHashBuilder_init(
+//         aux_data_hash_builder_t* builder
+// );
 
-void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder);
-void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder);
-void auxDataHashBuilder_catalystRegistration_addVotingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
-);
-void auxDataHashBuilder_catalystRegistration_addStakingKey(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
-);
-void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* addressBuffer, size_t addressSize
-);
-void auxDataHashBuilder_catalystRegistration_addNonce(aux_data_hash_builder_t* builder, uint64_t nonce);
-void auxDataHashBuilder_catalystRegistration_finalizePayload(
-        aux_data_hash_builder_t* builder,
-        uint8_t* outBuffer, size_t outSize
-);
+// void auxDataHashBuilder_catalystRegistration_enter(aux_data_hash_builder_t* builder);
+// void auxDataHashBuilder_catalystRegistration_enterPayload(aux_data_hash_builder_t* builder);
+// void auxDataHashBuilder_catalystRegistration_addVotingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* votingPubKeyBuffer, size_t votingPubKeySize
+// );
+// void auxDataHashBuilder_catalystRegistration_addStakingKey(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* stakingPubKeyBuffer, size_t stakingPubKeySize
+// );
+// void auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* addressBuffer, size_t addressSize
+// );
+// void auxDataHashBuilder_catalystRegistration_addNonce(aux_data_hash_builder_t* builder, uint64_t nonce);
+// void auxDataHashBuilder_catalystRegistration_finalizePayload(
+//         aux_data_hash_builder_t* builder,
+//         uint8_t* outBuffer, size_t outSize
+// );
 
-void auxDataHashBuilder_catalystRegistration_addSignature(
-        aux_data_hash_builder_t* builder,
-        const uint8_t* signatureBuffer, size_t signatureSize
-);
+// void auxDataHashBuilder_catalystRegistration_addSignature(
+//         aux_data_hash_builder_t* builder,
+//         const uint8_t* signatureBuffer, size_t signatureSize
+// );
 
-void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(aux_data_hash_builder_t* builder);
+// void auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(aux_data_hash_builder_t* builder);
 
-void auxDataHashBuilder_finalize(
-        aux_data_hash_builder_t* builder,
-        uint8_t* outBuffer, size_t outSize
-);
+// void auxDataHashBuilder_finalize(
+//         aux_data_hash_builder_t* builder,
+//         uint8_t* outBuffer, size_t outSize
+// );
 
-#ifdef DEVEL
-void run_auxDataHashBuilder_test();
-#endif // DEVEL
+// #ifdef DEVEL
+// void run_auxDataHashBuilder_test();
+// #endif // DEVEL
 
-#endif // H_CARDANO_APP_AUX_DATA_HASH_BUILDER
+// #endif // H_CARDANO_APP_AUX_DATA_HASH_BUILDER
diff --git a/src/cardano.h b/src/cardano.h
index a314f72..0a9a17a 100644
--- a/src/cardano.h
+++ b/src/cardano.h
@@ -19,7 +19,7 @@ STATIC_ASSERT(LOVELACE_MAX_SUPPLY < LOVELACE_INVALID, "bad LOVELACE_INVALID");
 #define TX_HASH_LENGTH 32
 #define AUX_DATA_HASH_LENGTH 32
 #define POOL_METADATA_HASH_LENGTH 32
-#define CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH 32
+// #define CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH 32
 #define ED25519_SIGNATURE_LENGTH 64
 #define SCRIPT_HASH_LENGTH 28
 #define SCRIPT_DATA_HASH_LENGTH 32
diff --git a/src/messageSigning.c b/src/messageSigning.c
index 006eb69..4c7c2fe 100644
--- a/src/messageSigning.c
+++ b/src/messageSigning.c
@@ -74,17 +74,17 @@ void getTxWitness(bip44_path_t* pathSpec,
 	#endif
 }
 
-void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
-        const uint8_t* payloadHashBuffer, size_t payloadHashSize,
-        uint8_t* outBuffer, size_t outSize)
-{
-	ASSERT(payloadHashSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
-	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
+// void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
+//         const uint8_t* payloadHashBuffer, size_t payloadHashSize,
+//         uint8_t* outBuffer, size_t outSize)
+// {
+// 	ASSERT(payloadHashSize == CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH);
+// 	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
 
-	#ifndef FUZZING
-	signRawMessageWithPath(pathSpec, payloadHashBuffer, payloadHashSize, outBuffer, outSize);
-	#endif
-}
+// 	#ifndef FUZZING
+// 	signRawMessageWithPath(pathSpec, payloadHashBuffer, payloadHashSize, outBuffer, outSize);
+// 	#endif
+// }
 
 void getOpCertSignature(bip44_path_t* pathSpec,
                         const uint8_t* opCertBodyBuffer, size_t opCertBodySize,
diff --git a/src/messageSigning.h b/src/messageSigning.h
index 5fd7e45..9d7d1fa 100644
--- a/src/messageSigning.h
+++ b/src/messageSigning.h
@@ -7,9 +7,9 @@ void getTxWitness(bip44_path_t* pathSpec,
                   const uint8_t* txHashBuffer, size_t txHashSize,
                   uint8_t* outBuffer, size_t outSize);
 
-void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
-        const uint8_t* payloadHashBuffer, size_t payloadHashSize,
-        uint8_t* outBuffer, size_t outSize);
+// void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
+//         const uint8_t* payloadHashBuffer, size_t payloadHashSize,
+//         uint8_t* outBuffer, size_t outSize);
 
 void getOpCertSignature(bip44_path_t* pathSpec,
                         const uint8_t* opCertBodyBuffer, size_t opCertBodySize,
diff --git a/src/securityPolicy.c b/src/securityPolicy.c
index 1be5402..8cca44b 100644
--- a/src/securityPolicy.c
+++ b/src/securityPolicy.c
@@ -33,12 +33,12 @@ static inline bool is_standard_base_address(const addressParams_t* addressParams
 #undef CHECK
 }
 
-static inline bool is_reward_address(const addressParams_t* addressParams)
-{
-	ASSERT(isValidAddressParams(addressParams));
+// static inline bool is_reward_address(const addressParams_t* addressParams)
+// {
+// 	ASSERT(isValidAddressParams(addressParams));
 
-	return addressParams->type == REWARD_KEY || addressParams->type == REWARD_SCRIPT;
-}
+// 	return addressParams->type == REWARD_KEY || addressParams->type == REWARD_SCRIPT;
+// }
 
 // spending part of the address is a script hash
 static inline bool allows_datum_hash(const uint8_t addressType)
@@ -1240,12 +1240,12 @@ security_policy_t policyForSignTxAuxData(aux_data_type_t auxDataType)
 		SHOW_IF(app_mode_expert());
 		ALLOW();
 
-	case AUX_DATA_TYPE_CATALYST_REGISTRATION:
-		// this is the policy for the initial prompt
-		// details of the registration are governed by separate policies
-		// (see policyForCatalystRegistration...)
-		SHOW();
-		break;
+	// case AUX_DATA_TYPE_CATALYST_REGISTRATION:
+	// 	// this is the policy for the initial prompt
+	// 	// details of the registration are governed by separate policies
+	// 	// (see policyForCatalystRegistration...)
+	// 	SHOW();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -1417,44 +1417,44 @@ security_policy_t policyForSignTxConfirm()
 	PROMPT();
 }
 
-security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
-        const addressParams_t* params,
-        const uint8_t networkId
-)
-{
-	DENY_UNLESS(isValidAddressParams(params));
-	DENY_UNLESS(isShelleyAddressType(params->type));
-	DENY_IF(params->networkId != networkId);
-
-	WARN_UNLESS(is_reward_address(params) || is_standard_base_address(params));
-
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationStakingKey(
-        const bip44_path_t* stakingKeyPath
-)
-{
-	DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(stakingKeyPath));
-	WARN_UNLESS(bip44_hasReasonableAccount(stakingKeyPath));
-
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationVotingKey()
-{
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationNonce()
-{
-	SHOW();
-}
-
-security_policy_t policyForCatalystRegistrationConfirm()
-{
-	PROMPT();
-}
+// security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
+//         const addressParams_t* params,
+//         const uint8_t networkId
+// )
+// {
+// 	DENY_UNLESS(isValidAddressParams(params));
+// 	DENY_UNLESS(isShelleyAddressType(params->type));
+// 	DENY_IF(params->networkId != networkId);
+
+// 	WARN_UNLESS(is_reward_address(params) || is_standard_base_address(params));
+
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationStakingKey(
+//         const bip44_path_t* stakingKeyPath
+// )
+// {
+// 	DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(stakingKeyPath));
+// 	WARN_UNLESS(bip44_hasReasonableAccount(stakingKeyPath));
+
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationVotingKey()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationNonce()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForCatalystRegistrationConfirm()
+// {
+// 	PROMPT();
+// }
 
 security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec)
 {
diff --git a/src/securityPolicy.h b/src/securityPolicy.h
index 48cba45..fb4322d 100644
--- a/src/securityPolicy.h
+++ b/src/securityPolicy.h
@@ -145,15 +145,15 @@ security_policy_t policyForSignTxConfirm();
 
 security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec);
 
-security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
-        const addressParams_t* params,
-        const uint8_t networkId
-);
-security_policy_t policyForCatalystRegistrationStakingKey(
-        const bip44_path_t* stakingKeyPath
-);
-security_policy_t policyForCatalystRegistrationVotingKey();
-security_policy_t policyForCatalystRegistrationNonce();
-security_policy_t policyForCatalystRegistrationConfirm();
+// security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
+//         const addressParams_t* params,
+//         const uint8_t networkId
+// );
+// security_policy_t policyForCatalystRegistrationStakingKey(
+//         const bip44_path_t* stakingKeyPath
+// );
+// security_policy_t policyForCatalystRegistrationVotingKey();
+// security_policy_t policyForCatalystRegistrationNonce();
+// security_policy_t policyForCatalystRegistrationConfirm();
 
 #endif // H_CARDANO_APP_SECURITY_POLICY
diff --git a/src/signTx.c b/src/signTx.c
index ec23d83..924efb9 100644
--- a/src/signTx.c
+++ b/src/signTx.c
@@ -327,19 +327,19 @@ static inline void checkForFinishedSubmachines()
 		}
 		break;
 
-	case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
-		if (signTxCatalystRegistration_isFinished()) {
-			TRACE();
-			ctx->stage = SIGN_STAGE_AUX_DATA;
-			AUX_DATA_CTX->auxDataReceived = true;
+	// case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
+	// 	if (signTxCatalystRegistration_isFinished()) {
+	// 		TRACE();
+	// 		ctx->stage = SIGN_STAGE_AUX_DATA;
+	// 		AUX_DATA_CTX->auxDataReceived = true;
 
-			STATIC_ASSERT(SIZEOF(ctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
-			STATIC_ASSERT(SIZEOF(AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
-			memmove(ctx->auxDataHash, AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash, AUX_DATA_HASH_LENGTH);
+	// 		STATIC_ASSERT(SIZEOF(ctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
+	// 		STATIC_ASSERT(SIZEOF(AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong auxiliary data hash length");
+	// 		memmove(ctx->auxDataHash, AUX_DATA_CTX->stageContext.catalyst_registration_subctx.auxDataHash, AUX_DATA_HASH_LENGTH);
 
-			advanceStage();
-		}
-		break;
+	// 		advanceStage();
+	// 	}
+	// 	break;
 
 	case SIGN_STAGE_BODY_MINT_SUBMACHINE:
 		if (signTxMint_isFinished()) {
@@ -649,34 +649,34 @@ static void signTx_handleAuxDataArbitraryHash_ui_runStep()
 }
 
 
-enum {
-	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY = 850,
-	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND,
-	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID,
-};
-static void signTx_handleAuxDataCatalystRegistration_ui_runStep()
-{
-	TRACE("UI step %d", ctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTx_handleAuxDataCatalystRegistration_ui_runStep;
-
-	UI_STEP_BEGIN(ctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY) {
-		ui_displayPrompt(
-		        "Register Catalyst",
-		        "voting key?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		signTxCatalystRegistration_init();
-		ctx->stage = SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE;
-	}
-	UI_STEP_END(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID);
-}
+// enum {
+// 	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY = 850,
+// 	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND,
+// 	HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID,
+// };
+// static void signTx_handleAuxDataCatalystRegistration_ui_runStep()
+// {
+// 	TRACE("UI step %d", ctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTx_handleAuxDataCatalystRegistration_ui_runStep;
+
+// 	UI_STEP_BEGIN(ctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY) {
+// 		ui_displayPrompt(
+// 		        "Register Catalyst",
+// 		        "voting key?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		signTxCatalystRegistration_init();
+// 		ctx->stage = SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE;
+// 	}
+// 	UI_STEP_END(HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_INVALID);
+// }
 
 __noinline_due_to_stack__
 static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
@@ -687,17 +687,17 @@ static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 		ASSERT(ctx->includeAuxData == true);
 
 		// delegate to state sub-machine for stake pool registration certificate data
-		if (signTxCatalystRegistration_isValidInstruction(p2)) {
-			TRACE();
-			CHECK_STAGE(SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE);
+		// if (signTxCatalystRegistration_isValidInstruction(p2)) {
+		// 	TRACE();
+		// 	CHECK_STAGE(SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE);
 
-			TRACE_STACK_USAGE();
+		// 	TRACE_STACK_USAGE();
 
-			signTxCatalystRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
-			return;
-		} else {
+		// 	signTxCatalystRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
+		// 	return;
+		// } else {
 			CHECK_STAGE(SIGN_STAGE_AUX_DATA);
-		}
+		// }
 	}
 	{
 		explicit_bzero(ctx->auxDataHash, SIZEOF(ctx->auxDataHash));
@@ -716,8 +716,8 @@ static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 			break;
 		}
 
-		case AUX_DATA_TYPE_CATALYST_REGISTRATION:
-			break;
+		// case AUX_DATA_TYPE_CATALYST_REGISTRATION:
+		// 	break;
 
 		default:
 			THROW(ERR_INVALID_DATA);
@@ -745,19 +745,19 @@ static void signTx_handleAuxDataAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 		signTx_handleAuxDataArbitraryHash_ui_runStep();
 		break;
 	}
-	case AUX_DATA_TYPE_CATALYST_REGISTRATION:
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-
-		signTx_handleAuxDataCatalystRegistration_ui_runStep();
-		break;
+// 	case AUX_DATA_TYPE_CATALYST_REGISTRATION:
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_AUX_DATA_CATALYST_REGISTRATION_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+
+// 		signTx_handleAuxDataCatalystRegistration_ui_runStep();
+// 		break;
 	default:
 		ASSERT(false);
 	}
@@ -2356,7 +2356,7 @@ ins_sign_tx_aux_data_context_t* accessAuxDataContext()
 	switch (ctx->stage) {
 
 	case SIGN_STAGE_AUX_DATA:
-	case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
+	// case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
 		return &(ctx->txPartCtx.aux_data_ctx);
 
 	default:
diff --git a/src/signTx.h b/src/signTx.h
index 255a070..223ce11 100644
--- a/src/signTx.h
+++ b/src/signTx.h
@@ -10,7 +10,7 @@
 #include "signTxMint.h"
 #include "signTxOutput.h"
 #include "signTxPoolRegistration.h"
-#include "signTxCatalystRegistration.h"
+// #include "signTxCatalystRegistration.h"
 #include "signTxAuxData.h"
 
 // the signing mode significantly affects restrictions on tx being signed
@@ -26,7 +26,7 @@ typedef enum {
 	SIGN_STAGE_NONE = 0,
 	SIGN_STAGE_INIT = 23,
 	SIGN_STAGE_AUX_DATA = 24,
-	SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE = 25,
+	// SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE = 25,
 	SIGN_STAGE_BODY_INPUTS = 26,
 	SIGN_STAGE_BODY_OUTPUTS = 27,
 	SIGN_STAGE_BODY_OUTPUTS_SUBMACHINE = 28,
@@ -111,11 +111,11 @@ typedef struct {
 typedef struct {
 	bool auxDataReceived;
 	aux_data_type_t auxDataType;
-	aux_data_hash_builder_t auxDataHashBuilder;
+	// aux_data_hash_builder_t auxDataHashBuilder;
 
-	struct {
-		catalyst_registration_context_t catalyst_registration_subctx;
-	} stageContext;
+	// struct {
+	// 	catalyst_registration_context_t catalyst_registration_subctx;
+	// } stageContext;
 } ins_sign_tx_aux_data_context_t;
 
 typedef enum {
diff --git a/src/signTxAuxData.h b/src/signTxAuxData.h
index 4317654..132fd0e 100644
--- a/src/signTxAuxData.h
+++ b/src/signTxAuxData.h
@@ -3,7 +3,7 @@
 
 typedef enum {
 	AUX_DATA_TYPE_ARBITRARY_HASH = 0,
-	AUX_DATA_TYPE_CATALYST_REGISTRATION = 1,
+	// AUX_DATA_TYPE_CATALYST_REGISTRATION = 1,
 } aux_data_type_t;
 
 #endif // H_CARDANO_APP_SIGN_TX_AUX_DATA
diff --git a/src/signTxCatalystRegistration.c b/src/signTxCatalystRegistration.c
index fdffe53..a3b87a5 100644
--- a/src/signTxCatalystRegistration.c
+++ b/src/signTxCatalystRegistration.c
@@ -1,635 +1,635 @@
-#include "app_mode.h"
-#include "signTxCatalystRegistration.h"
-#include "state.h"
-#include "uiHelpers.h"
-#include "signTxUtils.h"
-#include "uiScreens.h"
-#include "auxDataHashBuilder.h"
-#include "txHashBuilder.h"
-#include "textUtils.h"
-#include "bufView.h"
-#include "securityPolicy.h"
-#include "messageSigning.h"
-
-static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
-
-static inline catalyst_registration_context_t* accessSubContext()
-{
-	return &AUX_DATA_CTX->stageContext.catalyst_registration_subctx;
-}
-
-bool signTxCatalystRegistration_isFinished()
-{
-	const catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("Catalyst registration submachine state: %d", subctx->state);
-	// we are also asserting that the state is valid
-	switch (subctx->state) {
-	case STATE_CATALYST_REGISTRATION_FINISHED:
-		return true;
-
-	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
-	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
-	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
-	case STATE_CATALYST_REGISTRATION_NONCE:
-	case STATE_CATALYST_REGISTRATION_CONFIRM:
-		return false;
-
-	default:
-		ASSERT(false);
-	}
-}
-
-void signTxCatalystRegistration_init()
-{
-	explicit_bzero(&AUX_DATA_CTX->stageContext, SIZEOF(AUX_DATA_CTX->stageContext));
-	auxDataHashBuilder_init(&AUX_DATA_CTX->auxDataHashBuilder);
-
-	accessSubContext()->state = STATE_CATALYST_REGISTRATION_VOTING_KEY;
-}
-
-static inline void CHECK_STATE(sign_tx_catalyst_registration_state_t expected)
-{
-	TRACE("Catalyst voting registration submachine state: current %d, expected %d", accessSubContext()->state, expected);
-	VALIDATE(accessSubContext()->state == expected, ERR_INVALID_STATE);
-}
-
-static inline void advanceState()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("Advancing Catalyst registration state from: %d", subctx->state);
-
-	switch (subctx->state) {
-
-	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
-		subctx->state = STATE_CATALYST_REGISTRATION_STAKING_KEY;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
-		subctx->state = STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
-		subctx->state = STATE_CATALYST_REGISTRATION_NONCE;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_NONCE:
-		subctx->state = STATE_CATALYST_REGISTRATION_CONFIRM;
-		break;
-
-	case STATE_CATALYST_REGISTRATION_CONFIRM:
-		subctx->state = STATE_CATALYST_REGISTRATION_FINISHED;
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	TRACE("Advancing Catalyst registration state to: %d", subctx->state);
-}
-
-// ============================== VOTING KEY ==============================
-
-enum {
-	HANDLE_VOTING_KEY_STEP_DISPLAY = 8200,
-	HANDLE_VOTING_KEY_STEP_RESPOND,
-	HANDLE_VOTING_KEY_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleVotingKey_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_VOTING_KEY_STEP_DISPLAY) {
-		STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
-
-		// Jormungandr public key, hence the "ed25519_pk" prefix
-		// https://github.com/input-output-hk/jormungandr/blob/a057af27493d823be02480bb20258c25ff979e2a/jormungandr-lib/src/crypto/key.rs#L126
-		ui_displayBech32Screen(
-		        "Voting public key",
-		        "ed25519_pk",
-		        subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_VOTING_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_VOTING_KEY_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleVotingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_KEY);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-	{
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		{
-			VALIDATE(wireDataSize == SIZEOF(subctx->stateData.votingPubKey), ERR_INVALID_DATA);
-			read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-			STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
-			view_parseBuffer(subctx->stateData.votingPubKey, &view, CATALYST_VOTING_PUBLIC_KEY_LENGTH);
-
-			VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-		}
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationVotingKey();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
-		auxDataHashBuilder_catalystRegistration_enter(auxDataHashBuilder);
-		auxDataHashBuilder_catalystRegistration_enterPayload(auxDataHashBuilder);
-		auxDataHashBuilder_catalystRegistration_addVotingKey(
-		        auxDataHashBuilder, subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH
-		);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_KEY_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleVotingKey_ui_runStep();
-}
-
-// ============================== STAKING KEY ==============================
-
-enum {
-	HANDLE_STAKING_KEY_STEP_WARNING = 8300,
-	HANDLE_STAKING_KEY_STEP_DISPLAY,
-	HANDLE_STAKING_KEY_STEP_RESPOND,
-	HANDLE_STAKING_KEY_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleStakingKey_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleStakingKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_STAKING_KEY_STEP_WARNING) {
-		ui_displayPaginatedText(
-		        "Unusual request",
-		        "Proceed with care",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_STAKING_KEY_STEP_DISPLAY) {
-		ui_displayStakingKeyScreen(
-		        &subctx->stakingKeyPath,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_STAKING_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_STAKING_KEY_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleStakingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_STAKING_KEY);
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stakingKeyPath, SIZEOF(subctx->stakingKeyPath));
-	}
-	{
-		// parse input
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		view_skipBytes(
-		        &view,
-		        bip44_parseFromWire(&subctx->stakingKeyPath, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view))
-		);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationStakingKey(
-	                                   &subctx->stakingKeyPath
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		extendedPublicKey_t extStakingPubKey;
-		deriveExtendedPublicKey(&subctx->stakingKeyPath, &extStakingPubKey);
-		auxDataHashBuilder_catalystRegistration_addStakingKey(
-		        &AUX_DATA_CTX->auxDataHashBuilder, extStakingPubKey.pubKey, SIZEOF(extStakingPubKey.pubKey)
-		);
-	}
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_STAKING_KEY_STEP_WARNING);
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_STAKING_KEY_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_STAKING_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleStakingKey_ui_runStep();
-}
-
-// ============================== VOTING REWARDS ADDRESS ==============================
-
-enum {
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING = 8500,
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS,
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND,
-	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID
-};
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING) {
-		ui_displayPaginatedText(
-		        "Unusual request",
-		        "Proceed with care",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS) {
-		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
-		size_t addressSize = deriveAddress(
-		                             &subctx->stateData.votingRewardsAddressParams,
-		                             addressBuffer,
-		                             SIZEOF(addressBuffer)
-		                     );
-		ASSERT(addressSize > 0);
-		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
-
-		ui_displayAddressScreen(
-		        "Rewards go to",
-		        addressBuffer,
-		        addressSize,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleVotingRewardsAddressAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// safety checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(
-		        &subctx->stateData.votingRewardsAddressParams,
-		        SIZEOF(subctx->stateData.votingRewardsAddressParams)
-		);
-	}
-	{
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		view_parseAddressParams(&view, &subctx->stateData.votingRewardsAddressParams);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationVotingRewardsAddressParams(
-	                                   &subctx->stateData.votingRewardsAddressParams,
-	                                   commonTxData->networkId
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		ASSERT(isShelleyAddressType(subctx->stateData.votingRewardsAddressParams.type));
-		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
-		size_t addressSize = deriveAddress(
-		                             &subctx->stateData.votingRewardsAddressParams,
-		                             addressBuffer,
-		                             SIZEOF(addressBuffer)
-		                     );
-		ASSERT(addressSize > 0);
-		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
-
-		auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
-		        &AUX_DATA_CTX->auxDataHashBuilder, addressBuffer, addressSize
-		);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING);
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-
-		signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep();
-	}
-}
-
-// ============================== NONCE ==============================
-
-enum {
-	HANDLE_NONCE_STEP_DISPLAY = 8600,
-	HANDLE_NONCE_STEP_RESPOND,
-	HANDLE_NONCE_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleNonce_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleNonce_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_NONCE_STEP_DISPLAY) {
-		ui_displayUint64Screen(
-		        "Nonce",
-		        subctx->stateData.nonce,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_NONCE_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_NONCE_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleNonceAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// sanity checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_NONCE);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		VALIDATE(wireDataSize == 8, ERR_INVALID_DATA);
-		subctx->stateData.nonce = u8be_read(wireDataBuffer);
-		TRACE(
-		        "Catalyst registration nonce: %d",
-		        subctx->stateData.nonce
-		);
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationNonce();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		auxDataHashBuilder_catalystRegistration_addNonce(&AUX_DATA_CTX->auxDataHashBuilder, subctx->stateData.nonce);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NONCE_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NONCE_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleNonce_ui_runStep();
-}
-
-// ============================== CONFIRM ==============================
-
-enum {
-	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
-	HANDLE_CONFIRM_STEP_DISPLAY_HASH,
-	HANDLE_CONFIRM_STEP_RESPOND,
-	HANDLE_CONFIRM_STEP_INVALID,
-};
-
-static void signTxCatalystRegistration_handleConfirm_ui_runStep()
-{
-	catalyst_registration_context_t* subctx = accessSubContext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleConfirm_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
-		// confirming this means the signature being sent out of the device
-		// so we want to show it in non-expert mode too
-		ui_displayPrompt(
-		        "Confirm voting key",
-		        "registration?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_DISPLAY_HASH) {
-		if (!app_mode_expert()) {
-			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_RESPOND);
-		}
-		ui_displayHexBufferScreen(
-		        "Auxiliary data hash",
-		        subctx->auxDataHash,
-		        SIZEOF(subctx->auxDataHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
-		struct {
-			uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
-			uint8_t signature[ED25519_SIGNATURE_LENGTH];
-		} wireResponse = {0};
-
-		STATIC_ASSERT(SIZEOF(subctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong aux data hash length");
-		memmove(wireResponse.auxDataHash, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
-
-		STATIC_ASSERT(SIZEOF(subctx->stateData.registrationSignature) == ED25519_SIGNATURE_LENGTH, "Wrong Catalyst registration signature length");
-		memmove(wireResponse.signature, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
-
-		io_send_buf(SUCCESS, (uint8_t*) &wireResponse, SIZEOF(wireResponse));
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxCatalystRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
-{
-	{
-		//sanity checks
-		CHECK_STATE(STATE_CATALYST_REGISTRATION_CONFIRM);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	catalyst_registration_context_t* subctx = accessSubContext();
-	{
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-
-	{
-		// no data to receive
-		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForCatalystRegistrationConfirm();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
-		{
-			uint8_t votingPayloadHashBuffer[CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH] = {0};
-			auxDataHashBuilder_catalystRegistration_finalizePayload(auxDataHashBuilder, votingPayloadHashBuffer, AUX_DATA_HASH_LENGTH);
-			getCatalystVotingRegistrationSignature(
-			        &subctx->stakingKeyPath,
-			        votingPayloadHashBuffer, CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH,
-			        subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH
-			);
-		}
-		auxDataHashBuilder_catalystRegistration_addSignature(auxDataHashBuilder, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
-		auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(auxDataHashBuilder);
-
-		auxDataHashBuilder_finalize(auxDataHashBuilder, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxCatalystRegistration_handleConfirm_ui_runStep();
-}
-
-
-// ============================== main APDU handler ==============================
-
-enum {
-	APDU_INSTRUCTION_VOTING_KEY = 0x30,
-	APDU_INSTRUCTION_STAKING_KEY = 0x31,
-	APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS = 0x32,
-	APDU_INSTRUCTION_NONCE = 0x33,
-	APDU_INSTRUCTION_CONFIRM = 0x34
-};
-
-bool signTxCatalystRegistration_isValidInstruction(uint8_t p2)
-{
-	switch (p2) {
-	case APDU_INSTRUCTION_VOTING_KEY:
-	case APDU_INSTRUCTION_STAKING_KEY:
-	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
-	case APDU_INSTRUCTION_NONCE:
-	case APDU_INSTRUCTION_CONFIRM:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-
-	switch (p2) {
-	case APDU_INSTRUCTION_VOTING_KEY:
-		signTxCatalystRegistration_handleVotingKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_STAKING_KEY:
-		signTxCatalystRegistration_handleStakingKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
-		signTxCatalystRegistration_handleVotingRewardsAddressAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_NONCE:
-		signTxCatalystRegistration_handleNonceAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_CONFIRM:
-		signTxCatalystRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	default:
-		// this is not supposed to be called with invalid p2
-		ASSERT(false);
-	}
-}
+// #include "app_mode.h"
+// #include "signTxCatalystRegistration.h"
+// #include "state.h"
+// #include "uiHelpers.h"
+// #include "signTxUtils.h"
+// #include "uiScreens.h"
+// #include "auxDataHashBuilder.h"
+// #include "txHashBuilder.h"
+// #include "textUtils.h"
+// #include "bufView.h"
+// #include "securityPolicy.h"
+// #include "messageSigning.h"
+
+// static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
+
+// static inline catalyst_registration_context_t* accessSubContext()
+// {
+// 	return &AUX_DATA_CTX->stageContext.catalyst_registration_subctx;
+// }
+
+// bool signTxCatalystRegistration_isFinished()
+// {
+// 	const catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("Catalyst registration submachine state: %d", subctx->state);
+// 	// we are also asserting that the state is valid
+// 	switch (subctx->state) {
+// 	case STATE_CATALYST_REGISTRATION_FINISHED:
+// 		return true;
+
+// 	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
+// 	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
+// 	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
+// 	case STATE_CATALYST_REGISTRATION_NONCE:
+// 	case STATE_CATALYST_REGISTRATION_CONFIRM:
+// 		return false;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// void signTxCatalystRegistration_init()
+// {
+// 	explicit_bzero(&AUX_DATA_CTX->stageContext, SIZEOF(AUX_DATA_CTX->stageContext));
+// 	auxDataHashBuilder_init(&AUX_DATA_CTX->auxDataHashBuilder);
+
+// 	accessSubContext()->state = STATE_CATALYST_REGISTRATION_VOTING_KEY;
+// }
+
+// static inline void CHECK_STATE(sign_tx_catalyst_registration_state_t expected)
+// {
+// 	TRACE("Catalyst voting registration submachine state: current %d, expected %d", accessSubContext()->state, expected);
+// 	VALIDATE(accessSubContext()->state == expected, ERR_INVALID_STATE);
+// }
+
+// static inline void advanceState()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("Advancing Catalyst registration state from: %d", subctx->state);
+
+// 	switch (subctx->state) {
+
+// 	case STATE_CATALYST_REGISTRATION_VOTING_KEY:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_STAKING_KEY;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_STAKING_KEY:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_NONCE;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_NONCE:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_CONFIRM;
+// 		break;
+
+// 	case STATE_CATALYST_REGISTRATION_CONFIRM:
+// 		subctx->state = STATE_CATALYST_REGISTRATION_FINISHED;
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	TRACE("Advancing Catalyst registration state to: %d", subctx->state);
+// }
+
+// // ============================== VOTING KEY ==============================
+
+// enum {
+// 	HANDLE_VOTING_KEY_STEP_DISPLAY = 8200,
+// 	HANDLE_VOTING_KEY_STEP_RESPOND,
+// 	HANDLE_VOTING_KEY_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleVotingKey_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_VOTING_KEY_STEP_DISPLAY) {
+// 		STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
+
+// 		// Jormungandr public key, hence the "ed25519_pk" prefix
+// 		// https://github.com/input-output-hk/jormungandr/blob/a057af27493d823be02480bb20258c25ff979e2a/jormungandr-lib/src/crypto/key.rs#L126
+// 		ui_displayBech32Screen(
+// 		        "Voting public key",
+// 		        "ed25519_pk",
+// 		        subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_VOTING_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_VOTING_KEY_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleVotingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_KEY);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+// 	{
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		{
+// 			VALIDATE(wireDataSize == SIZEOF(subctx->stateData.votingPubKey), ERR_INVALID_DATA);
+// 			read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 			STATIC_ASSERT(SIZEOF(subctx->stateData.votingPubKey) == CATALYST_VOTING_PUBLIC_KEY_LENGTH, "wrong voting public key size");
+// 			view_parseBuffer(subctx->stateData.votingPubKey, &view, CATALYST_VOTING_PUBLIC_KEY_LENGTH);
+
+// 			VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 		}
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationVotingKey();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
+// 		auxDataHashBuilder_catalystRegistration_enter(auxDataHashBuilder);
+// 		auxDataHashBuilder_catalystRegistration_enterPayload(auxDataHashBuilder);
+// 		auxDataHashBuilder_catalystRegistration_addVotingKey(
+// 		        auxDataHashBuilder, subctx->stateData.votingPubKey, CATALYST_VOTING_PUBLIC_KEY_LENGTH
+// 		);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_KEY_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleVotingKey_ui_runStep();
+// }
+
+// // ============================== STAKING KEY ==============================
+
+// enum {
+// 	HANDLE_STAKING_KEY_STEP_WARNING = 8300,
+// 	HANDLE_STAKING_KEY_STEP_DISPLAY,
+// 	HANDLE_STAKING_KEY_STEP_RESPOND,
+// 	HANDLE_STAKING_KEY_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleStakingKey_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleStakingKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_STAKING_KEY_STEP_WARNING) {
+// 		ui_displayPaginatedText(
+// 		        "Unusual request",
+// 		        "Proceed with care",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_STAKING_KEY_STEP_DISPLAY) {
+// 		ui_displayStakingKeyScreen(
+// 		        &subctx->stakingKeyPath,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_STAKING_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_STAKING_KEY_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleStakingKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_STAKING_KEY);
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stakingKeyPath, SIZEOF(subctx->stakingKeyPath));
+// 	}
+// 	{
+// 		// parse input
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		view_skipBytes(
+// 		        &view,
+// 		        bip44_parseFromWire(&subctx->stakingKeyPath, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view))
+// 		);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationStakingKey(
+// 	                                   &subctx->stakingKeyPath
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		extendedPublicKey_t extStakingPubKey;
+// 		deriveExtendedPublicKey(&subctx->stakingKeyPath, &extStakingPubKey);
+// 		auxDataHashBuilder_catalystRegistration_addStakingKey(
+// 		        &AUX_DATA_CTX->auxDataHashBuilder, extStakingPubKey.pubKey, SIZEOF(extStakingPubKey.pubKey)
+// 		);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_STAKING_KEY_STEP_WARNING);
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_STAKING_KEY_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_STAKING_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleStakingKey_ui_runStep();
+// }
+
+// // ============================== VOTING REWARDS ADDRESS ==============================
+
+// enum {
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING = 8500,
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS,
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND,
+// 	HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID
+// };
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING) {
+// 		ui_displayPaginatedText(
+// 		        "Unusual request",
+// 		        "Proceed with care",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS) {
+// 		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
+// 		size_t addressSize = deriveAddress(
+// 		                             &subctx->stateData.votingRewardsAddressParams,
+// 		                             addressBuffer,
+// 		                             SIZEOF(addressBuffer)
+// 		                     );
+// 		ASSERT(addressSize > 0);
+// 		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
+
+// 		ui_displayAddressScreen(
+// 		        "Rewards go to",
+// 		        addressBuffer,
+// 		        addressSize,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleVotingRewardsAddressAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// safety checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(
+// 		        &subctx->stateData.votingRewardsAddressParams,
+// 		        SIZEOF(subctx->stateData.votingRewardsAddressParams)
+// 		);
+// 	}
+// 	{
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		view_parseAddressParams(&view, &subctx->stateData.votingRewardsAddressParams);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationVotingRewardsAddressParams(
+// 	                                   &subctx->stateData.votingRewardsAddressParams,
+// 	                                   commonTxData->networkId
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		ASSERT(isShelleyAddressType(subctx->stateData.votingRewardsAddressParams.type));
+// 		uint8_t addressBuffer[MAX_ADDRESS_SIZE] = {0};
+// 		size_t addressSize = deriveAddress(
+// 		                             &subctx->stateData.votingRewardsAddressParams,
+// 		                             addressBuffer,
+// 		                             SIZEOF(addressBuffer)
+// 		                     );
+// 		ASSERT(addressSize > 0);
+// 		ASSERT(addressSize < BUFFER_SIZE_PARANOIA);
+
+// 		auxDataHashBuilder_catalystRegistration_addVotingRewardsAddress(
+// 		        &AUX_DATA_CTX->auxDataHashBuilder, addressBuffer, addressSize
+// 		);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_WARN_UNUSUAL, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_WARNING);
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_DISPLAY_ADDRESS);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_VOTING_REWARDS_ADDRESS_PARAMS_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+
+// 		signTxCatalystRegistration_handleVotingRewardsAddress_addressParams_ui_runStep();
+// 	}
+// }
+
+// // ============================== NONCE ==============================
+
+// enum {
+// 	HANDLE_NONCE_STEP_DISPLAY = 8600,
+// 	HANDLE_NONCE_STEP_RESPOND,
+// 	HANDLE_NONCE_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleNonce_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleNonce_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_NONCE_STEP_DISPLAY) {
+// 		ui_displayUint64Screen(
+// 		        "Nonce",
+// 		        subctx->stateData.nonce,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_NONCE_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_NONCE_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleNonceAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_NONCE);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		VALIDATE(wireDataSize == 8, ERR_INVALID_DATA);
+// 		subctx->stateData.nonce = u8be_read(wireDataBuffer);
+// 		TRACE(
+// 		        "Catalyst registration nonce: %d",
+// 		        subctx->stateData.nonce
+// 		);
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationNonce();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		auxDataHashBuilder_catalystRegistration_addNonce(&AUX_DATA_CTX->auxDataHashBuilder, subctx->stateData.nonce);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NONCE_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NONCE_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleNonce_ui_runStep();
+// }
+
+// // ============================== CONFIRM ==============================
+
+// enum {
+// 	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
+// 	HANDLE_CONFIRM_STEP_DISPLAY_HASH,
+// 	HANDLE_CONFIRM_STEP_RESPOND,
+// 	HANDLE_CONFIRM_STEP_INVALID,
+// };
+
+// static void signTxCatalystRegistration_handleConfirm_ui_runStep()
+// {
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxCatalystRegistration_handleConfirm_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
+// 		// confirming this means the signature being sent out of the device
+// 		// so we want to show it in non-expert mode too
+// 		ui_displayPrompt(
+// 		        "Confirm voting key",
+// 		        "registration?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_DISPLAY_HASH) {
+// 		if (!app_mode_expert()) {
+// 			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_RESPOND);
+// 		}
+// 		ui_displayHexBufferScreen(
+// 		        "Auxiliary data hash",
+// 		        subctx->auxDataHash,
+// 		        SIZEOF(subctx->auxDataHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
+// 		struct {
+// 			uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
+// 			uint8_t signature[ED25519_SIGNATURE_LENGTH];
+// 		} wireResponse = {0};
+
+// 		STATIC_ASSERT(SIZEOF(subctx->auxDataHash) == AUX_DATA_HASH_LENGTH, "Wrong aux data hash length");
+// 		memmove(wireResponse.auxDataHash, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
+
+// 		STATIC_ASSERT(SIZEOF(subctx->stateData.registrationSignature) == ED25519_SIGNATURE_LENGTH, "Wrong Catalyst registration signature length");
+// 		memmove(wireResponse.signature, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
+
+// 		io_send_buf(SUCCESS, (uint8_t*) &wireResponse, SIZEOF(wireResponse));
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxCatalystRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
+// {
+// 	{
+// 		//sanity checks
+// 		CHECK_STATE(STATE_CATALYST_REGISTRATION_CONFIRM);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	catalyst_registration_context_t* subctx = accessSubContext();
+// 	{
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+
+// 	{
+// 		// no data to receive
+// 		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForCatalystRegistrationConfirm();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		aux_data_hash_builder_t* auxDataHashBuilder = &AUX_DATA_CTX->auxDataHashBuilder;
+// 		{
+// 			uint8_t votingPayloadHashBuffer[CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH] = {0};
+// 			auxDataHashBuilder_catalystRegistration_finalizePayload(auxDataHashBuilder, votingPayloadHashBuffer, AUX_DATA_HASH_LENGTH);
+// 			getCatalystVotingRegistrationSignature(
+// 			        &subctx->stakingKeyPath,
+// 			        votingPayloadHashBuffer, CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH,
+// 			        subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH
+// 			);
+// 		}
+// 		auxDataHashBuilder_catalystRegistration_addSignature(auxDataHashBuilder, subctx->stateData.registrationSignature, ED25519_SIGNATURE_LENGTH);
+// 		auxDataHashBuilder_catalystRegistration_addAuxiliaryScripts(auxDataHashBuilder);
+
+// 		auxDataHashBuilder_finalize(auxDataHashBuilder, subctx->auxDataHash, AUX_DATA_HASH_LENGTH);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxCatalystRegistration_handleConfirm_ui_runStep();
+// }
+
+
+// // ============================== main APDU handler ==============================
+
+// enum {
+// 	APDU_INSTRUCTION_VOTING_KEY = 0x30,
+// 	APDU_INSTRUCTION_STAKING_KEY = 0x31,
+// 	APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS = 0x32,
+// 	APDU_INSTRUCTION_NONCE = 0x33,
+// 	APDU_INSTRUCTION_CONFIRM = 0x34
+// };
+
+// bool signTxCatalystRegistration_isValidInstruction(uint8_t p2)
+// {
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_VOTING_KEY:
+// 	case APDU_INSTRUCTION_STAKING_KEY:
+// 	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
+// 	case APDU_INSTRUCTION_NONCE:
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		return true;
+
+// 	default:
+// 		return false;
+// 	}
+// }
+
+// void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_VOTING_KEY:
+// 		signTxCatalystRegistration_handleVotingKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_STAKING_KEY:
+// 		signTxCatalystRegistration_handleStakingKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_VOTING_REWARDS_ADDRESS:
+// 		signTxCatalystRegistration_handleVotingRewardsAddressAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_NONCE:
+// 		signTxCatalystRegistration_handleNonceAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		signTxCatalystRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	default:
+// 		// this is not supposed to be called with invalid p2
+// 		ASSERT(false);
+// 	}
+// }
diff --git a/src/signTxCatalystRegistration.h b/src/signTxCatalystRegistration.h
index 05c53f4..9968666 100644
--- a/src/signTxCatalystRegistration.h
+++ b/src/signTxCatalystRegistration.h
@@ -1,51 +1,51 @@
-#ifndef H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
-#define H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
-
-#include "common.h"
-#include "cardano.h"
-#include "auxDataHashBuilder.h"
-#include "addressUtilsShelley.h"
-
-
-#define CATALYST_VOTING_PUBLIC_KEY_LENGTH 32
-
-// SIGN_STAGE_AUX_DATA = 24
-// AUX_DATA_TYPE_CATALYST_REGISTRATION = 1
-typedef enum {
-	STATE_CATALYST_REGISTRATION_VOTING_KEY = 2410,
-	STATE_CATALYST_REGISTRATION_STAKING_KEY = 2411,
-	STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS = 2412,
-	STATE_CATALYST_REGISTRATION_NONCE = 2413,
-	STATE_CATALYST_REGISTRATION_CONFIRM = 2414,
-	STATE_CATALYST_REGISTRATION_FINISHED = 2415
-} sign_tx_catalyst_registration_state_t;
-
-typedef struct {
-	sign_tx_catalyst_registration_state_t state;
-	int ui_step;
-
-	/*
-	* Staking key path kept outside of stateData to produce the Catalyst registration
-	* signature at the end of the flow without re-requesting the staking key path
-	* (with the undesired side-effect of allowing signing with a different key than included
-	* in the registration payload)
-	*/
-	bip44_path_t stakingKeyPath;
-	uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
-
-	union {
-		uint8_t votingPubKey[CATALYST_VOTING_PUBLIC_KEY_LENGTH];
-		addressParams_t votingRewardsAddressParams;
-		uint64_t nonce;
-		uint8_t registrationSignature[ED25519_SIGNATURE_LENGTH];
-	} stateData;
-} catalyst_registration_context_t;
-
-void signTxCatalystRegistration_init();
-
-bool signTxCatalystRegistration_isValidInstruction(uint8_t p2);
-void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
-
-bool signTxCatalystRegistration_isFinished();
-
-#endif // H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
+// #ifndef H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
+// #define H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
+
+// #include "common.h"
+// #include "cardano.h"
+// #include "auxDataHashBuilder.h"
+// #include "addressUtilsShelley.h"
+
+
+// #define CATALYST_VOTING_PUBLIC_KEY_LENGTH 32
+
+// // SIGN_STAGE_AUX_DATA = 24
+// // AUX_DATA_TYPE_CATALYST_REGISTRATION = 1
+// typedef enum {
+// 	STATE_CATALYST_REGISTRATION_VOTING_KEY = 2410,
+// 	STATE_CATALYST_REGISTRATION_STAKING_KEY = 2411,
+// 	STATE_CATALYST_REGISTRATION_VOTING_REWARDS_ADDRESS = 2412,
+// 	STATE_CATALYST_REGISTRATION_NONCE = 2413,
+// 	STATE_CATALYST_REGISTRATION_CONFIRM = 2414,
+// 	STATE_CATALYST_REGISTRATION_FINISHED = 2415
+// } sign_tx_catalyst_registration_state_t;
+
+// typedef struct {
+// 	sign_tx_catalyst_registration_state_t state;
+// 	int ui_step;
+
+// 	/*
+// 	* Staking key path kept outside of stateData to produce the Catalyst registration
+// 	* signature at the end of the flow without re-requesting the staking key path
+// 	* (with the undesired side-effect of allowing signing with a different key than included
+// 	* in the registration payload)
+// 	*/
+// 	bip44_path_t stakingKeyPath;
+// 	uint8_t auxDataHash[AUX_DATA_HASH_LENGTH];
+
+// 	union {
+// 		uint8_t votingPubKey[CATALYST_VOTING_PUBLIC_KEY_LENGTH];
+// 		addressParams_t votingRewardsAddressParams;
+// 		uint64_t nonce;
+// 		uint8_t registrationSignature[ED25519_SIGNATURE_LENGTH];
+// 	} stateData;
+// } catalyst_registration_context_t;
+
+// void signTxCatalystRegistration_init();
+
+// bool signTxCatalystRegistration_isValidInstruction(uint8_t p2);
+// void signTxCatalystRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
+
+// bool signTxCatalystRegistration_isFinished();
+
+// #endif // H_CARDANO_APP_SIGN_TX_CATALYST_REGISTRATION
