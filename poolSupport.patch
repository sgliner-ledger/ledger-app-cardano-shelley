diff --git a/src/bip44.c b/src/bip44.c
index 8099ac0..e943cf2 100644
--- a/src/bip44.c
+++ b/src/bip44.c
@@ -11,7 +11,7 @@ static const uint32_t CARDANO_CHAIN_STAKING_KEY = 2;
 static const uint32_t MAX_REASONABLE_ACCOUNT = 100;
 static const uint32_t MAX_REASONABLE_ADDRESS = 1000000;
 
-static const uint32_t MAX_REASONABLE_COLD_KEY_INDEX = 1000000;
+// static const uint32_t MAX_REASONABLE_COLD_KEY_INDEX = 1000000;
 static const uint32_t MAX_REASONABLE_MINT_POLICY_INDEX = 1000000;
 
 
@@ -102,15 +102,15 @@ bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec)
 }
 
 // /1853'/1815'
-bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
-	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_POOL_COLD_KEY | HARDENED_BIP32));
-	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
-	return true;
-#undef CHECK
-}
+// bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
+// 	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_POOL_COLD_KEY | HARDENED_BIP32));
+// 	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
+// 	return true;
+// #undef CHECK
+// }
 
 // Account
 
@@ -131,11 +131,11 @@ uint32_t bip44_getMintPolicy(const bip44_path_t* pathSpec)
 	return pathSpec->path[BIP44_I_MINT_POLICY];
 }
 
-uint32_t bip44_getColdKeyIndex(const bip44_path_t* pathSpec)
-{
-	ASSERT(pathSpec->length > BIP44_I_POOL_COLD_KEY);
-	return pathSpec->path[BIP44_I_POOL_COLD_KEY];
-}
+// uint32_t bip44_getColdKeyIndex(const bip44_path_t* pathSpec)
+// {
+// 	ASSERT(pathSpec->length > BIP44_I_POOL_COLD_KEY);
+// 	return pathSpec->path[BIP44_I_POOL_COLD_KEY];
+// }
 
 bool bip44_hasReasonableAccount(const bip44_path_t* pathSpec)
 {
@@ -154,14 +154,14 @@ bool bip44_hasReasonableMintPolicy(const bip44_path_t* pathSpec)
 	return unharden(mintPolicyIndex) <= MAX_REASONABLE_MINT_POLICY_INDEX;
 }
 
-bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec)
-{
-	if (!bip44_isPoolColdKeyPath(pathSpec)) return false;
-	uint32_t coldKeyIndex = bip44_getColdKeyIndex(pathSpec);
+// bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec)
+// {
+// 	if (!bip44_isPoolColdKeyPath(pathSpec)) return false;
+// 	uint32_t coldKeyIndex = bip44_getColdKeyIndex(pathSpec);
 
-	if (!isHardened(coldKeyIndex)) return false;
-	return unharden(coldKeyIndex) <= MAX_REASONABLE_COLD_KEY_INDEX;
-}
+// 	if (!isHardened(coldKeyIndex)) return false;
+// 	return unharden(coldKeyIndex) <= MAX_REASONABLE_COLD_KEY_INDEX;
+// }
 
 // ChainType
 
@@ -255,16 +255,16 @@ bool bip44_isMintKeyPath(const bip44_path_t* pathSpec)
 #undef CHECK
 }
 
-bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length == BIP44_I_POOL_COLD_KEY + 1);
-	CHECK(bip44_hasPoolColdKeyPrefix(pathSpec));
-	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY_USECASE] == 0 + HARDENED_BIP32);
-	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY] >= HARDENED_BIP32);
-	return true;
-#undef CHECK
-}
+// bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length == BIP44_I_POOL_COLD_KEY + 1);
+// 	CHECK(bip44_hasPoolColdKeyPrefix(pathSpec));
+// 	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY_USECASE] == 0 + HARDENED_BIP32);
+// 	CHECK(pathSpec->path[BIP44_I_POOL_COLD_KEY] >= HARDENED_BIP32);
+// 	return true;
+// #undef CHECK
+// }
 
 bool bip44_containsMoreThanAddress(const bip44_path_t* pathSpec)
 {
@@ -421,13 +421,13 @@ bip44_path_type_t bip44_classifyPath(const bip44_path_t* pathSpec)
 		}
 	}
 
-	if (bip44_hasPoolColdKeyPrefix(pathSpec)) {
-		if (bip44_isPoolColdKeyPath(pathSpec)) {
-			return PATH_POOL_COLD_KEY;
-		} else {
-			return PATH_INVALID;
-		}
-	}
+	// if (bip44_hasPoolColdKeyPrefix(pathSpec)) {
+	// 	if (bip44_isPoolColdKeyPath(pathSpec)) {
+	// 		return PATH_POOL_COLD_KEY;
+	// 	} else {
+	// 		return PATH_INVALID;
+	// 	}
+	// }
 
 	return PATH_INVALID;
 }
@@ -453,8 +453,8 @@ bool bip44_isPathReasonable(const bip44_path_t* pathSpec)
 	case PATH_MINT_KEY:
 		return bip44_hasReasonableMintPolicy(pathSpec);
 
-	case PATH_POOL_COLD_KEY:
-		return bip44_hasReasonablePoolColdKeyIndex(pathSpec);
+	// case PATH_POOL_COLD_KEY:
+	// 	return bip44_hasReasonablePoolColdKeyIndex(pathSpec);
 
 	default:
 		// we are not supposed to call this for invalid paths
diff --git a/src/bip44.h b/src/bip44.h
index daff51f..791f0da 100644
--- a/src/bip44.h
+++ b/src/bip44.h
@@ -20,7 +20,7 @@ static const uint32_t PURPOSE_MULTISIG = 1854;
 
 static const uint32_t PURPOSE_MINT = 1855;
 
-static const uint32_t PURPOSE_POOL_COLD_KEY = 1853;
+// static const uint32_t PURPOSE_POOL_COLD_KEY = 1853;
 
 static const uint32_t ADA_COIN_TYPE = 1815;
 
@@ -48,8 +48,8 @@ enum {
 	BIP44_I_MINT_POLICY = 2,
 
 	// pool cold keys https://cips.cardano.org/cips/cip1853/
-	BIP44_I_POOL_COLD_KEY_USECASE = 2,
-	BIP44_I_POOL_COLD_KEY = 3,
+	// BIP44_I_POOL_COLD_KEY_USECASE = 2,
+	// BIP44_I_POOL_COLD_KEY = 3,
 };
 
 
@@ -58,7 +58,7 @@ bool bip44_hasShelleyPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasOrdinaryWalletKeyPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec);
-bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec);
+// bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec);
 
 bool bip44_containsAccount(const bip44_path_t* pathSpec);
 uint32_t bip44_getAccount(const bip44_path_t* pathSpec);
@@ -78,8 +78,8 @@ bool bip44_containsMoreThanAddress(const bip44_path_t* pathSpec);
 
 bool bip44_isMintKeyPath(const bip44_path_t* pathSpec);
 
-bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec);
-bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec);
+// bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec);
 
 bool isHardened(uint32_t value);
 uint32_t unharden(uint32_t value);
@@ -104,7 +104,7 @@ typedef enum {
 	PATH_MINT_KEY,
 
 	// pool cold key in pool registrations and retirements
-	PATH_POOL_COLD_KEY,
+	// PATH_POOL_COLD_KEY,
 
 	// none of the above
 	PATH_INVALID,
diff --git a/src/cardano.h b/src/cardano.h
index a314f72..401e652 100644
--- a/src/cardano.h
+++ b/src/cardano.h
@@ -18,7 +18,7 @@ STATIC_ASSERT(LOVELACE_MAX_SUPPLY < LOVELACE_INVALID, "bad LOVELACE_INVALID");
 #define VRF_KEY_HASH_LENGTH 32
 #define TX_HASH_LENGTH 32
 #define AUX_DATA_HASH_LENGTH 32
-#define POOL_METADATA_HASH_LENGTH 32
+// #define POOL_METADATA_HASH_LENGTH 32
 #define CATALYST_REGISTRATION_PAYLOAD_HASH_LENGTH 32
 #define ED25519_SIGNATURE_LENGTH 64
 #define SCRIPT_HASH_LENGTH 28
@@ -91,14 +91,14 @@ typedef struct {
 
 // ==============================  CERTIFICATES  ==============================
 
-#define POOL_METADATA_URL_LENGTH_MAX 64
-#define DNS_NAME_SIZE_MAX 64
+// #define POOL_METADATA_URL_LENGTH_MAX 64
+// #define DNS_NAME_SIZE_MAX 64
 
-#define IPV4_SIZE 4
-#define IPV6_SIZE 16
+// #define IPV4_SIZE 4
+// #define IPV6_SIZE 16
 
 // see the calculation in ui_displayMarginScreen() in uiScreens.c
-#define MARGIN_DENOMINATOR_MAX 1000000000000000ul // 10^15
+// #define MARGIN_DENOMINATOR_MAX 1000000000000000ul // 10^15
 
 // there may be other types we do not support
 typedef enum {
@@ -116,38 +116,38 @@ typedef enum {
 	STAKE_CREDENTIAL_SCRIPT_HASH = 1,
 } stake_credential_type_t;
 
-typedef enum {
-	RELAY_SINGLE_HOST_IP = 0,
-	RELAY_SINGLE_HOST_NAME = 1,
-	RELAY_MULTIPLE_HOST_NAME = 2
-} relay_format_t;
+// typedef enum {
+// 	RELAY_SINGLE_HOST_IP = 0,
+// 	RELAY_SINGLE_HOST_NAME = 1,
+// 	RELAY_MULTIPLE_HOST_NAME = 2
+// } relay_format_t;
 
-typedef struct {
-	bool isNull;
-	uint8_t ip[IPV4_SIZE];
-} ipv4_t;
+// typedef struct {
+// 	bool isNull;
+// 	uint8_t ip[IPV4_SIZE];
+// } ipv4_t;
 
-typedef struct {
-	bool isNull;
-	uint8_t ip[IPV6_SIZE];
-} ipv6_t;
+// typedef struct {
+// 	bool isNull;
+// 	uint8_t ip[IPV6_SIZE];
+// } ipv6_t;
 
-typedef struct {
-	bool isNull;
-	uint16_t number;
-} ipport_t;
+// typedef struct {
+// 	bool isNull;
+// 	uint16_t number;
+// } ipport_t;
 
-typedef struct {
-	relay_format_t format;
+// typedef struct {
+// 	relay_format_t format;
 
-	ipport_t port;
+// 	ipport_t port;
 
-	ipv4_t ipv4;
-	ipv6_t ipv6;
+// 	ipv4_t ipv4;
+// 	ipv6_t ipv6;
 
-	size_t dnsNameSize;
-	uint8_t dnsName[DNS_NAME_SIZE_MAX];
-} pool_relay_t;
+// 	size_t dnsNameSize;
+// 	uint8_t dnsName[DNS_NAME_SIZE_MAX];
+// } pool_relay_t;
 
 // ==============================  NATIVE SCRIPTS  ==============================
 
diff --git a/src/handlers.c b/src/handlers.c
index f591160..44f98df 100644
--- a/src/handlers.c
+++ b/src/handlers.c
@@ -12,7 +12,7 @@
 #include "deriveAddress.h"
 #include "deriveNativeScriptHash.h"
 #include "signTx.h"
-#include "signOpCert.h"
+// #include "signOpCert.h"
 
 // The APDU protocol uses a single-byte instruction code (INS) to specify
 // which command should be executed. We'll use this code to dispatch on a
@@ -32,7 +32,7 @@ handler_fn_t* lookupHandler(uint8_t ins)
 
 		// 0x2* -  signing related
 		CASE(0x21, signTx_handleAPDU);
-		CASE(0x22, signOpCert_handleAPDU);
+		// CASE(0x22, signOpCert_handleAPDU);
 
 		#ifdef DEVEL
 		// 0xF* -  debug_mode related
diff --git a/src/ipUtils.c b/src/ipUtils.c
index 2386ee2..3075340 100644
--- a/src/ipUtils.c
+++ b/src/ipUtils.c
@@ -1,161 +1,161 @@
-/*
- * Taken from glibc:
- * https://www.gnu.org/software/libc/sources.html
- * resolv/inet_ntop.c
- *
- * Modified by Vacuumlabs (2021).
- */
-
-/*
- * Copyright (c) 1996-1999 by Internet Software Consortium.
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
- * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
- * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
- * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- */
-
-#include "assert.h"
-#include "ipUtils.h"
-
-#define NS_IN6ADDRSZ 16 /*%< IPv6 T_AAAA */
-#define NS_INT16SZ 2 /*%< #/bytes of data in a uint16_t */
-
-/*
- * WARNING: Don't even consider trying to compile this on a system where
- * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
- */
-
-/*
- *	format an IPv4 address
- * return:
- *	`dst' (as a const)
- * notes:
- *	(1) uses no statics
- *	(2) takes a uint8_t* not an in_addr as input
- * author:
- *	Paul Vixie, 1996.
- */
-void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize)
-{
-
-	ASSERT(dstSize >= IPV4_STR_SIZE_MAX);
-
-	static const char fmt[] = "%u.%u.%u.%u";
-
-	snprintf(dst, dstSize, fmt, src[0], src[1], src[2], src[3]);
-
-	ASSERT(strlen(dst) + 1 < dstSize);
-}
-
-/*
- *	convert IPv6 binary address into presentation (printable) format
- * author:
- *	Paul Vixie, 1996.
- */
-void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize)
-{
-	STATIC_ASSERT(sizeof(size_t) >= 4, "bad size_t size");
-	STATIC_ASSERT(sizeof(unsigned int) >= 4, "bad unsigned int size");
-
-	/*
-	 * Note that int32_t and int16_t need only be "at least" large enough
-	 * to contain a value of the specified size.  On some systems, like
-	 * Crays, there is no such thing as an integer variable with 16 bits.
-	 * Keep this in mind if you think this function should have been coded
-	 * to use pointer overlays.  All the world's not a VAX.
-	 */
-	char tmp[IPV6_STR_SIZE_MAX] = {0};
-	struct {
-		int base, len;
-	} best, cur;
-	unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];
-
-	/*
-	 * Preprocess:
-	 *	Copy the input (bytewise) array into a wordwise array.
-	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
-	 */
-	memset(words, '\0', sizeof words);
-	for (int i = 0; i < NS_IN6ADDRSZ; i += 2) {
-		ASSERT((unsigned int)(i / 2) < SIZEOF(words));
-		words[i / 2] = (src[i] << 8) | src[i + 1];
-	}
-	best.base = -1;
-	cur.base = -1;
-	best.len = 0;
-	cur.len = 0;
-	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
-		ASSERT((unsigned int) i < SIZEOF(words));
-		if (words[i] == 0) {
-			if (cur.base == -1)
-				cur.base = i, cur.len = 1;
-			else
-				cur.len++;
-		} else {
-			if (cur.base != -1) {
-				if (best.base == -1 || cur.len > best.len)
-					best = cur;
-				cur.base = -1;
-			}
-		}
-	}
-	if (cur.base != -1) {
-		if (best.base == -1 || cur.len > best.len)
-			best = cur;
-	}
-	if (best.base != -1 && best.len < 2)
-		best.base = -1;
-
-	/*
-	 * Format the result.
-	 */
-	char* tp = tmp;
-	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
-		/* Are we inside the best run of 0x00's? */
-		if (best.base != -1 && i >= best.base &&
-		    i < (best.base + best.len)) {
-			if (i == best.base) {
-				ASSERT(tp < tmp + SIZEOF(tmp));
-				*tp++ = ':';
-			}
-			continue;
-		}
-		/* Are we following an initial run of 0x00s or any real hex? */
-		if (i != 0) {
-			ASSERT(tp < tmp + SIZEOF(tmp));
-			*tp++ = ':';
-		}
-		/* Is this address an encapsulated IPv4? */
-		if (i == 6 && best.base == 0 &&
-		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
-			inet_ntop4(src + 12, tp, sizeof tmp - (tp - tmp));
-			tp += strlen(tp);
-			break;
-		}
-		STATIC_ASSERT(sizeof(words[i]) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(words[i]), "signed type for %u");
-		snprintf(tp, sizeof tmp - (tp - tmp), "%x", words[i]);
-
-		tp += strlen(tp);
-	}
-	/* Was it a trailing run of 0x00's? */
-	if (best.base != -1 && (best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ)) {
-		ASSERT(tp < tmp + SIZEOF(tmp));
-		*tp++ = ':';
-	}
-	ASSERT(tp < tmp + SIZEOF(tmp));
-	*tp++ = '\0';
-
-	ASSERT(strlen(tmp) + 1 < dstSize);
-
-	strncpy(dst, tmp, dstSize);
-}
+// /*
+//  * Taken from glibc:
+//  * https://www.gnu.org/software/libc/sources.html
+//  * resolv/inet_ntop.c
+//  *
+//  * Modified by Vacuumlabs (2021).
+//  */
+
+// /*
+//  * Copyright (c) 1996-1999 by Internet Software Consortium.
+//  *
+//  * Permission to use, copy, modify, and distribute this software for any
+//  * purpose with or without fee is hereby granted, provided that the above
+//  * copyright notice and this permission notice appear in all copies.
+//  *
+//  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+//  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+//  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+//  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+//  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+//  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+//  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+//  * SOFTWARE.
+//  */
+
+// #include "assert.h"
+// #include "ipUtils.h"
+
+// #define NS_IN6ADDRSZ 16 /*%< IPv6 T_AAAA */
+// #define NS_INT16SZ 2 /*%< #/bytes of data in a uint16_t */
+
+// /*
+//  * WARNING: Don't even consider trying to compile this on a system where
+//  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
+//  */
+
+// /*
+//  *	format an IPv4 address
+//  * return:
+//  *	`dst' (as a const)
+//  * notes:
+//  *	(1) uses no statics
+//  *	(2) takes a uint8_t* not an in_addr as input
+//  * author:
+//  *	Paul Vixie, 1996.
+//  */
+// void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize)
+// {
+
+// 	ASSERT(dstSize >= IPV4_STR_SIZE_MAX);
+
+// 	static const char fmt[] = "%u.%u.%u.%u";
+
+// 	snprintf(dst, dstSize, fmt, src[0], src[1], src[2], src[3]);
+
+// 	ASSERT(strlen(dst) + 1 < dstSize);
+// }
+
+// /*
+//  *	convert IPv6 binary address into presentation (printable) format
+//  * author:
+//  *	Paul Vixie, 1996.
+//  */
+// void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize)
+// {
+// 	STATIC_ASSERT(sizeof(size_t) >= 4, "bad size_t size");
+// 	STATIC_ASSERT(sizeof(unsigned int) >= 4, "bad unsigned int size");
+
+// 	/*
+// 	 * Note that int32_t and int16_t need only be "at least" large enough
+// 	 * to contain a value of the specified size.  On some systems, like
+// 	 * Crays, there is no such thing as an integer variable with 16 bits.
+// 	 * Keep this in mind if you think this function should have been coded
+// 	 * to use pointer overlays.  All the world's not a VAX.
+// 	 */
+// 	char tmp[IPV6_STR_SIZE_MAX] = {0};
+// 	struct {
+// 		int base, len;
+// 	} best, cur;
+// 	unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];
+
+// 	/*
+// 	 * Preprocess:
+// 	 *	Copy the input (bytewise) array into a wordwise array.
+// 	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
+// 	 */
+// 	memset(words, '\0', sizeof words);
+// 	for (int i = 0; i < NS_IN6ADDRSZ; i += 2) {
+// 		ASSERT((unsigned int)(i / 2) < SIZEOF(words));
+// 		words[i / 2] = (src[i] << 8) | src[i + 1];
+// 	}
+// 	best.base = -1;
+// 	cur.base = -1;
+// 	best.len = 0;
+// 	cur.len = 0;
+// 	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+// 		ASSERT((unsigned int) i < SIZEOF(words));
+// 		if (words[i] == 0) {
+// 			if (cur.base == -1)
+// 				cur.base = i, cur.len = 1;
+// 			else
+// 				cur.len++;
+// 		} else {
+// 			if (cur.base != -1) {
+// 				if (best.base == -1 || cur.len > best.len)
+// 					best = cur;
+// 				cur.base = -1;
+// 			}
+// 		}
+// 	}
+// 	if (cur.base != -1) {
+// 		if (best.base == -1 || cur.len > best.len)
+// 			best = cur;
+// 	}
+// 	if (best.base != -1 && best.len < 2)
+// 		best.base = -1;
+
+// 	/*
+// 	 * Format the result.
+// 	 */
+// 	char* tp = tmp;
+// 	for (int i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+// 		/* Are we inside the best run of 0x00's? */
+// 		if (best.base != -1 && i >= best.base &&
+// 		    i < (best.base + best.len)) {
+// 			if (i == best.base) {
+// 				ASSERT(tp < tmp + SIZEOF(tmp));
+// 				*tp++ = ':';
+// 			}
+// 			continue;
+// 		}
+// 		/* Are we following an initial run of 0x00s or any real hex? */
+// 		if (i != 0) {
+// 			ASSERT(tp < tmp + SIZEOF(tmp));
+// 			*tp++ = ':';
+// 		}
+// 		/* Is this address an encapsulated IPv4? */
+// 		if (i == 6 && best.base == 0 &&
+// 		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
+// 			inet_ntop4(src + 12, tp, sizeof tmp - (tp - tmp));
+// 			tp += strlen(tp);
+// 			break;
+// 		}
+// 		STATIC_ASSERT(sizeof(words[i]) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(words[i]), "signed type for %u");
+// 		snprintf(tp, sizeof tmp - (tp - tmp), "%x", words[i]);
+
+// 		tp += strlen(tp);
+// 	}
+// 	/* Was it a trailing run of 0x00's? */
+// 	if (best.base != -1 && (best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ)) {
+// 		ASSERT(tp < tmp + SIZEOF(tmp));
+// 		*tp++ = ':';
+// 	}
+// 	ASSERT(tp < tmp + SIZEOF(tmp));
+// 	*tp++ = '\0';
+
+// 	ASSERT(strlen(tmp) + 1 < dstSize);
+
+// 	strncpy(dst, tmp, dstSize);
+// }
diff --git a/src/ipUtils.h b/src/ipUtils.h
index ffa0862..90da88f 100644
--- a/src/ipUtils.h
+++ b/src/ipUtils.h
@@ -1,16 +1,16 @@
-#ifndef H_CARDANO_APP_IP_UTILS
-#define H_CARDANO_APP_IP_UTILS
+// #ifndef H_CARDANO_APP_IP_UTILS
+// #define H_CARDANO_APP_IP_UTILS
 
-#include "os.h"
+// #include "os.h"
 
-#define IPV4_STR_SIZE_MAX (sizeof "255.255.255.255")
-#define IPV6_STR_SIZE_MAX (sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")
+// #define IPV4_STR_SIZE_MAX (sizeof "255.255.255.255")
+// #define IPV6_STR_SIZE_MAX (sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")
 
-void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize);
-void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize);
+// void inet_ntop4 (const uint8_t *src, char *dst, size_t dstSize);
+// void inet_ntop6 (const uint8_t *src, char *dst, size_t dstSize);
 
-#ifdef DEVEL
-void run_ipUtils_test();
-#endif // DEVEL
+// #ifdef DEVEL
+// void run_ipUtils_test();
+// #endif // DEVEL
 
-#endif  // H_CARDANO_APP_SIGN_TX_UTILS
+// #endif  // H_CARDANO_APP_SIGN_TX_UTILS
diff --git a/src/messageSigning.c b/src/messageSigning.c
index 006eb69..c439255 100644
--- a/src/messageSigning.c
+++ b/src/messageSigning.c
@@ -86,13 +86,13 @@ void getCatalystVotingRegistrationSignature(bip44_path_t* pathSpec,
 	#endif
 }
 
-void getOpCertSignature(bip44_path_t* pathSpec,
-                        const uint8_t* opCertBodyBuffer, size_t opCertBodySize,
-                        uint8_t* outBuffer, size_t outSize)
-{
-	ASSERT(bip44_isPoolColdKeyPath(pathSpec));
-	ASSERT(opCertBodySize == OP_CERT_BODY_LENGTH);
-	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
+// void getOpCertSignature(bip44_path_t* pathSpec,
+//                         const uint8_t* opCertBodyBuffer, size_t opCertBodySize,
+//                         uint8_t* outBuffer, size_t outSize)
+// {
+// 	ASSERT(bip44_isPoolColdKeyPath(pathSpec));
+// 	ASSERT(opCertBodySize == OP_CERT_BODY_LENGTH);
+// 	ASSERT(outSize < BUFFER_SIZE_PARANOIA);
 
-	signRawMessageWithPath(pathSpec, opCertBodyBuffer, opCertBodySize, outBuffer, outSize);
-}
+// 	signRawMessageWithPath(pathSpec, opCertBodyBuffer, opCertBodySize, outBuffer, outSize);
+// }
diff --git a/src/securityPolicy.c b/src/securityPolicy.c
index 1be5402..4eb366d 100644
--- a/src/securityPolicy.c
+++ b/src/securityPolicy.c
@@ -86,7 +86,7 @@ security_policy_t policyForDerivePrivateKey(const bip44_path_t* path)
 
 	case PATH_MINT_KEY:
 
-	case PATH_POOL_COLD_KEY:
+	// case PATH_POOL_COLD_KEY:
 
 		ALLOW();
 		break;
@@ -131,7 +131,7 @@ security_policy_t policyForGetExtendedPublicKey(const bip44_path_t* pathSpec)
 	case PATH_MULTISIG_SPENDING_KEY:
 	case PATH_MULTISIG_STAKING_KEY:
 	case PATH_MINT_KEY:
-	case PATH_POOL_COLD_KEY:
+	// case PATH_POOL_COLD_KEY:
 		WARN_UNLESS(bip44_isPathReasonable(pathSpec));
 		// ask for permission
 		PROMPT();
@@ -162,11 +162,11 @@ security_policy_t policyForGetExtendedPublicKeyBulkExport(const bip44_path_t* pa
 		ALLOW();
 		break;
 
-	case PATH_POOL_COLD_KEY:
-		WARN_UNLESS(bip44_isPathReasonable(pathSpec));
-		// but ask for permission when pool cold key is requested
-		PROMPT();
-		break;
+	// case PATH_POOL_COLD_KEY:
+	// 	WARN_UNLESS(bip44_isPathReasonable(pathSpec));
+	// 	// but ask for permission when pool cold key is requested
+	// 	PROMPT();
+	// 	break;
 
 	default:
 		DENY();
@@ -269,10 +269,10 @@ bool isTxNetworkIdVerifiable(
 
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// pool registration certificate contains pool reward account
-		return true;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// pool registration certificate contains pool reward account
+	// 	return true;
 
 	default:
 		return false;
@@ -302,11 +302,11 @@ security_policy_t policyForSignTxInit(
         uint32_t networkId,
         uint32_t protocolMagic,
         uint16_t numOutputs,
-        uint16_t numCertificates,
+        // uint16_t numCertificates,
         uint16_t numWithdrawals,
-        bool includeMint,
+        // bool includeMint,
         uint16_t numCollaterals,
-        uint16_t numRequiredSigners,
+        // uint16_t numRequiredSigners,
         bool includeScriptDataHash,
         bool includeNetworkId
 )
@@ -320,24 +320,24 @@ security_policy_t policyForSignTxInit(
 	// mostly because of potential cross-witnessing
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// necessary to avoid intermingling witnesses from several certs
-		DENY_UNLESS(numCertificates == 1);
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// necessary to avoid intermingling witnesses from several certs
+	// 	DENY_UNLESS(numCertificates == 1);
 
-		// witnesses for owners and withdrawals are the same
-		// we forbid withdrawals so that users cannot be tricked into witnessing
-		// something unintentionally (e.g. an owner given by the staking key hash)
-		DENY_UNLESS(numWithdrawals == 0);
+	// 	// witnesses for owners and withdrawals are the same
+	// 	// we forbid withdrawals so that users cannot be tricked into witnessing
+	// 	// something unintentionally (e.g. an owner given by the staking key hash)
+	// 	DENY_UNLESS(numWithdrawals == 0);
 
-		// mint must not be combined with pool registration certificates
-		DENY_IF(includeMint);
+	// 	// mint must not be combined with pool registration certificates
+	// 	DENY_IF(includeMint);
 
-		// no Plutus elements for pool registrations
-		DENY_IF(includeScriptDataHash);
-		DENY_IF(numCollaterals > 0);
-		DENY_IF(numRequiredSigners > 0);
-		break;
+	// 	// no Plutus elements for pool registrations
+	// 	DENY_IF(includeScriptDataHash);
+	// 	DENY_IF(numCollaterals > 0);
+	// 	DENY_IF(numRequiredSigners > 0);
+	// 	break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
@@ -386,8 +386,8 @@ security_policy_t policyForSignTxInput(sign_tx_signingmode_t txSigningMode)
 		break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		// inputs are not interesting for the user (transferred funds are shown in the outputs)
 		ALLOW();
@@ -447,15 +447,15 @@ security_policy_t policyForSignTxOutputAddressBytes(
 
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// all the funds are provided by the operator
-		// and thus outputs are irrelevant to the owner (even those having tokens or datum hash)
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// all the funds are provided by the operator
+	// 	// and thus outputs are irrelevant to the owner (even those having tokens or datum hash)
+	// 	ALLOW();
+	// 	break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		// utxo on a Plutus script address without datum hash is unspendable
 		// but we can't DENY because it is valid for native scripts
@@ -529,7 +529,7 @@ security_policy_t policyForSignTxOutputAddressParams(
 
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX: {
 		// unusual paths or spending and staking path mismatch
 		SHOW_UNLESS(is_standard_base_address(params));
@@ -559,13 +559,13 @@ security_policy_t policyForSignTxOutputAddressParams(
 		break;
 	}
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER: {
-		// we forbid these to avoid leaking information
-		// (since the outputs are not shown, the user is unaware of what addresses are being derived)
-		// it also makes the tx signing faster if all outputs are given as addresses
-		DENY();
-		break;
-	}
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER: {
+	// 	// we forbid these to avoid leaking information
+	// 	// (since the outputs are not shown, the user is unaware of what addresses are being derived)
+	// 	// it also makes the tx signing faster if all outputs are given as addresses
+	// 	DENY();
+	// 	break;
+	// }
 
 	default:
 		ASSERT(false);
@@ -637,7 +637,7 @@ security_policy_t policyForSignTxFee(
 {
 	switch (txSigningMode) {
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
@@ -645,10 +645,10 @@ security_policy_t policyForSignTxFee(
 		SHOW();
 		break;
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// fees are paid by the operator and are thus irrelevant for owners
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// fees are paid by the operator and are thus irrelevant for owners
+	// 	ALLOW();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -688,12 +688,12 @@ security_policy_t policyForSignTxCertificate(
 		ALLOW();
 		break;
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// only pool registration is allowed
-		DENY_UNLESS(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	// only pool registration is allowed
+	// 	DENY_UNLESS(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
+	// 	ALLOW();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -787,199 +787,199 @@ security_policy_t policyForSignTxCertificateStaking(
 	DENY(); // should not be reached
 }
 
-security_policy_t policyForSignTxCertificateStakePoolRetirement(
-        sign_tx_signingmode_t txSigningMode,
-        const bip44_path_t* poolIdPath,
-        uint64_t epoch MARK_UNUSED
-)
-{
-	switch (txSigningMode) {
-
-	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-		// pool retirement may only be present in ORDINARY_TX signing mode
-		// the path hash should be a valid pool cold key path
-		DENY_UNLESS(bip44_isPoolColdKeyPath(poolIdPath));
-		PROMPT();
-		break;
-
-	default:
-		// in other signing modes, the tx containing pool retirement certificate
-		// should have already been reported as invalid
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationInit(
-        sign_tx_signingmode_t txSigningMode,
-        uint32_t numOwners
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// there should be exactly one owner given by path for which we provide a witness
-		DENY_IF(numOwners == 0);
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
-		DENY();
-		break;
-
-	default:
-		ASSERT(false);
-		break;
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationPoolId(
-        sign_tx_signingmode_t txSigningMode,
-        const pool_id_t* poolId
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// owner should see a hash
-		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_HASH);
-		SHOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		// operator should see a path
-		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_PATH);
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
-        sign_tx_signingmode_t txSigningMode
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// not interesting for an owner
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
-        sign_tx_signingmode_t txSigningMode,
-        const reward_account_t* poolRewardAccount MARK_UNUSED
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationOwner(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_owner_t* owner,
-        uint32_t numOwnersGivenByPath
-)
-{
-	if (owner->keyReferenceType == KEY_REFERENCE_PATH) {
-		// when path is present, it should be a valid staking path
-		DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(&owner->path));
-		DENY_IF(violatesSingleAccountOrStoreIt(&owner->path));
-	}
-
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// can be 0 while processing owners given by hash
-		// or if no path owner is given at all (then we just compute the tx hash and don't allow witnesses)
-		DENY_UNLESS(numOwnersGivenByPath <= 1);
-		SHOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		// operator should receive owners given by hash
-		ASSERT(numOwnersGivenByPath == 0);
-		DENY_UNLESS(owner->keyReferenceType == KEY_REFERENCE_HASH);
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationRelay(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_relay_t* relay MARK_UNUSED
-)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		// not interesting for an owner
-		ALLOW();
-		break;
-
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		SHOW();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationMetadata()
-{
-	SHOW();
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationNoMetadata()
-{
-	SHOW();
-}
-
-security_policy_t policyForSignTxStakePoolRegistrationConfirm(
-        uint32_t numOwners, uint32_t numRelays
-)
-{
-	// notify the user if there are no owners and/or relays
-	PROMPT_IF(numOwners == 0);
-	PROMPT_IF(numRelays == 0);
-
-	ALLOW();
-}
+// security_policy_t policyForSignTxCertificateStakePoolRetirement(
+//         sign_tx_signingmode_t txSigningMode,
+//         const bip44_path_t* poolIdPath,
+//         uint64_t epoch MARK_UNUSED
+// )
+// {
+// 	switch (txSigningMode) {
+
+// 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
+// 		// pool retirement may only be present in ORDINARY_TX signing mode
+// 		// the path hash should be a valid pool cold key path
+// 		DENY_UNLESS(bip44_isPoolColdKeyPath(poolIdPath));
+// 		PROMPT();
+// 		break;
+
+// 	default:
+// 		// in other signing modes, the tx containing pool retirement certificate
+// 		// should have already been reported as invalid
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationInit(
+//         sign_tx_signingmode_t txSigningMode,
+//         uint32_t numOwners
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// there should be exactly one owner given by path for which we provide a witness
+// 		DENY_IF(numOwners == 0);
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
+// 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+// 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
+// 		DENY();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 		break;
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationPoolId(
+//         sign_tx_signingmode_t txSigningMode,
+//         const pool_id_t* poolId
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// owner should see a hash
+// 		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_HASH);
+// 		SHOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		// operator should see a path
+// 		DENY_UNLESS(poolId->keyReferenceType == KEY_REFERENCE_PATH);
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
+//         sign_tx_signingmode_t txSigningMode
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// not interesting for an owner
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
+//         sign_tx_signingmode_t txSigningMode,
+//         const reward_account_t* poolRewardAccount MARK_UNUSED
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationOwner(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_owner_t* owner,
+//         uint32_t numOwnersGivenByPath
+// )
+// {
+// 	if (owner->keyReferenceType == KEY_REFERENCE_PATH) {
+// 		// when path is present, it should be a valid staking path
+// 		DENY_UNLESS(bip44_isOrdinaryStakingKeyPath(&owner->path));
+// 		DENY_IF(violatesSingleAccountOrStoreIt(&owner->path));
+// 	}
+
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// can be 0 while processing owners given by hash
+// 		// or if no path owner is given at all (then we just compute the tx hash and don't allow witnesses)
+// 		DENY_UNLESS(numOwnersGivenByPath <= 1);
+// 		SHOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		// operator should receive owners given by hash
+// 		ASSERT(numOwnersGivenByPath == 0);
+// 		DENY_UNLESS(owner->keyReferenceType == KEY_REFERENCE_HASH);
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationRelay(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_relay_t* relay MARK_UNUSED
+// )
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 		// not interesting for an owner
+// 		ALLOW();
+// 		break;
+
+// 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationMetadata()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationNoMetadata()
+// {
+// 	SHOW();
+// }
+
+// security_policy_t policyForSignTxStakePoolRegistrationConfirm(
+//         uint32_t numOwners, uint32_t numRelays
+// )
+// {
+// 	// notify the user if there are no owners and/or relays
+// 	PROMPT_IF(numOwners == 0);
+// 	PROMPT_IF(numRelays == 0);
+
+// 	ALLOW();
+// }
 
 // For each withdrawal
 security_policy_t policyForSignTxWithdrawal(
@@ -1081,12 +1081,12 @@ static inline security_policy_t _ordinaryWitnessPolicy(const bip44_path_t* path,
 		ALLOW();
 		break;
 
-	case PATH_POOL_COLD_KEY:
-		// ordinary key paths and pool cold key paths can be hidden if they are not unusual
-		// (the user saw all outputs, withdrawals and pool certificates and they all belong to him)
-		WARN_UNLESS(bip44_isPathReasonable(path));
-		SHOW();
-		break;
+	// case PATH_POOL_COLD_KEY:
+	// 	// ordinary key paths and pool cold key paths can be hidden if they are not unusual
+	// 	// (the user saw all outputs, withdrawals and pool certificates and they all belong to him)
+	// 	WARN_UNLESS(bip44_isPathReasonable(path));
+	// 	SHOW();
+	// 	break;
 
 	case PATH_MINT_KEY:
 		DENY_UNLESS(mintPresent);
@@ -1149,54 +1149,54 @@ static inline security_policy_t _plutusWitnessPolicy(const bip44_path_t* path, b
 		SHOW();
 		break;
 
-	case PATH_POOL_COLD_KEY:
+	// case PATH_POOL_COLD_KEY:
 	default:
 		DENY();
 		break;
 	}
 }
 
-static inline security_policy_t _poolRegistrationOwnerWitnessPolicy(const bip44_path_t* witnessPath, const bip44_path_t* poolOwnerPath)
-{
-	switch (bip44_classifyPath(witnessPath)) {
-
-	case PATH_ORDINARY_STAKING_KEY:
-		if (poolOwnerPath != NULL) {
-			// an owner was given by path
-			// the witness path must be identical
-			DENY_UNLESS(bip44_pathsEqual(witnessPath, poolOwnerPath));
-		} else {
-			// no owner was given by path
-			// we must not allow witnesses because they might witness owners given by key hash
-			DENY();
-		}
-		WARN_UNLESS(bip44_isPathReasonable(witnessPath));
-		SHOW();
-		break;
-
-	default:
-		DENY();
-		break;
-	}
-}
-
-static inline security_policy_t _poolRegistrationOperatorWitnessPolicy(const bip44_path_t* path)
-{
-	switch (bip44_classifyPath(path)) {
-
-	case PATH_ORDINARY_SPENDING_KEY:
-	case PATH_POOL_COLD_KEY:
-		// only ordinary spending key paths (because of inputs) and pool cold key path are allowed
-		WARN_UNLESS(bip44_isPathReasonable(path));
-		// TODO is there a reason to show the witnesses?
-		SHOW();
-		break;
-
-	default:
-		DENY();
-		break;
-	}
-}
+// static inline security_policy_t _poolRegistrationOwnerWitnessPolicy(const bip44_path_t* witnessPath, const bip44_path_t* poolOwnerPath)
+// {
+// 	switch (bip44_classifyPath(witnessPath)) {
+
+// 	case PATH_ORDINARY_STAKING_KEY:
+// 		if (poolOwnerPath != NULL) {
+// 			// an owner was given by path
+// 			// the witness path must be identical
+// 			DENY_UNLESS(bip44_pathsEqual(witnessPath, poolOwnerPath));
+// 		} else {
+// 			// no owner was given by path
+// 			// we must not allow witnesses because they might witness owners given by key hash
+// 			DENY();
+// 		}
+// 		WARN_UNLESS(bip44_isPathReasonable(witnessPath));
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		DENY();
+// 		break;
+// 	}
+// }
+
+// static inline security_policy_t _poolRegistrationOperatorWitnessPolicy(const bip44_path_t* path)
+// {
+// 	switch (bip44_classifyPath(path)) {
+
+// 	case PATH_ORDINARY_SPENDING_KEY:
+// 	case PATH_POOL_COLD_KEY:
+// 		// only ordinary spending key paths (because of inputs) and pool cold key path are allowed
+// 		WARN_UNLESS(bip44_isPathReasonable(path));
+// 		// TODO is there a reason to show the witnesses?
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		DENY();
+// 		break;
+// 	}
+// }
 
 // For each transaction witness
 // Note: witnesses reveal public key of an address and Ledger *does not* check
@@ -1204,8 +1204,8 @@ static inline security_policy_t _poolRegistrationOperatorWitnessPolicy(const bip
 security_policy_t policyForSignTxWitness(
         sign_tx_signingmode_t txSigningMode,
         const bip44_path_t* witnessPath,
-        bool mintPresent,
-        const bip44_path_t* poolOwnerPath
+        bool mintPresent
+        // const bip44_path_t* poolOwnerPath
 )
 {
 	switch (txSigningMode) {
@@ -1218,11 +1218,11 @@ security_policy_t policyForSignTxWitness(
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		return _plutusWitnessPolicy(witnessPath, mintPresent);
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		return _poolRegistrationOwnerWitnessPolicy(witnessPath, poolOwnerPath);
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	return _poolRegistrationOwnerWitnessPolicy(witnessPath, poolOwnerPath);
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		return _poolRegistrationOperatorWitnessPolicy(witnessPath);
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// 	return _poolRegistrationOperatorWitnessPolicy(witnessPath);
 
 	default:
 		ASSERT(false);
@@ -1311,10 +1311,10 @@ security_policy_t policyForSignTxScriptDataHash(const sign_tx_signingmode_t txSi
 		ALLOW();
 		break;
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		DENY();
-		break;
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// 	DENY();
+	// 	break;
 
 	default:
 		ASSERT(false);
@@ -1338,8 +1338,8 @@ security_policy_t policyForSignTxCollateral(const sign_tx_signingmode_t txSignin
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 		// collaterals allowed only if Plutus script is to be executed
 		DENY();
 		break;
@@ -1456,22 +1456,22 @@ security_policy_t policyForCatalystRegistrationConfirm()
 	PROMPT();
 }
 
-security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec)
-{
-	switch (bip44_classifyPath(poolColdKeyPathSpec)) {
-
-	case PATH_POOL_COLD_KEY:
-		if (bip44_isPathReasonable(poolColdKeyPathSpec)) {
-			PROMPT();
-		} else {
-			WARN();
-		}
-		break;
-
-	default:
-		DENY();
-		break;
-	}
-
-	DENY(); // should not be reached
-}
+// security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec)
+// {
+// 	switch (bip44_classifyPath(poolColdKeyPathSpec)) {
+
+// 	case PATH_POOL_COLD_KEY:
+// 		if (bip44_isPathReasonable(poolColdKeyPathSpec)) {
+// 			PROMPT();
+// 		} else {
+// 			WARN();
+// 		}
+// 		break;
+
+// 	default:
+// 		DENY();
+// 		break;
+// 	}
+
+// 	DENY(); // should not be reached
+// }
diff --git a/src/securityPolicy.h b/src/securityPolicy.h
index 48cba45..5cb9227 100644
--- a/src/securityPolicy.h
+++ b/src/securityPolicy.h
@@ -5,7 +5,7 @@
 #include "bip44.h"
 #include "cardano.h"
 #include "securityPolicyType.h"
-#include "signTxPoolRegistration.h"
+// #include "signTxPoolRegistration.h"
 #include "signTxAuxData.h"
 #include "signTx.h"
 
@@ -34,11 +34,11 @@ security_policy_t policyForSignTxInit(
         uint32_t networkId,
         uint32_t protocolMagic,
         uint16_t numOutputs,
-        uint16_t numCertificates,
+        // uint16_t numCertificates,
         uint16_t numWithdrawals,
-        bool includeMint,
+        // bool includeMint,
         uint16_t numCollaterals,
-        uint16_t numRequiredSigners,
+        // uint16_t numRequiredSigners,
         bool includeScriptDataHash,
         bool includeNetworkId
 );
@@ -78,40 +78,40 @@ security_policy_t policyForSignTxCertificateStaking(
         const certificate_type_t certificateType,
         const stake_credential_t* stakeCredential
 );
-security_policy_t policyForSignTxCertificateStakePoolRetirement(
-        sign_tx_signingmode_t txSigningMode,
-        const bip44_path_t* stakeCredential,
-        uint64_t epoch
-);
-security_policy_t policyForSignTxStakePoolRegistrationInit(
-        sign_tx_signingmode_t txSigningMode,
-        uint32_t numOwners
-);
-security_policy_t policyForSignTxStakePoolRegistrationPoolId(
-        sign_tx_signingmode_t txSigningMode,
-        const pool_id_t* poolId
-);
-security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
-        sign_tx_signingmode_t txSigningMode
-);
-security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
-        sign_tx_signingmode_t txSigningMode,
-        const reward_account_t* poolRewardAccount
-);
-security_policy_t policyForSignTxStakePoolRegistrationOwner(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_owner_t* owner,
-        uint32_t numOwnersGivenByPath
-);
-security_policy_t policyForSignTxStakePoolRegistrationRelay(
-        const sign_tx_signingmode_t txSigningMode,
-        const pool_relay_t* relay
-);
-security_policy_t policyForSignTxStakePoolRegistrationMetadata();
-security_policy_t policyForSignTxStakePoolRegistrationNoMetadata();
-security_policy_t policyForSignTxStakePoolRegistrationConfirm(
-        uint32_t numOwners, uint32_t numRelays
-);
+// security_policy_t policyForSignTxCertificateStakePoolRetirement(
+//         sign_tx_signingmode_t txSigningMode,
+//         const bip44_path_t* stakeCredential,
+//         uint64_t epoch
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationInit(
+//         sign_tx_signingmode_t txSigningMode,
+//         uint32_t numOwners
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationPoolId(
+//         sign_tx_signingmode_t txSigningMode,
+//         const pool_id_t* poolId
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationVrfKey(
+//         sign_tx_signingmode_t txSigningMode
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationRewardAccount(
+//         sign_tx_signingmode_t txSigningMode,
+//         const reward_account_t* poolRewardAccount
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationOwner(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_owner_t* owner,
+//         uint32_t numOwnersGivenByPath
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationRelay(
+//         const sign_tx_signingmode_t txSigningMode,
+//         const pool_relay_t* relay
+// );
+// security_policy_t policyForSignTxStakePoolRegistrationMetadata();
+// security_policy_t policyForSignTxStakePoolRegistrationNoMetadata();
+// security_policy_t policyForSignTxStakePoolRegistrationConfirm(
+//         uint32_t numOwners, uint32_t numRelays
+// );
 
 security_policy_t policyForSignTxWithdrawal(
         sign_tx_signingmode_t txSigningMode,
@@ -137,13 +137,13 @@ security_policy_t policyForSignTxRequiredSigner(
 security_policy_t policyForSignTxWitness(
         sign_tx_signingmode_t txSigningMode,
         const bip44_path_t* witnessPath,
-        bool mintPresent,
-        const bip44_path_t* poolOwnerPath
+        bool mintPresent
+        // const bip44_path_t* poolOwnerPath
 );
 
 security_policy_t policyForSignTxConfirm();
 
-security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec);
+// security_policy_t policyForSignOpCert(const bip44_path_t* poolColdKeyPathSpec);
 
 security_policy_t policyForCatalystRegistrationVotingRewardsAddressParams(
         const addressParams_t* params,
diff --git a/src/signOpCert.c b/src/signOpCert.c
index 6bf0794..f1c16da 100644
--- a/src/signOpCert.c
+++ b/src/signOpCert.c
@@ -1,205 +1,205 @@
-#include "common.h"
-
-#include "signOpCert.h"
-#include "keyDerivation.h"
-#include "endian.h"
-#include "state.h"
-#include "uiHelpers.h"
-#include "uiScreens.h"
-#include "securityPolicy.h"
-#include "messageSigning.h"
-#include "textUtils.h"
-
-static ins_sign_op_cert_context_t* ctx = &(instructionState.signOpCertContext);
-
-
-static int16_t RESPONSE_READY_MAGIC = 31678;
-
-// forward declaration
-static void signOpCert_ui_runStep();
-enum {
-	UI_STEP_WARNING = 100,
-	UI_STEP_CONFIRM_START,
-	UI_STEP_DISPLAY_POOL_COLD_KEY_PATH,
-	UI_STEP_DISPLAY_POOL_ID,
-	UI_STEP_DISPLAY_KES_PUBLIC_KEY,
-	UI_STEP_DISPLAY_KES_PERIOD,
-	UI_STEP_DISPLAY_ISSUE_COUNTER,
-	UI_STEP_CONFIRM,
-	UI_STEP_RESPOND,
-	UI_STEP_INVALID,
-};
-
-void signOpCert_handleAPDU(
-        uint8_t p1,
-        uint8_t p2,
-        uint8_t *wireDataBuffer,
-        size_t wireDataSize,
-        bool isNewCall
-)
-{
-	// Initialize state
-	if (isNewCall) {
-		explicit_bzero(ctx, SIZEOF(*ctx));
-	}
-	ctx->responseReadyMagic = 0;
-
-	// Validate params
-	VALIDATE(p1 == P1_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
-	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
-
-	{
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		STATIC_ASSERT(SIZEOF(ctx->kesPublicKey) == KES_PUBLIC_KEY_LENGTH, "wrong KES public key size");
-		view_parseBuffer(ctx->kesPublicKey, &view, KES_PUBLIC_KEY_LENGTH);
-		TRACE("KES key:");
-		TRACE_BUFFER(ctx->kesPublicKey, KES_PUBLIC_KEY_LENGTH);
-
-		ctx->kesPeriod = parse_u8be(&view);
-		TRACE("KES period:");
-		TRACE_UINT64(ctx->kesPeriod);
-
-		ctx->issueCounter = parse_u8be(&view);
-		TRACE("Issue counter:");
-		TRACE_UINT64(ctx->issueCounter);
-
-		view_skipBytes(&view, bip44_parseFromWire(&ctx->poolColdKeyPathSpec, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	// Check security policy
-	security_policy_t policy = policyForSignOpCert(&ctx->poolColdKeyPathSpec);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		uint8_t opCertBodyBuffer[OP_CERT_BODY_LENGTH] = {0};
-		write_view_t opCertBodyBufferView = make_write_view(opCertBodyBuffer, opCertBodyBuffer + OP_CERT_BODY_LENGTH);
-
-		view_appendBuffer(&opCertBodyBufferView, (const uint8_t*) &ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey));
-		{
-			uint8_t chunk[8] = {0};
-			u8be_write(chunk, ctx->issueCounter);
-			#ifdef FUZZING
-			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
-			#else
-			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
-			#endif
-		}
-		{
-			uint8_t chunk[8] = {0};
-			u8be_write(chunk, ctx->kesPeriod);
-			#ifdef FUZZING
-			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
-			#else
-			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
-			#endif
-		}
-
-		ASSERT(view_processedSize(&opCertBodyBufferView) == OP_CERT_BODY_LENGTH);
-		TRACE_BUFFER(opCertBodyBuffer, SIZEOF(opCertBodyBuffer));
-
-		getOpCertSignature(
-		        &ctx->poolColdKeyPathSpec,
-		        opCertBodyBuffer,
-		        OP_CERT_BODY_LENGTH,
-		        ctx->signature,
-		        SIZEOF(ctx->signature)
-		);
-	}
-	ctx->responseReadyMagic = RESPONSE_READY_MAGIC;
-
-	switch (policy) {
-#define  CASE(policy, step) case policy: {ctx->ui_step = step; break;}
-		CASE(POLICY_PROMPT_WARN_UNUSUAL,    UI_STEP_WARNING);
-		CASE(POLICY_PROMPT_BEFORE_RESPONSE, UI_STEP_CONFIRM_START);
-		CASE(POLICY_ALLOW_WITHOUT_PROMPT,   UI_STEP_RESPOND);
-#undef   CASE
-	default:
-		THROW(ERR_NOT_IMPLEMENTED);
-	}
-	signOpCert_ui_runStep();
-}
-
-static void signOpCert_ui_runStep()
-{
-	ui_callback_fn_t* this_fn = signOpCert_ui_runStep;
-
-	UI_STEP_BEGIN(ctx->ui_step, this_fn);
-
-	UI_STEP(UI_STEP_WARNING) {
-		ui_displayPaginatedText(
-		        "Unusual request",
-		        "Proceed with care",
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_CONFIRM_START) {
-		ui_displayPrompt(
-		        "Start new",
-		        "operational certificate?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_POOL_COLD_KEY_PATH) {
-		ui_displayPathScreen("Pool cold key path", &ctx->poolColdKeyPathSpec, this_fn);
-	}
-	UI_STEP(UI_STEP_DISPLAY_POOL_ID) {
-		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-		bip44_pathToKeyHash(&ctx->poolColdKeyPathSpec, poolKeyHash, SIZEOF(poolKeyHash));
-
-		ui_displayBech32Screen(
-		        "Pool ID",
-		        "pool_vk",
-		        poolKeyHash, SIZEOF(poolKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_KES_PUBLIC_KEY) {
-		ui_displayBech32Screen(
-		        "KES public key",
-		        "kes_vk",
-		        ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey),
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_KES_PERIOD) {
-		char kesPeriodString[50] = {0};
-		explicit_bzero(kesPeriodString, SIZEOF(kesPeriodString));
-		str_formatUint64(ctx->kesPeriod, kesPeriodString, SIZEOF(kesPeriodString));
-		ui_displayPaginatedText(
-		        "KES period",
-		        kesPeriodString,
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_DISPLAY_ISSUE_COUNTER) {
-		char issueCounterString[50] = {0};
-		explicit_bzero(issueCounterString, SIZEOF(issueCounterString));
-		str_formatUint64(ctx->issueCounter, issueCounterString, SIZEOF(issueCounterString));
-		ui_displayPaginatedText(
-		        "Issue counter",
-		        issueCounterString,
-		        this_fn
-		);
-	}
-	UI_STEP(UI_STEP_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm",
-		        "operational certificate?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(UI_STEP_RESPOND) {
-		ASSERT(ctx->responseReadyMagic == RESPONSE_READY_MAGIC);
-
-		io_send_buf(SUCCESS, (uint8_t*) &ctx->signature, SIZEOF(ctx->signature));
-		ui_idle();
-
-	}
-	UI_STEP_END(UI_STEP_INVALID);
-}
+// #include "common.h"
+
+// #include "signOpCert.h"
+// #include "keyDerivation.h"
+// #include "endian.h"
+// #include "state.h"
+// #include "uiHelpers.h"
+// #include "uiScreens.h"
+// #include "securityPolicy.h"
+// #include "messageSigning.h"
+// #include "textUtils.h"
+
+// static ins_sign_op_cert_context_t* ctx = &(instructionState.signOpCertContext);
+
+
+// static int16_t RESPONSE_READY_MAGIC = 31678;
+
+// // forward declaration
+// static void signOpCert_ui_runStep();
+// enum {
+// 	UI_STEP_WARNING = 100,
+// 	UI_STEP_CONFIRM_START,
+// 	UI_STEP_DISPLAY_POOL_COLD_KEY_PATH,
+// 	UI_STEP_DISPLAY_POOL_ID,
+// 	UI_STEP_DISPLAY_KES_PUBLIC_KEY,
+// 	UI_STEP_DISPLAY_KES_PERIOD,
+// 	UI_STEP_DISPLAY_ISSUE_COUNTER,
+// 	UI_STEP_CONFIRM,
+// 	UI_STEP_RESPOND,
+// 	UI_STEP_INVALID,
+// };
+
+// void signOpCert_handleAPDU(
+//         uint8_t p1,
+//         uint8_t p2,
+//         uint8_t *wireDataBuffer,
+//         size_t wireDataSize,
+//         bool isNewCall
+// )
+// {
+// 	// Initialize state
+// 	if (isNewCall) {
+// 		explicit_bzero(ctx, SIZEOF(*ctx));
+// 	}
+// 	ctx->responseReadyMagic = 0;
+
+// 	// Validate params
+// 	VALIDATE(p1 == P1_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
+// 	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
+
+// 	{
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		STATIC_ASSERT(SIZEOF(ctx->kesPublicKey) == KES_PUBLIC_KEY_LENGTH, "wrong KES public key size");
+// 		view_parseBuffer(ctx->kesPublicKey, &view, KES_PUBLIC_KEY_LENGTH);
+// 		TRACE("KES key:");
+// 		TRACE_BUFFER(ctx->kesPublicKey, KES_PUBLIC_KEY_LENGTH);
+
+// 		ctx->kesPeriod = parse_u8be(&view);
+// 		TRACE("KES period:");
+// 		TRACE_UINT64(ctx->kesPeriod);
+
+// 		ctx->issueCounter = parse_u8be(&view);
+// 		TRACE("Issue counter:");
+// 		TRACE_UINT64(ctx->issueCounter);
+
+// 		view_skipBytes(&view, bip44_parseFromWire(&ctx->poolColdKeyPathSpec, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	// Check security policy
+// 	security_policy_t policy = policyForSignOpCert(&ctx->poolColdKeyPathSpec);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		uint8_t opCertBodyBuffer[OP_CERT_BODY_LENGTH] = {0};
+// 		write_view_t opCertBodyBufferView = make_write_view(opCertBodyBuffer, opCertBodyBuffer + OP_CERT_BODY_LENGTH);
+
+// 		view_appendBuffer(&opCertBodyBufferView, (const uint8_t*) &ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey));
+// 		{
+// 			uint8_t chunk[8] = {0};
+// 			u8be_write(chunk, ctx->issueCounter);
+// 			#ifdef FUZZING
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
+// 			#else
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
+// 			#endif
+// 		}
+// 		{
+// 			uint8_t chunk[8] = {0};
+// 			u8be_write(chunk, ctx->kesPeriod);
+// 			#ifdef FUZZING
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, 8);
+// 			#else
+// 			view_appendBuffer(&opCertBodyBufferView, chunk, SIZEOF(chunk));
+// 			#endif
+// 		}
+
+// 		ASSERT(view_processedSize(&opCertBodyBufferView) == OP_CERT_BODY_LENGTH);
+// 		TRACE_BUFFER(opCertBodyBuffer, SIZEOF(opCertBodyBuffer));
+
+// 		getOpCertSignature(
+// 		        &ctx->poolColdKeyPathSpec,
+// 		        opCertBodyBuffer,
+// 		        OP_CERT_BODY_LENGTH,
+// 		        ctx->signature,
+// 		        SIZEOF(ctx->signature)
+// 		);
+// 	}
+// 	ctx->responseReadyMagic = RESPONSE_READY_MAGIC;
+
+// 	switch (policy) {
+// #define  CASE(policy, step) case policy: {ctx->ui_step = step; break;}
+// 		CASE(POLICY_PROMPT_WARN_UNUSUAL,    UI_STEP_WARNING);
+// 		CASE(POLICY_PROMPT_BEFORE_RESPONSE, UI_STEP_CONFIRM_START);
+// 		CASE(POLICY_ALLOW_WITHOUT_PROMPT,   UI_STEP_RESPOND);
+// #undef   CASE
+// 	default:
+// 		THROW(ERR_NOT_IMPLEMENTED);
+// 	}
+// 	signOpCert_ui_runStep();
+// }
+
+// static void signOpCert_ui_runStep()
+// {
+// 	ui_callback_fn_t* this_fn = signOpCert_ui_runStep;
+
+// 	UI_STEP_BEGIN(ctx->ui_step, this_fn);
+
+// 	UI_STEP(UI_STEP_WARNING) {
+// 		ui_displayPaginatedText(
+// 		        "Unusual request",
+// 		        "Proceed with care",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_CONFIRM_START) {
+// 		ui_displayPrompt(
+// 		        "Start new",
+// 		        "operational certificate?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_POOL_COLD_KEY_PATH) {
+// 		ui_displayPathScreen("Pool cold key path", &ctx->poolColdKeyPathSpec, this_fn);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_POOL_ID) {
+// 		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 		bip44_pathToKeyHash(&ctx->poolColdKeyPathSpec, poolKeyHash, SIZEOF(poolKeyHash));
+
+// 		ui_displayBech32Screen(
+// 		        "Pool ID",
+// 		        "pool_vk",
+// 		        poolKeyHash, SIZEOF(poolKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_KES_PUBLIC_KEY) {
+// 		ui_displayBech32Screen(
+// 		        "KES public key",
+// 		        "kes_vk",
+// 		        ctx->kesPublicKey, SIZEOF(ctx->kesPublicKey),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_KES_PERIOD) {
+// 		char kesPeriodString[50] = {0};
+// 		explicit_bzero(kesPeriodString, SIZEOF(kesPeriodString));
+// 		str_formatUint64(ctx->kesPeriod, kesPeriodString, SIZEOF(kesPeriodString));
+// 		ui_displayPaginatedText(
+// 		        "KES period",
+// 		        kesPeriodString,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_DISPLAY_ISSUE_COUNTER) {
+// 		char issueCounterString[50] = {0};
+// 		explicit_bzero(issueCounterString, SIZEOF(issueCounterString));
+// 		str_formatUint64(ctx->issueCounter, issueCounterString, SIZEOF(issueCounterString));
+// 		ui_displayPaginatedText(
+// 		        "Issue counter",
+// 		        issueCounterString,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm",
+// 		        "operational certificate?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(UI_STEP_RESPOND) {
+// 		ASSERT(ctx->responseReadyMagic == RESPONSE_READY_MAGIC);
+
+// 		io_send_buf(SUCCESS, (uint8_t*) &ctx->signature, SIZEOF(ctx->signature));
+// 		ui_idle();
+
+// 	}
+// 	UI_STEP_END(UI_STEP_INVALID);
+// }
diff --git a/src/signOpCert.h b/src/signOpCert.h
index af84479..e7cf564 100644
--- a/src/signOpCert.h
+++ b/src/signOpCert.h
@@ -1,23 +1,23 @@
-#ifndef H_CARDANO_APP_SIGN_OP_CERT
-#define H_CARDANO_APP_SIGN_OP_CERT
+// #ifndef H_CARDANO_APP_SIGN_OP_CERT
+// #define H_CARDANO_APP_SIGN_OP_CERT
 
-#include "common.h"
-#include "handlers.h"
-#include "bip44.h"
-#include "keyDerivation.h"
+// #include "common.h"
+// #include "handlers.h"
+// #include "bip44.h"
+// #include "keyDerivation.h"
 
-handler_fn_t signOpCert_handleAPDU;
+// handler_fn_t signOpCert_handleAPDU;
 
-#define KES_PUBLIC_KEY_LENGTH 32
+// #define KES_PUBLIC_KEY_LENGTH 32
 
-typedef struct {
-	int16_t responseReadyMagic;
-	uint8_t kesPublicKey[KES_PUBLIC_KEY_LENGTH];
-	uint64_t kesPeriod;
-	uint64_t issueCounter;
-	bip44_path_t poolColdKeyPathSpec;
-	uint8_t signature[64];
-	int ui_step;
-} ins_sign_op_cert_context_t;
+// typedef struct {
+// 	int16_t responseReadyMagic;
+// 	uint8_t kesPublicKey[KES_PUBLIC_KEY_LENGTH];
+// 	uint64_t kesPeriod;
+// 	uint64_t issueCounter;
+// 	bip44_path_t poolColdKeyPathSpec;
+// 	uint8_t signature[64];
+// 	int ui_step;
+// } ins_sign_op_cert_context_t;
 
-#endif // H_CARDANO_APP_SIGN_OP_CERT
\ No newline at end of file
+// #endif // H_CARDANO_APP_SIGN_OP_CERT
\ No newline at end of file
diff --git a/src/signTx.c b/src/signTx.c
index ec23d83..e974fa3 100644
--- a/src/signTx.c
+++ b/src/signTx.c
@@ -317,15 +317,15 @@ static inline void checkForFinishedSubmachines()
 		}
 		break;
 
-	case SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE:
-		if (signTxPoolRegistration_isFinished()) {
-			TRACE();
-			ASSERT(BODY_CTX->currentCertificate < ctx->numCertificates);
-			ctx->stage = SIGN_STAGE_BODY_CERTIFICATES;
+	// case SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE:
+	// 	if (signTxPoolRegistration_isFinished()) {
+	// 		TRACE();
+	// 		ASSERT(BODY_CTX->currentCertificate < ctx->numCertificates);
+	// 		ctx->stage = SIGN_STAGE_BODY_CERTIFICATES;
 
-			advanceCertificatesStateIfAppropriate();
-		}
-		break;
+	// 		advanceCertificatesStateIfAppropriate();
+	// 	}
+	// 	break;
 
 	case SIGN_STAGE_AUX_DATA_CATALYST_REGISTRATION_SUBMACHINE:
 		if (signTxCatalystRegistration_isFinished()) {
@@ -377,11 +377,11 @@ static const char *_newTxLine1(sign_tx_signingmode_t txSigningMode)
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 		return "New ordinary";
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		return "New pool owner";
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+	// 	return "New pool owner";
 
-	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		return "New pool operator";
+	// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+	// 	return "New pool operator";
 
 	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		return "New multisig";
@@ -536,8 +536,8 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 		TRACE("Signing mode %d", (int) ctx->commonTxData.txSigningMode);
 		switch (ctx->commonTxData.txSigningMode) {
 		case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+		// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+		// case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 			// these signing modes are allowed
@@ -582,7 +582,7 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 
 	{
 		// default values for variables whose value is not given in the APDU
-		ctx->poolOwnerByPath = false;
+		// ctx->poolOwnerByPath = false;
 		ctx->shouldDisplayTxid = false;
 	}
 
@@ -591,11 +591,11 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 	                                   ctx->commonTxData.networkId,
 	                                   ctx->commonTxData.protocolMagic,
 	                                   ctx->numOutputs,
-	                                   ctx->numCertificates,
+	                                //    ctx->numCertificates,
 	                                   ctx->numWithdrawals,
-	                                   ctx->includeMint,
+	                                //    ctx->includeMint,
 	                                   ctx->numCollaterals,
-	                                   ctx->numRequiredSigners,
+	                                //    ctx->numRequiredSigners,
 	                                   ctx->includeScriptDataHash,
 	                                   ctx->includeNetworkId
 	                           );
@@ -1159,53 +1159,53 @@ static void signTx_handleCertificate_ui_runStep()
 	UI_STEP_END(HANDLE_CERTIFICATE_STEP_INVALID);
 }
 
-enum {
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION = 650,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND,
-	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID,
-};
-
-static void signTx_handleCertificatePoolRetirement_ui_runStep()
-{
-	TRACE("UI step %d", ctx->ui_step);
-	ASSERT(BODY_CTX->stageData.certificate.type == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
-
-	ui_callback_fn_t* this_fn = signTx_handleCertificatePoolRetirement_ui_runStep;
-
-	UI_STEP_BEGIN(ctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION) {
-		ui_displayBech32Screen(
-		        "Retire stake pool",
-		        "pool",
-		        BODY_CTX->stageData.certificate.poolKeyHash, SIZEOF(BODY_CTX->stageData.certificate.poolKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH) {
-		ui_displayUint64Screen(
-		        "at the start of epoch",
-		        BODY_CTX->stageData.certificate.epoch,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm",
-		        "pool retirement",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		advanceCertificatesStateIfAppropriate();
-	}
-	UI_STEP_END(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID);
-}
+// enum {
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION = 650,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND,
+// 	HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID,
+// };
+
+// static void signTx_handleCertificatePoolRetirement_ui_runStep()
+// {
+// 	TRACE("UI step %d", ctx->ui_step);
+// 	ASSERT(BODY_CTX->stageData.certificate.type == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
+
+// 	ui_callback_fn_t* this_fn = signTx_handleCertificatePoolRetirement_ui_runStep;
+
+// 	UI_STEP_BEGIN(ctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION) {
+// 		ui_displayBech32Screen(
+// 		        "Retire stake pool",
+// 		        "pool",
+// 		        BODY_CTX->stageData.certificate.poolKeyHash, SIZEOF(BODY_CTX->stageData.certificate.poolKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_EPOCH) {
+// 		ui_displayUint64Screen(
+// 		        "at the start of epoch",
+// 		        BODY_CTX->stageData.certificate.epoch,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm",
+// 		        "pool retirement",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		advanceCertificatesStateIfAppropriate();
+// 	}
+// 	UI_STEP_END(HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_INVALID);
+// }
 
 static void _parsePathSpec(read_view_t* view, bip44_path_t* pathSpec)
 {
@@ -1262,15 +1262,15 @@ static void _parseCertificateData(uint8_t* wireDataBuffer, size_t wireDataSize,
 		view_parseBuffer(certificateData->poolKeyHash, &view, POOL_KEY_HASH_LENGTH);
 		break;
 
-	case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION:
-		// nothing more to parse, certificate data will be provided
-		// in additional APDUs processed by a submachine
-		return;
+	// case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION:
+	// 	// nothing more to parse, certificate data will be provided
+	// 	// in additional APDUs processed by a submachine
+	// 	return;
 
-	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT:
-		_parsePathSpec(&view, &certificateData->poolIdPath);
-		certificateData->epoch = parse_u8be(&view);
-		break;
+	// case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT:
+	// 	_parsePathSpec(&view, &certificateData->poolIdPath);
+	// 	certificateData->epoch = parse_u8be(&view);
+	// 	break;
 
 	default:
 		THROW(ERR_INVALID_DATA);
@@ -1353,15 +1353,15 @@ static void _addCertificateDataToTx(
 		break;
 	}
 
-	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
-		_fillHashFromPath(&BODY_CTX->stageData.certificate.poolIdPath, certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash));
-		txHashBuilder_addCertificate_poolRetirement(
-		        txHashBuilder,
-		        certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash),
-		        certificateData->epoch
-		);
-		break;
-	}
+	// case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
+	// 	_fillHashFromPath(&BODY_CTX->stageData.certificate.poolIdPath, certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash));
+	// 	txHashBuilder_addCertificate_poolRetirement(
+	// 	        txHashBuilder,
+	// 	        certificateData->poolKeyHash, SIZEOF(certificateData->poolKeyHash),
+	// 	        certificateData->epoch
+	// 	);
+	// 	break;
+	// }
 
 	default:
 		ASSERT(false);
@@ -1376,15 +1376,15 @@ static void signTx_handleCertificateAPDU(uint8_t p2, uint8_t* wireDataBuffer, si
 	ASSERT(BODY_CTX->currentCertificate < ctx->numCertificates);
 
 	// delegate to state sub-machine for stake pool registration certificate data
-	if (signTxPoolRegistration_isValidInstruction(p2)) {
-		TRACE();
-		VALIDATE(ctx->stage == SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE, ERR_INVALID_DATA);
+	// if (signTxPoolRegistration_isValidInstruction(p2)) {
+	// 	TRACE();
+	// 	VALIDATE(ctx->stage == SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE, ERR_INVALID_DATA);
 
-		TRACE_STACK_USAGE();
+	// 	TRACE_STACK_USAGE();
 
-		signTxPoolRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
-		return;
-	}
+	// 	signTxPoolRegistration_handleAPDU(p2, wireDataBuffer, wireDataSize);
+	// 	return;
+	// }
 
 	CHECK_STAGE(SIGN_STAGE_BODY_CERTIFICATES);
 	VALIDATE(p2 == P2_UNUSED, ERR_INVALID_REQUEST_PARAMETERS);
@@ -1434,38 +1434,38 @@ static void signTx_handleCertificateAPDU(uint8_t p2, uint8_t* wireDataBuffer, si
 		return;
 	}
 
-	case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION: {
-		// pool registration certificates have a separate sub-machine for handling APDU and UI
-		// nothing more to be done with them here, we just init the sub-machine
-		ctx->stage = SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE;
-		signTxPoolRegistration_init();
-
-		respondSuccessEmptyMsg();
-		return;
-	}
-
-	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
-		security_policy_t policy = policyForSignTxCertificateStakePoolRetirement(
-		                                   ctx->commonTxData.txSigningMode,
-		                                   &BODY_CTX->stageData.certificate.poolIdPath,
-		                                   BODY_CTX->stageData.certificate.epoch
-		                           );
-		TRACE("Policy: %d", (int) policy);
-		ENSURE_NOT_DENIED(policy);
-
-		_addCertificateDataToTx(&BODY_CTX->stageData.certificate, &BODY_CTX->txHashBuilder);
-
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-		signTx_handleCertificatePoolRetirement_ui_runStep();
-		return;
-	}
+// 	case CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION: {
+// 		// pool registration certificates have a separate sub-machine for handling APDU and UI
+// 		// nothing more to be done with them here, we just init the sub-machine
+// 		ctx->stage = SIGN_STAGE_BODY_CERTIFICATES_POOL_SUBMACHINE;
+// 		signTxPoolRegistration_init();
+
+// 		respondSuccessEmptyMsg();
+// 		return;
+// 	}
+
+// 	case CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT: {
+// 		security_policy_t policy = policyForSignTxCertificateStakePoolRetirement(
+// 		                                   ctx->commonTxData.txSigningMode,
+// 		                                   &BODY_CTX->stageData.certificate.poolIdPath,
+// 		                                   BODY_CTX->stageData.certificate.epoch
+// 		                           );
+// 		TRACE("Policy: %d", (int) policy);
+// 		ENSURE_NOT_DENIED(policy);
+
+// 		_addCertificateDataToTx(&BODY_CTX->stageData.certificate, &BODY_CTX->txHashBuilder);
+
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {ctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_DISPLAY_OPERATION);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CERTIFICATE_POOL_RETIREMENT_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 		signTx_handleCertificatePoolRetirement_ui_runStep();
+// 		return;
+// 	}
 
 	default:
 		ASSERT(false);
@@ -2233,8 +2233,8 @@ static void signTx_handleWitnessAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t
 	security_policy_t policy = policyForSignTxWitness(
 	                                   ctx->commonTxData.txSigningMode,
 	                                   &WITNESS_CTX->stageData.witness.path,
-	                                   ctx->includeMint,
-	                                   ctx->poolOwnerByPath ? &ctx->poolOwnerPath : NULL
+	                                   ctx->includeMint
+	                                //    ctx->poolOwnerByPath ? &ctx->poolOwnerPath : NULL
 	                           );
 	TRACE("Policy: %d", (int) policy);
 	ENSURE_NOT_DENIED(policy);
diff --git a/src/signTx.h b/src/signTx.h
index 255a070..4c60450 100644
--- a/src/signTx.h
+++ b/src/signTx.h
@@ -9,15 +9,15 @@
 #include "addressUtilsShelley.h"
 #include "signTxMint.h"
 #include "signTxOutput.h"
-#include "signTxPoolRegistration.h"
+// #include "signTxPoolRegistration.h"
 #include "signTxCatalystRegistration.h"
 #include "signTxAuxData.h"
 
 // the signing mode significantly affects restrictions on tx being signed
 typedef enum {
 	SIGN_TX_SIGNINGMODE_ORDINARY_TX = 3, // enum value 3 is needed for backwards compatibility
-	SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER = 4,
-	SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR = 5,
+	// SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER = 4,
+	// SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR = 5,
 	SIGN_TX_SIGNINGMODE_MULTISIG_TX = 6,
 	SIGN_TX_SIGNINGMODE_PLUTUS_TX = 7,
 } sign_tx_signingmode_t;
@@ -85,7 +85,7 @@ typedef struct {
 
 	union {
 		stake_credential_t stakeCredential;
-		bip44_path_t poolIdPath;
+		// bip44_path_t poolIdPath;
 	};
 	uint64_t epoch;
 	uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH];
@@ -162,7 +162,7 @@ typedef struct {
 	} stageData; // TODO rename to reflect single-APDU scope
 
 	union {
-		pool_registration_context_t pool_registration_subctx;
+		// pool_registration_context_t pool_registration_subctx;
 		output_context_t output_subctx;
 		mint_context_t mint_subctx;
 	} stageContext;
@@ -203,8 +203,8 @@ typedef struct {
 		ins_sign_tx_witness_context_t witnesses_ctx;
 	} txPartCtx;
 
-	bool poolOwnerByPath;
-	bip44_path_t poolOwnerPath;
+	// bool poolOwnerByPath;
+	// bip44_path_t poolOwnerPath;
 
 	bool shouldDisplayTxid; // long bytestrings (e.g. datums in outputs) are better verified indirectly
 
diff --git a/src/signTxPoolRegistration.c b/src/signTxPoolRegistration.c
index de3a445..93317df 100644
--- a/src/signTxPoolRegistration.c
+++ b/src/signTxPoolRegistration.c
@@ -1,1498 +1,1498 @@
-#include "signTx.h"
-#include "state.h"
-#include "cardano.h"
-#include "addressUtilsShelley.h"
-#include "keyDerivation.h"
-#include "uiHelpers.h"
-#include "signTxUtils.h"
-#include "uiScreens.h"
-#include "txHashBuilder.h"
-#include "textUtils.h"
-#include "hexUtils.h"
-#include "bufView.h"
-#include "securityPolicy.h"
-#include "signTxPoolRegistration.h"
-
-static ins_sign_tx_context_t* ctx = &(instructionState.signTxContext);
-static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
-
-static pool_registration_context_t* accessSubcontext()
-{
-	return &BODY_CTX->stageContext.pool_registration_subctx;
-}
-
-bool signTxPoolRegistration_isFinished()
-{
-	// we are also asserting that the state is valid
-	switch (accessSubcontext()->state) {
-	case STAKE_POOL_REGISTRATION_FINISHED:
-		return true;
-
-	case STAKE_POOL_REGISTRATION_INIT:
-	case STAKE_POOL_REGISTRATION_POOL_KEY:
-	case STAKE_POOL_REGISTRATION_VRF_KEY:
-	case STAKE_POOL_REGISTRATION_FINANCIALS:
-	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
-	case STAKE_POOL_REGISTRATION_OWNERS:
-	case STAKE_POOL_REGISTRATION_RELAYS:
-	case STAKE_POOL_REGISTRATION_METADATA:
-	case STAKE_POOL_REGISTRATION_CONFIRM:
-		return false;
-
-	default:
-		ASSERT(false);
-	}
-}
-
-void signTxPoolRegistration_init()
-{
-	explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
-
-	accessSubcontext()->state = STAKE_POOL_REGISTRATION_INIT;
-}
-
-static inline void CHECK_STATE(sign_tx_pool_registration_state_t expected)
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("Pool registration certificate stage: current %d, expected %d", subctx->state, expected);
-	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
-}
-
-static inline void advanceState()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("Advancing pool registration certificate state from: %d", subctx->state);
-
-	switch (subctx->state) {
-
-	case STAKE_POOL_REGISTRATION_INIT:
-		subctx->state = STAKE_POOL_REGISTRATION_POOL_KEY;
-		break;
-
-	case STAKE_POOL_REGISTRATION_POOL_KEY:
-		subctx->state = STAKE_POOL_REGISTRATION_VRF_KEY;
-		break;
-
-	case STAKE_POOL_REGISTRATION_VRF_KEY:
-		subctx->state = STAKE_POOL_REGISTRATION_FINANCIALS;
-		break;
-
-	case STAKE_POOL_REGISTRATION_FINANCIALS:
-		subctx->state = STAKE_POOL_REGISTRATION_REWARD_ACCOUNT;
-		break;
-
-	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
-		txHashBuilder_addPoolRegistrationCertificate_enterOwners(&BODY_CTX->txHashBuilder);
-		subctx->state = STAKE_POOL_REGISTRATION_OWNERS;
-
-		if (subctx->numOwners > 0) {
-			break;
-		}
-
-	// intentional fallthrough
-
-	case STAKE_POOL_REGISTRATION_OWNERS:
-		ASSERT(subctx->currentOwner == subctx->numOwners);
-
-		txHashBuilder_addPoolRegistrationCertificate_enterRelays(&BODY_CTX->txHashBuilder);
-		subctx->state = STAKE_POOL_REGISTRATION_RELAYS;
-
-		if (subctx->numRelays > 0) {
-			break;
-		}
-
-	// intentional fallthrough
-
-	case STAKE_POOL_REGISTRATION_RELAYS:
-		ASSERT(subctx->currentRelay == subctx->numRelays);
-
-		subctx->state = STAKE_POOL_REGISTRATION_METADATA;
-		break;
-
-	case STAKE_POOL_REGISTRATION_METADATA:
-		subctx->state = STAKE_POOL_REGISTRATION_CONFIRM;
-		break;
-
-	case STAKE_POOL_REGISTRATION_CONFIRM:
-		subctx->state = STAKE_POOL_REGISTRATION_FINISHED;
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	TRACE("Advancing pool registration certificate state to: %d", subctx->state);
-}
-
-
-// ============================== INIT ==============================
-
-enum {
-	HANDLE_POOL_INIT_STEP_DISPLAY = 6100,
-	HANDLE_POOL_INIT_STEP_RESPOND,
-	HANDLE_POOL_INIT_STEP_INVALID,
-} ;
-
-static void handlePoolInit_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolInit_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_INIT_STEP_DISPLAY) {
-		ui_displayPaginatedText(
-		        "Pool registration",
-		        "certificate",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_INIT_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_INIT_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleInitAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_INIT);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	pool_registration_context_t* subctx = accessSubcontext();
-	{
-		// initialization
-		subctx->currentOwner = 0;
-		subctx->currentRelay = 0;
-
-		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-	}
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		struct {
-			uint8_t numOwners[4];
-			uint8_t numRelays[4];
-		}* wireHeader = (void*) wireDataBuffer;
-
-		// can't use SIZEOF because it fails for x86 for fuzzing
-		VALIDATE(wireDataSize == sizeof(*wireHeader), ERR_INVALID_DATA);
-
-		uint64_t numOwners = u4be_read(wireHeader->numOwners);
-		uint64_t numRelays = u4be_read(wireHeader->numRelays);
-		TRACE(
-		        "num owners, relays: %d %d",
-		        subctx->numOwners, subctx->numRelays
-		);
-
-		VALIDATE(subctx->numOwners <= POOL_MAX_OWNERS, ERR_INVALID_DATA);
-		VALIDATE(subctx->numRelays <= POOL_MAX_RELAYS, ERR_INVALID_DATA);
-		ASSERT_TYPE(subctx->numOwners, uint16_t);
-		ASSERT_TYPE(subctx->numRelays, uint16_t);
-		subctx->numOwners = (uint16_t) numOwners;
-		subctx->numRelays = (uint16_t) numRelays;
-	}
-	{
-		security_policy_t policy = policyForSignTxStakePoolRegistrationInit(
-		                                   commonTxData->txSigningMode,
-		                                   subctx->numOwners
-		                           );
-		TRACE("Policy: %d", (int) policy);
-		ENSURE_NOT_DENIED(policy);
-	}
-	{
-		txHashBuilder_poolRegistrationCertificate_enter(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->numOwners, subctx->numRelays
-		);
-	}
-
-	subctx->ui_step = HANDLE_POOL_INIT_STEP_DISPLAY;
-	handlePoolInit_ui_runStep();
-}
-
-// ============================== POOL KEY HASH / ID ==============================
-
-static void _toPoolKeyHash(const pool_id_t* poolId, uint8_t* poolKeyHash)
-{
-	switch (poolId->keyReferenceType) {
-
-	case KEY_REFERENCE_HASH: {
-		STATIC_ASSERT(SIZEOF(poolId->hash) == POOL_KEY_HASH_LENGTH, "wrong pool key hash length");
-		memmove(poolKeyHash, poolId->hash, POOL_KEY_HASH_LENGTH);
-		break;
-	}
-	case KEY_REFERENCE_PATH: {
-		bip44_pathToKeyHash(&poolId->path, poolKeyHash, POOL_KEY_HASH_LENGTH);
-		break;
-	}
-	default:
-		ASSERT(false);
-	}
-}
-
-enum {
-	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH = 6200,
-	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID,
-	HANDLE_POOL_KEY_STEP_RESPOND,
-	HANDLE_POOL_KEY_STEP_INVALID,
-} ;
-
-static void handlePoolKey_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH) {
-		ui_displayPathScreen(
-		        "Pool ID path",
-		        &subctx->stateData.poolId.path,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID) {
-		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
-
-		ui_displayBech32Screen(
-		        "Pool ID",
-		        "pool",
-		        poolKeyHash, SIZEOF(poolKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_KEY_STEP_INVALID);
-}
-
-static void _parsePoolId(read_view_t* view)
-{
-	pool_id_t* key = &accessSubcontext()->stateData.poolId;
-
-	key->keyReferenceType = parse_u1be(view);
-
-	switch (key->keyReferenceType) {
-
-	case KEY_REFERENCE_HASH: {
-		STATIC_ASSERT(SIZEOF(key->hash) == POOL_KEY_HASH_LENGTH, "wrong pool id key hash size");
-		view_parseBuffer(key->hash, view, POOL_KEY_HASH_LENGTH);
-		TRACE_BUFFER(key->hash, SIZEOF(key->hash));
-		break;
-	}
-
-	case KEY_REFERENCE_PATH: {
-		view_skipBytes(view, bip44_parseFromWire(&key->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
-		BIP44_PRINTF(&key->path);
-		PRINTF("\n");
-		break;
-	}
-
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handlePoolKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_POOL_KEY);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		_parsePoolId(&view);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxStakePoolRegistrationPoolId(
-	                                   commonTxData->txSigningMode,
-	                                   &subctx->stateData.poolId
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// key derivation must not be done before DENY security policy is enforced
-		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
-		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
-
-		txHashBuilder_poolRegistrationCertificate_poolKeyHash(
-		        &BODY_CTX->txHashBuilder,
-		        poolKeyHash, SIZEOF(poolKeyHash)
-		);
-	}
-	{
-		// ui step depends not only on security policy, but also on signing mode
-		int displayUiStep = HANDLE_POOL_KEY_STEP_INVALID;
-		switch (commonTxData->txSigningMode) {
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
-			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID;
-			break;
-
-		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH;
-			break;
-
-		default:
-			ASSERT(false);
-		}
-		ASSERT(displayUiStep != HANDLE_POOL_KEY_STEP_INVALID);
-
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayUiStep);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handlePoolKey_ui_runStep();
-}
-
-// ============================== VRF KEY HASH ==============================
-
-enum {
-	HANDLE_POOL_VRF_KEY_STEP_DISPLAY = 6300,
-	HANDLE_POOL_VRF_KEY_STEP_RESPOND,
-	HANDLE_POOL_VRF_KEY_STEP_INVALID,
-} ;
-
-static void handlePoolVrfKey_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolVrfKey_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_DISPLAY) {
-		ui_displayBech32Screen(
-		        "VRF key hash",
-		        "vrf_vk",
-		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash),
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_VRF_KEY_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleVrfKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_VRF_KEY);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	pool_registration_context_t* subctx = accessSubcontext();
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		VALIDATE(wireDataSize == SIZEOF(subctx->stateData.vrfKeyHash), ERR_INVALID_DATA);
-
-		{
-			STATIC_ASSERT(SIZEOF(subctx->stateData.vrfKeyHash) == VRF_KEY_HASH_LENGTH, "wrong vrfKeyHash size");
-			memmove(subctx->stateData.vrfKeyHash, wireDataBuffer, VRF_KEY_HASH_LENGTH);
-			// nothing to validate, all values are valid
-		}
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationVrfKey(
-	                                   commonTxData->txSigningMode
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash)
-		);
-	}
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_VRF_KEY_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_VRF_KEY_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handlePoolVrfKey_ui_runStep();
-}
-
-// ============================== POOL FINANCIALS ==============================
-
-enum {
-	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE = 6400,
-	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST,
-	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN,
-	HANDLE_POOL_FINANCIALS_STEP_RESPOND,
-	HANDLE_POOL_FINANCIALS_STEP_INVALID,
-} ;
-
-static void handlePoolFinancials_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolFinancials_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE) {
-		ui_displayAdaAmountScreen(
-		        "Pledge",
-		        subctx->stateData.pledge,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST) {
-		ui_displayAdaAmountScreen(
-		        "Cost",
-		        subctx->stateData.cost,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN) {
-		ui_displayPoolMarginScreen(
-		        subctx->stateData.marginNumerator,
-		        subctx->stateData.marginDenominator,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_FINANCIALS_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handlePoolFinancialsAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_FINANCIALS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	pool_registration_context_t* subctx = accessSubcontext();
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		struct {
-			uint8_t pledge[8];
-			uint8_t cost[8];
-			uint8_t marginNumerator[8];
-			uint8_t marginDenominator[8];
-		}* wireHeader = (void*) wireDataBuffer;
-
-		VALIDATE(wireDataSize == SIZEOF(*wireHeader), ERR_INVALID_DATA);
-
-		{
-			ASSERT_TYPE(subctx->stateData.pledge, uint64_t);
-			subctx->stateData.pledge = u8be_read(wireHeader->pledge);
-			TRACE_ADA_AMOUNT("pledge ", subctx->stateData.pledge);
-			VALIDATE(subctx->stateData.pledge < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
-
-			ASSERT_TYPE(subctx->stateData.cost, uint64_t);
-			subctx->stateData.cost = u8be_read(wireHeader->cost);
-			TRACE_ADA_AMOUNT("cost ", subctx->stateData.cost);
-			VALIDATE(subctx->stateData.cost < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
-
-			ASSERT_TYPE(subctx->stateData.marginNumerator, uint64_t);
-			subctx->stateData.marginNumerator = u8be_read(wireHeader->marginNumerator);
-			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginNumerator, 8);
-			VALIDATE(subctx->stateData.marginNumerator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
-
-			ASSERT_TYPE(subctx->stateData.marginDenominator, uint64_t);
-			subctx->stateData.marginDenominator = u8be_read(wireHeader->marginDenominator);
-			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginDenominator, 8);
-			VALIDATE(subctx->stateData.marginDenominator != 0, ERR_INVALID_DATA);
-			VALIDATE(subctx->stateData.marginDenominator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
-			VALIDATE(subctx->stateData.marginNumerator <= subctx->stateData.marginDenominator, ERR_INVALID_DATA);
-		}
-	}
-	{
-		txHashBuilder_poolRegistrationCertificate_financials(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.pledge, subctx->stateData.cost,
-		        subctx->stateData.marginNumerator, subctx->stateData.marginDenominator
-		);
-	}
-
-	subctx->ui_step = HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE;
-	handlePoolFinancials_ui_runStep();
-}
-
-// ============================== POOL REWARD ACCOUNT ==============================
-
-enum {
-	HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY = 6500,
-	HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND,
-	HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID,
-};
-
-static void handlePoolRewardAccount_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handlePoolRewardAccount_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY) {
-		ui_displayRewardAccountScreen(
-		        &subctx->stateData.poolRewardAccount,
-		        commonTxData->networkId,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID);
-}
-
-static void _parsePoolRewardAccount(read_view_t* view)
-{
-	reward_account_t* rewardAccount = &accessSubcontext()->stateData.poolRewardAccount;
-
-	rewardAccount->keyReferenceType = parse_u1be(view);
-
-	switch (rewardAccount->keyReferenceType) {
-
-	case KEY_REFERENCE_HASH: {
-		STATIC_ASSERT(SIZEOF(rewardAccount->hashBuffer) == REWARD_ACCOUNT_SIZE, "wrong reward account hash buffer size");
-		view_parseBuffer(rewardAccount->hashBuffer, view, REWARD_ACCOUNT_SIZE);
-		TRACE_BUFFER(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
-
-		const uint8_t header = getAddressHeader(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
-		VALIDATE(getAddressType(header) == REWARD_KEY || getAddressType(header) == REWARD_SCRIPT, ERR_INVALID_DATA);
-		VALIDATE(getNetworkId(header) == commonTxData->networkId, ERR_INVALID_DATA);
-		break;
-	}
-
-	case KEY_REFERENCE_PATH: {
-		view_skipBytes(view, bip44_parseFromWire(&rewardAccount->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
-		BIP44_PRINTF(&rewardAccount->path);
-		PRINTF("\n");
-		break;
-	}
-
-	default:
-		THROW(ERR_INVALID_DATA);
-	}
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleRewardAccountAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_REWARD_ACCOUNT);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	{
-		// parse data
-
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		_parsePoolRewardAccount(&view);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxStakePoolRegistrationRewardAccount(
-	                                   commonTxData->txSigningMode,
-	                                   &subctx->stateData.poolRewardAccount
-	                           );
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// key derivation must not be done before DENY security policy is enforced
-		uint8_t rewardAccountBuffer[REWARD_ACCOUNT_SIZE] = {0};
-		rewardAccountToBuffer(&subctx->stateData.poolRewardAccount, commonTxData->networkId, rewardAccountBuffer);
-
-		txHashBuilder_poolRegistrationCertificate_rewardAccount(
-		        &BODY_CTX->txHashBuilder,
-		        rewardAccountBuffer, SIZEOF(rewardAccountBuffer)
-		);
-	}
-
-	{
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handlePoolRewardAccount_ui_runStep();
-}
-
-// ============================== OWNER ==============================
-
-enum {
-	HANDLE_OWNER_STEP_DISPLAY = 6600,
-	HANDLE_OWNER_STEP_RESPOND,
-	HANDLE_OWNER_STEP_INVALID,
-};
-
-static void handleOwner_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleOwner_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_OWNER_STEP_DISPLAY) {
-		ui_displayPoolOwnerScreen(&subctx->stateData.owner, subctx->currentOwner, commonTxData->networkId, this_fn);
-	}
-	UI_STEP(HANDLE_OWNER_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		subctx->currentOwner++;
-		if (subctx->currentOwner == subctx->numOwners) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_OWNER_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void _addOwnerToTxHash()
-{
-	pool_owner_t* owner = &accessSubcontext()->stateData.owner;
-
-	uint8_t ownerKeyHash[ADDRESS_KEY_HASH_LENGTH] = {0};
-
-	switch (owner->keyReferenceType) {
-
-	case KEY_REFERENCE_PATH:
-		bip44_pathToKeyHash(&owner->path, ownerKeyHash, SIZEOF(ownerKeyHash));
-		break;
-
-	case KEY_REFERENCE_HASH:
-		memmove(ownerKeyHash, owner->keyHash, SIZEOF(ownerKeyHash));
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	// add data to tx
-	TRACE("Adding owner to tx hash");
-	txHashBuilder_addPoolRegistrationCertificate_addOwner(
-	        &BODY_CTX->txHashBuilder,
-	        ownerKeyHash, SIZEOF(ownerKeyHash)
-	);
-	TRACE();
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleOwnerAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_OWNERS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	pool_owner_t* owner = &subctx->stateData.owner;
-
-	explicit_bzero(owner, SIZEOF(*owner));
-
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		owner->keyReferenceType = parse_u1be(&view);
-		switch (owner->keyReferenceType) {
-
-		case KEY_REFERENCE_HASH: {
-			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
-			view_parseBuffer(owner->keyHash, &view, ADDRESS_KEY_HASH_LENGTH);
-			TRACE_BUFFER(owner->keyHash, SIZEOF(owner->keyHash));
-			break;
-		}
-
-		case KEY_REFERENCE_PATH: {
-			view_skipBytes(&view, bip44_parseFromWire(&owner->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
-			// further validation of the path in security policy below
-			TRACE("Owner given by path:");
-			BIP44_PRINTF(&owner->path);
-			PRINTF("\n");
-
-			subctx->numOwnersGivenByPath++;
-			VALIDATE(!ctx->poolOwnerByPath, ERR_INVALID_DATA);
-			ctx->poolOwnerByPath = true;
-			memmove(&ctx->poolOwnerPath, &owner->path, SIZEOF(owner->path));
-			break;
-		}
-
-		default:
-			THROW(ERR_INVALID_DATA);
-		}
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationOwner(commonTxData->txSigningMode, owner, subctx->numOwnersGivenByPath);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	_addOwnerToTxHash();
-
-	{
-		// select UI steps
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_OWNER_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_OWNER_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handleOwner_ui_runStep();
-}
-
-
-// ============================== RELAY ==============================
-
-enum {
-	HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER = 6700,
-	HANDLE_RELAY_IP_STEP_DISPLAY_IPV4,
-	HANDLE_RELAY_IP_STEP_DISPLAY_IPV6,
-	HANDLE_RELAY_IP_STEP_DISPLAY_PORT,
-	HANDLE_RELAY_IP_STEP_RESPOND,
-	HANDLE_RELAY_IP_STEP_INVALID,
-};
-
-static void handleRelay_ip_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleRelay_ip_ui_runStep;
-
-	pool_relay_t* relay = &subctx->stateData.relay;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER) {
-		ui_displayPoolRelayScreen(
-		        relay,
-		        subctx->currentRelay,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV4) {
-		ui_displayIpv4Screen(
-		        &relay->ipv4,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV6) {
-		ui_displayIpv6Screen(
-		        &relay->ipv6,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_PORT) {
-		ui_displayIpPortScreen(
-		        &relay->port,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_IP_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		subctx->currentRelay++;
-		TRACE("current relay %d", subctx->currentRelay);
-
-		if (subctx->currentRelay == subctx->numRelays) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_RELAY_IP_STEP_INVALID);
-}
-
-enum {
-	HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER = 6800,
-	HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME,
-	HANDLE_RELAY_DNS_STEP_DISPLAY_PORT,
-	HANDLE_RELAY_DNS_STEP_RESPOND,
-	HANDLE_RELAY_DNS_STEP_INVALID,
-};
-
-static void handleRelay_dns_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleRelay_dns_ui_runStep;
-
-	pool_relay_t* relay = &subctx->stateData.relay;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER) {
-		ui_displayPoolRelayScreen(
-		        relay,
-		        subctx->currentRelay,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME) {
-		char dnsNameStr[1 + DNS_NAME_SIZE_MAX] = {0};
-		explicit_bzero(dnsNameStr, SIZEOF(dnsNameStr));
-		ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
-		memmove(dnsNameStr, relay->dnsName, relay->dnsNameSize);
-		dnsNameStr[relay->dnsNameSize] = '\0';
-		ASSERT(strlen(dnsNameStr) == relay->dnsNameSize);
-
-		ui_displayPaginatedText(
-		        "DNS name",
-		        dnsNameStr,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_PORT) {
-		if (relay->format == RELAY_MULTIPLE_HOST_NAME) {
-			// nothing to display in this step, so we skip it
-			UI_STEP_JUMP(HANDLE_RELAY_DNS_STEP_RESPOND);
-		}
-
-		ui_displayIpPortScreen(
-		        &relay->port,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_RELAY_DNS_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		subctx->currentRelay++;
-		TRACE("current relay %d", subctx->currentRelay);
-
-		if (subctx->currentRelay == subctx->numRelays) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_RELAY_DNS_STEP_INVALID);
-}
-
-static void _parsePort(ipport_t* port, read_view_t* view)
-{
-	uint8_t isPortGiven = parse_u1be(view);
-	if (isPortGiven == ITEM_INCLUDED_YES) {
-		port->isNull = false;
-		ASSERT_TYPE(port->number, uint16_t);
-		port->number = parse_u2be(view);
-		TRACE("Port: %u", port->number);
-	} else {
-		VALIDATE(isPortGiven == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
-		port->isNull = true;
-	}
-}
-
-static void _parseIpv4(ipv4_t* ipv4, read_view_t* view)
-{
-	uint8_t isIpv4Given = parse_u1be(view);
-	if (isIpv4Given == ITEM_INCLUDED_YES) {
-		ipv4->isNull = false;
-		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
-		view_parseBuffer(ipv4->ip, view, IPV4_SIZE);
-		TRACE("ipv4");
-		TRACE_BUFFER(ipv4->ip, IPV4_SIZE);
-	} else {
-		VALIDATE(isIpv4Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
-		ipv4->isNull = true;
-	}
-}
-
-static void _parseIpv6(ipv6_t* ipv6, read_view_t* view)
-{
-	uint8_t isIpv6Given = parse_u1be(view);
-	if (isIpv6Given == ITEM_INCLUDED_YES) {
-		ipv6->isNull = false;
-		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
-		view_parseBuffer(ipv6->ip, view, IPV6_SIZE);
-		TRACE("ipv6");
-		TRACE_BUFFER(ipv6->ip, IPV6_SIZE);
-	} else {
-		VALIDATE(isIpv6Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
-		ipv6->isNull = true;
-	}
-}
-
-static void _parseDnsName(pool_relay_t* relay, read_view_t* view)
-{
-	relay->dnsNameSize = view_remainingSize(view);
-	VALIDATE(relay->dnsNameSize <= DNS_NAME_SIZE_MAX, ERR_INVALID_DATA);
-	VALIDATE(str_isAllowedDnsName(VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)), ERR_INVALID_DATA);
-
-	STATIC_ASSERT(SIZEOF(relay->dnsName) == DNS_NAME_SIZE_MAX, "wrong dns name buffer size");
-	view_parseBuffer(relay->dnsName, view, relay->dnsNameSize);
-}
-
-/*
-wire data:
-1B relay format
-
-format 0 single_host_addr:
-1B + [2B port] + 1B + [4B ipv4] + 1B + [16B ipv6]
-
-format 1 single_host_name:
-1B + [2B port] + [0-64B dns_name]
-
-format 2 multi_host_name:
-[0-64B dns_name]
-*/
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleRelayAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_RELAYS);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	pool_relay_t* relay = &accessSubcontext()->stateData.relay;
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		relay->format = parse_u1be(&view);
-		TRACE("Relay format %u", relay->format);
-		switch (relay->format) {
-
-		// validation differs from the CDDL spec
-		// the CDDL spec allows combinations of parameters that lead
-		// to meaningless relays that are ignored by nodes
-		// so we only allow meaningful relays
-
-		case RELAY_SINGLE_HOST_IP: {
-			_parsePort(&relay->port, &view);
-			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
-			_parseIpv4(&relay->ipv4, &view);
-			_parseIpv6(&relay->ipv6, &view);
-			VALIDATE(!relay->ipv4.isNull || !relay->ipv6.isNull, ERR_INVALID_DATA);
-			break;
-		}
-
-		case RELAY_SINGLE_HOST_NAME: {
-			_parsePort(&relay->port, &view);
-			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
-			_parseDnsName(relay, &view);
-			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
-			break;
-		}
-
-		case RELAY_MULTIPLE_HOST_NAME: {
-			_parseDnsName(relay, &view);
-			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
-			break;
-		}
-
-		default:
-			THROW(ERR_INVALID_DATA);
-		}
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationRelay(commonTxData->txSigningMode, relay);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	TRACE("Adding relay format %d to tx hash", (int) relay->format);
-	txHashBuilder_addPoolRegistrationCertificate_addRelay(&BODY_CTX->txHashBuilder, relay);
-
-	{
-		int respondStep = -1;
-		int displayStep = -1;
-		void (*uiFn)() = NULL;
-
-		switch (relay->format) {
-
-		case RELAY_SINGLE_HOST_IP: {
-			respondStep = HANDLE_RELAY_IP_STEP_RESPOND;
-			displayStep = HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER;
-			uiFn = handleRelay_ip_ui_runStep;
-			break;
-		}
-
-		case RELAY_SINGLE_HOST_NAME:
-		case RELAY_MULTIPLE_HOST_NAME: {
-			respondStep = HANDLE_RELAY_DNS_STEP_RESPOND;
-			displayStep = HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER;
-			uiFn = handleRelay_dns_ui_runStep;
-			break;
-		}
-
-		default:
-			THROW(ERR_INVALID_DATA);
-		}
-
-		ASSERT(respondStep != -1);
-		ASSERT(displayStep != -1);
-		ASSERT(uiFn != NULL);
-
-		// select UI steps and call ui handler
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, respondStep);
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayStep);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-
-		uiFn();
-	}
-}
-
-
-// ============================== METADATA ==============================
-
-enum {
-	HANDLE_NULL_METADATA_STEP_DISPLAY = 6900,
-	HANDLE_NULL_METADATA_STEP_RESPOND,
-	HANDLE_NULL_METADATA_STEP_INVALID,
-};
-
-static void handleNullMetadata_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleNullMetadata_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_NULL_METADATA_STEP_DISPLAY) {
-		ui_displayPaginatedText(
-		        "No metadata",
-		        "(anonymous pool)",
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_NULL_METADATA_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_NULL_METADATA_STEP_INVALID);
-}
-
-enum {
-	HANDLE_METADATA_STEP_DISPLAY_URL = 7000,
-	HANDLE_METADATA_STEP_DISPLAY_HASH,
-	HANDLE_METADATA_STEP_RESPOND,
-	HANDLE_METADATA_STEP_INVALID,
-};
-
-static void handleMetadata_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = handleMetadata_ui_runStep;
-
-	pool_metadata_t* md = &subctx->stateData.metadata;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_URL) {
-		char metadataUrlStr[1 + POOL_METADATA_URL_LENGTH_MAX] = {0};
-		explicit_bzero(metadataUrlStr, SIZEOF(metadataUrlStr));
-		ASSERT(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX);
-		memmove(metadataUrlStr, md->url, md->urlSize);
-		metadataUrlStr[md->urlSize] = '\0';
-		ASSERT(strlen(metadataUrlStr) == md->urlSize);
-
-		ui_displayPaginatedText(
-		        "Pool metadata url",
-		        metadataUrlStr,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_HASH) {
-		char metadataHashHex[1 + 2 * POOL_METADATA_HASH_LENGTH] = {0};
-		explicit_bzero(metadataHashHex, SIZEOF(metadataHashHex));
-		size_t len = str_formatMetadata(
-		                     md->hash, SIZEOF(md->hash),
-		                     metadataHashHex, SIZEOF(metadataHashHex)
-		             );
-		ASSERT(len + 1 == SIZEOF(metadataHashHex));
-
-		ui_displayPaginatedText(
-		        "Pool metadata hash",
-		        metadataHashHex,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_METADATA_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_METADATA_STEP_INVALID);
-}
-
-static void handleNullMetadata()
-{
-	security_policy_t policy = policyForSignTxStakePoolRegistrationNoMetadata();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// add null metadata to certificate
-		TRACE("Adding null pool metadata to tx hash");
-		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(&BODY_CTX->txHashBuilder);
-	}
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NULL_METADATA_STEP_DISPLAY);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NULL_METADATA_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handleNullMetadata_ui_runStep();
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handlePoolMetadataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		// sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_METADATA);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	explicit_bzero(&subctx->stateData.metadata, SIZEOF(subctx->stateData.metadata));
-
-	{
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-
-		pool_metadata_t* md = &subctx->stateData.metadata;
-
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		{
-			// deal with null metadata
-			uint8_t includeMetadataByte = parse_u1be(&view);
-			int includeMetadata = signTx_parseIncluded(includeMetadataByte);
-
-			if (!includeMetadata) {
-				VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-				handleNullMetadata();
-				return;
-			}
-		}
-		{
-			STATIC_ASSERT(SIZEOF(md->hash) == POOL_METADATA_HASH_LENGTH, "wrong pool metadata buffer size");
-			view_parseBuffer(md->hash, &view, POOL_METADATA_HASH_LENGTH);
-		}
-		{
-			md->urlSize = view_remainingSize(&view);
-			VALIDATE(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX, ERR_INVALID_DATA);
-			STATIC_ASSERT(SIZEOF(md->url) >= POOL_METADATA_URL_LENGTH_MAX, "wrong pool metada url size");
-			view_parseBuffer(md->url, &view, md->urlSize);
-
-			// whitespace not allowed
-			VALIDATE(str_isPrintableAsciiWithoutSpaces(md->url, md->urlSize), ERR_INVALID_DATA);
-		}
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	security_policy_t policy = policyForSignTxStakePoolRegistrationMetadata();
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// add metadata to tx
-		TRACE("Adding metadata hash to tx hash");
-		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.metadata.url, subctx->stateData.metadata.urlSize,
-		        subctx->stateData.metadata.hash, SIZEOF(subctx->stateData.metadata.hash)
-		);
-	}
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_METADATA_STEP_DISPLAY_URL);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_METADATA_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	handleMetadata_ui_runStep();
-}
-
-// ============================== CONFIRM ==============================
-
-enum {
-	HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS = 7100,
-	HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS,
-	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
-	HANDLE_CONFIRM_STEP_RESPOND,
-	HANDLE_CONFIRM_STEP_INVALID,
-};
-
-static void signTxPoolRegistration_handleConfirm_ui_runStep()
-{
-	pool_registration_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	TRACE_STACK_USAGE();
-	ui_callback_fn_t* this_fn = signTxPoolRegistration_handleConfirm_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	// we display potencially suspicious facts about the certificate
-	// that have not been explicitly shown to the user before:
-	// missing owners or relays
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS) {
-		if (subctx->numOwners == 0) {
-			ui_displayPaginatedText(
-			        "No",
-			        "pool owners",
-			        this_fn
-			);
-		} else {
-			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS);
-		}
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS) {
-		bool isOperator = commonTxData->txSigningMode == SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR;
-		if ((subctx->numRelays == 0) && isOperator) {
-			ui_displayPaginatedText(
-			        "No",
-			        "pool relays",
-			        this_fn
-			);
-		} else {
-			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
-		}
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm stake",
-		        "pool registration?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
-}
-
-__noinline_due_to_stack__
-static void signTxPoolRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	{
-		//sanity checks
-		CHECK_STATE(STAKE_POOL_REGISTRATION_CONFIRM);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	{
-		// no data to receive
-		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
-	}
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxStakePoolRegistrationConfirm(subctx->numOwners, subctx->numRelays);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxPoolRegistration_handleConfirm_ui_runStep();
-}
-
-
-// ============================== main APDU handler ==============================
-
-enum {
-	APDU_INSTRUCTION_INIT = 0x30,
-	APDU_INSTRUCTION_POOL_KEY = 0x31,
-	APDU_INSTRUCTION_VRF_KEY = 0x32,
-	APDU_INSTRUCTION_FINANCIALS = 0x33,
-	APDU_INSTRUCTION_REWARD_ACCOUNT = 0x34,
-	APDU_INSTRUCTION_OWNERS = 0x35,
-	APDU_INSTRUCTION_RELAYS = 0x36,
-	APDU_INSTRUCTION_METADATA = 0x37,
-	APDU_INSTRUCTION_CONFIRMATION = 0x38
-};
-
-bool signTxPoolRegistration_isValidInstruction(uint8_t p2)
-{
-	switch (p2) {
-	case APDU_INSTRUCTION_INIT:
-	case APDU_INSTRUCTION_POOL_KEY:
-	case APDU_INSTRUCTION_VRF_KEY:
-	case APDU_INSTRUCTION_FINANCIALS:
-	case APDU_INSTRUCTION_REWARD_ACCOUNT:
-	case APDU_INSTRUCTION_OWNERS:
-	case APDU_INSTRUCTION_RELAYS:
-	case APDU_INSTRUCTION_METADATA:
-	case APDU_INSTRUCTION_CONFIRMATION:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	TRACE_STACK_USAGE();
-	TRACE("p2 = 0x%x", p2);
-	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-
-	pool_registration_context_t* subctx = accessSubcontext();
-	explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
-
-	switch (p2) {
-	case APDU_INSTRUCTION_INIT:
-		signTxPoolRegistration_handleInitAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_POOL_KEY:
-		signTxPoolRegistration_handlePoolKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_VRF_KEY:
-		signTxPoolRegistration_handleVrfKeyAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_FINANCIALS:
-		signTxPoolRegistration_handlePoolFinancialsAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_REWARD_ACCOUNT:
-		signTxPoolRegistration_handleRewardAccountAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_OWNERS:
-		signTxPoolRegistration_handleOwnerAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_RELAYS:
-		signTxPoolRegistration_handleRelayAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_METADATA:
-		signTxPoolRegistration_handlePoolMetadataAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_CONFIRMATION:
-		signTxPoolRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	default:
-		// this is not supposed to be called with invalid p2
-		ASSERT(false);
-	}
-}
+// #include "signTx.h"
+// #include "state.h"
+// #include "cardano.h"
+// #include "addressUtilsShelley.h"
+// #include "keyDerivation.h"
+// #include "uiHelpers.h"
+// #include "signTxUtils.h"
+// #include "uiScreens.h"
+// #include "txHashBuilder.h"
+// #include "textUtils.h"
+// #include "hexUtils.h"
+// #include "bufView.h"
+// #include "securityPolicy.h"
+// #include "signTxPoolRegistration.h"
+
+// static ins_sign_tx_context_t* ctx = &(instructionState.signTxContext);
+// static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
+
+// static pool_registration_context_t* accessSubcontext()
+// {
+// 	return &BODY_CTX->stageContext.pool_registration_subctx;
+// }
+
+// bool signTxPoolRegistration_isFinished()
+// {
+// 	// we are also asserting that the state is valid
+// 	switch (accessSubcontext()->state) {
+// 	case STAKE_POOL_REGISTRATION_FINISHED:
+// 		return true;
+
+// 	case STAKE_POOL_REGISTRATION_INIT:
+// 	case STAKE_POOL_REGISTRATION_POOL_KEY:
+// 	case STAKE_POOL_REGISTRATION_VRF_KEY:
+// 	case STAKE_POOL_REGISTRATION_FINANCIALS:
+// 	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
+// 	case STAKE_POOL_REGISTRATION_OWNERS:
+// 	case STAKE_POOL_REGISTRATION_RELAYS:
+// 	case STAKE_POOL_REGISTRATION_METADATA:
+// 	case STAKE_POOL_REGISTRATION_CONFIRM:
+// 		return false;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// void signTxPoolRegistration_init()
+// {
+// 	explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
+
+// 	accessSubcontext()->state = STAKE_POOL_REGISTRATION_INIT;
+// }
+
+// static inline void CHECK_STATE(sign_tx_pool_registration_state_t expected)
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("Pool registration certificate stage: current %d, expected %d", subctx->state, expected);
+// 	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
+// }
+
+// static inline void advanceState()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("Advancing pool registration certificate state from: %d", subctx->state);
+
+// 	switch (subctx->state) {
+
+// 	case STAKE_POOL_REGISTRATION_INIT:
+// 		subctx->state = STAKE_POOL_REGISTRATION_POOL_KEY;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_POOL_KEY:
+// 		subctx->state = STAKE_POOL_REGISTRATION_VRF_KEY;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_VRF_KEY:
+// 		subctx->state = STAKE_POOL_REGISTRATION_FINANCIALS;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_FINANCIALS:
+// 		subctx->state = STAKE_POOL_REGISTRATION_REWARD_ACCOUNT;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_REWARD_ACCOUNT:
+// 		txHashBuilder_addPoolRegistrationCertificate_enterOwners(&BODY_CTX->txHashBuilder);
+// 		subctx->state = STAKE_POOL_REGISTRATION_OWNERS;
+
+// 		if (subctx->numOwners > 0) {
+// 			break;
+// 		}
+
+// 	// intentional fallthrough
+
+// 	case STAKE_POOL_REGISTRATION_OWNERS:
+// 		ASSERT(subctx->currentOwner == subctx->numOwners);
+
+// 		txHashBuilder_addPoolRegistrationCertificate_enterRelays(&BODY_CTX->txHashBuilder);
+// 		subctx->state = STAKE_POOL_REGISTRATION_RELAYS;
+
+// 		if (subctx->numRelays > 0) {
+// 			break;
+// 		}
+
+// 	// intentional fallthrough
+
+// 	case STAKE_POOL_REGISTRATION_RELAYS:
+// 		ASSERT(subctx->currentRelay == subctx->numRelays);
+
+// 		subctx->state = STAKE_POOL_REGISTRATION_METADATA;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_METADATA:
+// 		subctx->state = STAKE_POOL_REGISTRATION_CONFIRM;
+// 		break;
+
+// 	case STAKE_POOL_REGISTRATION_CONFIRM:
+// 		subctx->state = STAKE_POOL_REGISTRATION_FINISHED;
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	TRACE("Advancing pool registration certificate state to: %d", subctx->state);
+// }
+
+
+// // ============================== INIT ==============================
+
+// enum {
+// 	HANDLE_POOL_INIT_STEP_DISPLAY = 6100,
+// 	HANDLE_POOL_INIT_STEP_RESPOND,
+// 	HANDLE_POOL_INIT_STEP_INVALID,
+// } ;
+
+// static void handlePoolInit_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolInit_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_INIT_STEP_DISPLAY) {
+// 		ui_displayPaginatedText(
+// 		        "Pool registration",
+// 		        "certificate",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_INIT_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_INIT_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleInitAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_INIT);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	{
+// 		// initialization
+// 		subctx->currentOwner = 0;
+// 		subctx->currentRelay = 0;
+
+// 		explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+// 	}
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		struct {
+// 			uint8_t numOwners[4];
+// 			uint8_t numRelays[4];
+// 		}* wireHeader = (void*) wireDataBuffer;
+
+// 		// can't use SIZEOF because it fails for x86 for fuzzing
+// 		VALIDATE(wireDataSize == sizeof(*wireHeader), ERR_INVALID_DATA);
+
+// 		uint64_t numOwners = u4be_read(wireHeader->numOwners);
+// 		uint64_t numRelays = u4be_read(wireHeader->numRelays);
+// 		TRACE(
+// 		        "num owners, relays: %d %d",
+// 		        subctx->numOwners, subctx->numRelays
+// 		);
+
+// 		VALIDATE(subctx->numOwners <= POOL_MAX_OWNERS, ERR_INVALID_DATA);
+// 		VALIDATE(subctx->numRelays <= POOL_MAX_RELAYS, ERR_INVALID_DATA);
+// 		ASSERT_TYPE(subctx->numOwners, uint16_t);
+// 		ASSERT_TYPE(subctx->numRelays, uint16_t);
+// 		subctx->numOwners = (uint16_t) numOwners;
+// 		subctx->numRelays = (uint16_t) numRelays;
+// 	}
+// 	{
+// 		security_policy_t policy = policyForSignTxStakePoolRegistrationInit(
+// 		                                   commonTxData->txSigningMode,
+// 		                                   subctx->numOwners
+// 		                           );
+// 		TRACE("Policy: %d", (int) policy);
+// 		ENSURE_NOT_DENIED(policy);
+// 	}
+// 	{
+// 		txHashBuilder_poolRegistrationCertificate_enter(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->numOwners, subctx->numRelays
+// 		);
+// 	}
+
+// 	subctx->ui_step = HANDLE_POOL_INIT_STEP_DISPLAY;
+// 	handlePoolInit_ui_runStep();
+// }
+
+// // ============================== POOL KEY HASH / ID ==============================
+
+// static void _toPoolKeyHash(const pool_id_t* poolId, uint8_t* poolKeyHash)
+// {
+// 	switch (poolId->keyReferenceType) {
+
+// 	case KEY_REFERENCE_HASH: {
+// 		STATIC_ASSERT(SIZEOF(poolId->hash) == POOL_KEY_HASH_LENGTH, "wrong pool key hash length");
+// 		memmove(poolKeyHash, poolId->hash, POOL_KEY_HASH_LENGTH);
+// 		break;
+// 	}
+// 	case KEY_REFERENCE_PATH: {
+// 		bip44_pathToKeyHash(&poolId->path, poolKeyHash, POOL_KEY_HASH_LENGTH);
+// 		break;
+// 	}
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// enum {
+// 	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH = 6200,
+// 	HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID,
+// 	HANDLE_POOL_KEY_STEP_RESPOND,
+// 	HANDLE_POOL_KEY_STEP_INVALID,
+// } ;
+
+// static void handlePoolKey_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH) {
+// 		ui_displayPathScreen(
+// 		        "Pool ID path",
+// 		        &subctx->stateData.poolId.path,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID) {
+// 		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
+
+// 		ui_displayBech32Screen(
+// 		        "Pool ID",
+// 		        "pool",
+// 		        poolKeyHash, SIZEOF(poolKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_KEY_STEP_INVALID);
+// }
+
+// static void _parsePoolId(read_view_t* view)
+// {
+// 	pool_id_t* key = &accessSubcontext()->stateData.poolId;
+
+// 	key->keyReferenceType = parse_u1be(view);
+
+// 	switch (key->keyReferenceType) {
+
+// 	case KEY_REFERENCE_HASH: {
+// 		STATIC_ASSERT(SIZEOF(key->hash) == POOL_KEY_HASH_LENGTH, "wrong pool id key hash size");
+// 		view_parseBuffer(key->hash, view, POOL_KEY_HASH_LENGTH);
+// 		TRACE_BUFFER(key->hash, SIZEOF(key->hash));
+// 		break;
+// 	}
+
+// 	case KEY_REFERENCE_PATH: {
+// 		view_skipBytes(view, bip44_parseFromWire(&key->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
+// 		BIP44_PRINTF(&key->path);
+// 		PRINTF("\n");
+// 		break;
+// 	}
+
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handlePoolKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_POOL_KEY);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		_parsePoolId(&view);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationPoolId(
+// 	                                   commonTxData->txSigningMode,
+// 	                                   &subctx->stateData.poolId
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// key derivation must not be done before DENY security policy is enforced
+// 		uint8_t poolKeyHash[POOL_KEY_HASH_LENGTH] = {0};
+// 		_toPoolKeyHash(&subctx->stateData.poolId, poolKeyHash);
+
+// 		txHashBuilder_poolRegistrationCertificate_poolKeyHash(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        poolKeyHash, SIZEOF(poolKeyHash)
+// 		);
+// 	}
+// 	{
+// 		// ui step depends not only on security policy, but also on signing mode
+// 		int displayUiStep = HANDLE_POOL_KEY_STEP_INVALID;
+// 		switch (commonTxData->txSigningMode) {
+// 		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
+// 			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_ID;
+// 			break;
+
+// 		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
+// 			displayUiStep = HANDLE_POOL_KEY_STEP_DISPLAY_POOL_PATH;
+// 			break;
+
+// 		default:
+// 			ASSERT(false);
+// 		}
+// 		ASSERT(displayUiStep != HANDLE_POOL_KEY_STEP_INVALID);
+
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayUiStep);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handlePoolKey_ui_runStep();
+// }
+
+// // ============================== VRF KEY HASH ==============================
+
+// enum {
+// 	HANDLE_POOL_VRF_KEY_STEP_DISPLAY = 6300,
+// 	HANDLE_POOL_VRF_KEY_STEP_RESPOND,
+// 	HANDLE_POOL_VRF_KEY_STEP_INVALID,
+// } ;
+
+// static void handlePoolVrfKey_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolVrfKey_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_DISPLAY) {
+// 		ui_displayBech32Screen(
+// 		        "VRF key hash",
+// 		        "vrf_vk",
+// 		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash),
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_VRF_KEY_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_VRF_KEY_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleVrfKeyAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_VRF_KEY);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		VALIDATE(wireDataSize == SIZEOF(subctx->stateData.vrfKeyHash), ERR_INVALID_DATA);
+
+// 		{
+// 			STATIC_ASSERT(SIZEOF(subctx->stateData.vrfKeyHash) == VRF_KEY_HASH_LENGTH, "wrong vrfKeyHash size");
+// 			memmove(subctx->stateData.vrfKeyHash, wireDataBuffer, VRF_KEY_HASH_LENGTH);
+// 			// nothing to validate, all values are valid
+// 		}
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationVrfKey(
+// 	                                   commonTxData->txSigningMode
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.vrfKeyHash, SIZEOF(subctx->stateData.vrfKeyHash)
+// 		);
+// 	}
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_VRF_KEY_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_VRF_KEY_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handlePoolVrfKey_ui_runStep();
+// }
+
+// // ============================== POOL FINANCIALS ==============================
+
+// enum {
+// 	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE = 6400,
+// 	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST,
+// 	HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN,
+// 	HANDLE_POOL_FINANCIALS_STEP_RESPOND,
+// 	HANDLE_POOL_FINANCIALS_STEP_INVALID,
+// } ;
+
+// static void handlePoolFinancials_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolFinancials_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE) {
+// 		ui_displayAdaAmountScreen(
+// 		        "Pledge",
+// 		        subctx->stateData.pledge,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_COST) {
+// 		ui_displayAdaAmountScreen(
+// 		        "Cost",
+// 		        subctx->stateData.cost,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_DISPLAY_MARGIN) {
+// 		ui_displayPoolMarginScreen(
+// 		        subctx->stateData.marginNumerator,
+// 		        subctx->stateData.marginDenominator,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_FINANCIALS_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_FINANCIALS_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handlePoolFinancialsAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_FINANCIALS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		struct {
+// 			uint8_t pledge[8];
+// 			uint8_t cost[8];
+// 			uint8_t marginNumerator[8];
+// 			uint8_t marginDenominator[8];
+// 		}* wireHeader = (void*) wireDataBuffer;
+
+// 		VALIDATE(wireDataSize == SIZEOF(*wireHeader), ERR_INVALID_DATA);
+
+// 		{
+// 			ASSERT_TYPE(subctx->stateData.pledge, uint64_t);
+// 			subctx->stateData.pledge = u8be_read(wireHeader->pledge);
+// 			TRACE_ADA_AMOUNT("pledge ", subctx->stateData.pledge);
+// 			VALIDATE(subctx->stateData.pledge < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
+
+// 			ASSERT_TYPE(subctx->stateData.cost, uint64_t);
+// 			subctx->stateData.cost = u8be_read(wireHeader->cost);
+// 			TRACE_ADA_AMOUNT("cost ", subctx->stateData.cost);
+// 			VALIDATE(subctx->stateData.cost < LOVELACE_MAX_SUPPLY, ERR_INVALID_DATA);
+
+// 			ASSERT_TYPE(subctx->stateData.marginNumerator, uint64_t);
+// 			subctx->stateData.marginNumerator = u8be_read(wireHeader->marginNumerator);
+// 			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginNumerator, 8);
+// 			VALIDATE(subctx->stateData.marginNumerator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
+
+// 			ASSERT_TYPE(subctx->stateData.marginDenominator, uint64_t);
+// 			subctx->stateData.marginDenominator = u8be_read(wireHeader->marginDenominator);
+// 			TRACE_BUFFER((uint8_t *) &subctx->stateData.marginDenominator, 8);
+// 			VALIDATE(subctx->stateData.marginDenominator != 0, ERR_INVALID_DATA);
+// 			VALIDATE(subctx->stateData.marginDenominator <= MARGIN_DENOMINATOR_MAX, ERR_INVALID_DATA);
+// 			VALIDATE(subctx->stateData.marginNumerator <= subctx->stateData.marginDenominator, ERR_INVALID_DATA);
+// 		}
+// 	}
+// 	{
+// 		txHashBuilder_poolRegistrationCertificate_financials(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.pledge, subctx->stateData.cost,
+// 		        subctx->stateData.marginNumerator, subctx->stateData.marginDenominator
+// 		);
+// 	}
+
+// 	subctx->ui_step = HANDLE_POOL_FINANCIALS_STEP_DISPLAY_PLEDGE;
+// 	handlePoolFinancials_ui_runStep();
+// }
+
+// // ============================== POOL REWARD ACCOUNT ==============================
+
+// enum {
+// 	HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY = 6500,
+// 	HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND,
+// 	HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID,
+// };
+
+// static void handlePoolRewardAccount_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handlePoolRewardAccount_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY) {
+// 		ui_displayRewardAccountScreen(
+// 		        &subctx->stateData.poolRewardAccount,
+// 		        commonTxData->networkId,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_POOL_REWARD_ACCOUNT_STEP_INVALID);
+// }
+
+// static void _parsePoolRewardAccount(read_view_t* view)
+// {
+// 	reward_account_t* rewardAccount = &accessSubcontext()->stateData.poolRewardAccount;
+
+// 	rewardAccount->keyReferenceType = parse_u1be(view);
+
+// 	switch (rewardAccount->keyReferenceType) {
+
+// 	case KEY_REFERENCE_HASH: {
+// 		STATIC_ASSERT(SIZEOF(rewardAccount->hashBuffer) == REWARD_ACCOUNT_SIZE, "wrong reward account hash buffer size");
+// 		view_parseBuffer(rewardAccount->hashBuffer, view, REWARD_ACCOUNT_SIZE);
+// 		TRACE_BUFFER(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
+
+// 		const uint8_t header = getAddressHeader(rewardAccount->hashBuffer, SIZEOF(rewardAccount->hashBuffer));
+// 		VALIDATE(getAddressType(header) == REWARD_KEY || getAddressType(header) == REWARD_SCRIPT, ERR_INVALID_DATA);
+// 		VALIDATE(getNetworkId(header) == commonTxData->networkId, ERR_INVALID_DATA);
+// 		break;
+// 	}
+
+// 	case KEY_REFERENCE_PATH: {
+// 		view_skipBytes(view, bip44_parseFromWire(&rewardAccount->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)));
+// 		BIP44_PRINTF(&rewardAccount->path);
+// 		PRINTF("\n");
+// 		break;
+// 	}
+
+// 	default:
+// 		THROW(ERR_INVALID_DATA);
+// 	}
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleRewardAccountAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_REWARD_ACCOUNT);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	{
+// 		// parse data
+
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		_parsePoolRewardAccount(&view);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationRewardAccount(
+// 	                                   commonTxData->txSigningMode,
+// 	                                   &subctx->stateData.poolRewardAccount
+// 	                           );
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// key derivation must not be done before DENY security policy is enforced
+// 		uint8_t rewardAccountBuffer[REWARD_ACCOUNT_SIZE] = {0};
+// 		rewardAccountToBuffer(&subctx->stateData.poolRewardAccount, commonTxData->networkId, rewardAccountBuffer);
+
+// 		txHashBuilder_poolRegistrationCertificate_rewardAccount(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        rewardAccountBuffer, SIZEOF(rewardAccountBuffer)
+// 		);
+// 	}
+
+// 	{
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_POOL_REWARD_ACCOUNT_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_POOL_REWARD_ACCOUNT_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handlePoolRewardAccount_ui_runStep();
+// }
+
+// // ============================== OWNER ==============================
+
+// enum {
+// 	HANDLE_OWNER_STEP_DISPLAY = 6600,
+// 	HANDLE_OWNER_STEP_RESPOND,
+// 	HANDLE_OWNER_STEP_INVALID,
+// };
+
+// static void handleOwner_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleOwner_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_OWNER_STEP_DISPLAY) {
+// 		ui_displayPoolOwnerScreen(&subctx->stateData.owner, subctx->currentOwner, commonTxData->networkId, this_fn);
+// 	}
+// 	UI_STEP(HANDLE_OWNER_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		subctx->currentOwner++;
+// 		if (subctx->currentOwner == subctx->numOwners) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_OWNER_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void _addOwnerToTxHash()
+// {
+// 	pool_owner_t* owner = &accessSubcontext()->stateData.owner;
+
+// 	uint8_t ownerKeyHash[ADDRESS_KEY_HASH_LENGTH] = {0};
+
+// 	switch (owner->keyReferenceType) {
+
+// 	case KEY_REFERENCE_PATH:
+// 		bip44_pathToKeyHash(&owner->path, ownerKeyHash, SIZEOF(ownerKeyHash));
+// 		break;
+
+// 	case KEY_REFERENCE_HASH:
+// 		memmove(ownerKeyHash, owner->keyHash, SIZEOF(ownerKeyHash));
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	// add data to tx
+// 	TRACE("Adding owner to tx hash");
+// 	txHashBuilder_addPoolRegistrationCertificate_addOwner(
+// 	        &BODY_CTX->txHashBuilder,
+// 	        ownerKeyHash, SIZEOF(ownerKeyHash)
+// 	);
+// 	TRACE();
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleOwnerAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_OWNERS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	pool_owner_t* owner = &subctx->stateData.owner;
+
+// 	explicit_bzero(owner, SIZEOF(*owner));
+
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		owner->keyReferenceType = parse_u1be(&view);
+// 		switch (owner->keyReferenceType) {
+
+// 		case KEY_REFERENCE_HASH: {
+// 			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
+// 			view_parseBuffer(owner->keyHash, &view, ADDRESS_KEY_HASH_LENGTH);
+// 			TRACE_BUFFER(owner->keyHash, SIZEOF(owner->keyHash));
+// 			break;
+// 		}
+
+// 		case KEY_REFERENCE_PATH: {
+// 			view_skipBytes(&view, bip44_parseFromWire(&owner->path, VIEW_REMAINING_TO_TUPLE_BUF_SIZE(&view)));
+// 			// further validation of the path in security policy below
+// 			TRACE("Owner given by path:");
+// 			BIP44_PRINTF(&owner->path);
+// 			PRINTF("\n");
+
+// 			subctx->numOwnersGivenByPath++;
+// 			VALIDATE(!ctx->poolOwnerByPath, ERR_INVALID_DATA);
+// 			ctx->poolOwnerByPath = true;
+// 			memmove(&ctx->poolOwnerPath, &owner->path, SIZEOF(owner->path));
+// 			break;
+// 		}
+
+// 		default:
+// 			THROW(ERR_INVALID_DATA);
+// 		}
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationOwner(commonTxData->txSigningMode, owner, subctx->numOwnersGivenByPath);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	_addOwnerToTxHash();
+
+// 	{
+// 		// select UI steps
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_OWNER_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_OWNER_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handleOwner_ui_runStep();
+// }
+
+
+// // ============================== RELAY ==============================
+
+// enum {
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER = 6700,
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_IPV4,
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_IPV6,
+// 	HANDLE_RELAY_IP_STEP_DISPLAY_PORT,
+// 	HANDLE_RELAY_IP_STEP_RESPOND,
+// 	HANDLE_RELAY_IP_STEP_INVALID,
+// };
+
+// static void handleRelay_ip_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleRelay_ip_ui_runStep;
+
+// 	pool_relay_t* relay = &subctx->stateData.relay;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER) {
+// 		ui_displayPoolRelayScreen(
+// 		        relay,
+// 		        subctx->currentRelay,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV4) {
+// 		ui_displayIpv4Screen(
+// 		        &relay->ipv4,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_IPV6) {
+// 		ui_displayIpv6Screen(
+// 		        &relay->ipv6,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_DISPLAY_PORT) {
+// 		ui_displayIpPortScreen(
+// 		        &relay->port,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_IP_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		subctx->currentRelay++;
+// 		TRACE("current relay %d", subctx->currentRelay);
+
+// 		if (subctx->currentRelay == subctx->numRelays) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_RELAY_IP_STEP_INVALID);
+// }
+
+// enum {
+// 	HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER = 6800,
+// 	HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME,
+// 	HANDLE_RELAY_DNS_STEP_DISPLAY_PORT,
+// 	HANDLE_RELAY_DNS_STEP_RESPOND,
+// 	HANDLE_RELAY_DNS_STEP_INVALID,
+// };
+
+// static void handleRelay_dns_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleRelay_dns_ui_runStep;
+
+// 	pool_relay_t* relay = &subctx->stateData.relay;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER) {
+// 		ui_displayPoolRelayScreen(
+// 		        relay,
+// 		        subctx->currentRelay,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_DNSNAME) {
+// 		char dnsNameStr[1 + DNS_NAME_SIZE_MAX] = {0};
+// 		explicit_bzero(dnsNameStr, SIZEOF(dnsNameStr));
+// 		ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
+// 		memmove(dnsNameStr, relay->dnsName, relay->dnsNameSize);
+// 		dnsNameStr[relay->dnsNameSize] = '\0';
+// 		ASSERT(strlen(dnsNameStr) == relay->dnsNameSize);
+
+// 		ui_displayPaginatedText(
+// 		        "DNS name",
+// 		        dnsNameStr,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_DISPLAY_PORT) {
+// 		if (relay->format == RELAY_MULTIPLE_HOST_NAME) {
+// 			// nothing to display in this step, so we skip it
+// 			UI_STEP_JUMP(HANDLE_RELAY_DNS_STEP_RESPOND);
+// 		}
+
+// 		ui_displayIpPortScreen(
+// 		        &relay->port,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_RELAY_DNS_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		subctx->currentRelay++;
+// 		TRACE("current relay %d", subctx->currentRelay);
+
+// 		if (subctx->currentRelay == subctx->numRelays) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_RELAY_DNS_STEP_INVALID);
+// }
+
+// static void _parsePort(ipport_t* port, read_view_t* view)
+// {
+// 	uint8_t isPortGiven = parse_u1be(view);
+// 	if (isPortGiven == ITEM_INCLUDED_YES) {
+// 		port->isNull = false;
+// 		ASSERT_TYPE(port->number, uint16_t);
+// 		port->number = parse_u2be(view);
+// 		TRACE("Port: %u", port->number);
+// 	} else {
+// 		VALIDATE(isPortGiven == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
+// 		port->isNull = true;
+// 	}
+// }
+
+// static void _parseIpv4(ipv4_t* ipv4, read_view_t* view)
+// {
+// 	uint8_t isIpv4Given = parse_u1be(view);
+// 	if (isIpv4Given == ITEM_INCLUDED_YES) {
+// 		ipv4->isNull = false;
+// 		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
+// 		view_parseBuffer(ipv4->ip, view, IPV4_SIZE);
+// 		TRACE("ipv4");
+// 		TRACE_BUFFER(ipv4->ip, IPV4_SIZE);
+// 	} else {
+// 		VALIDATE(isIpv4Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
+// 		ipv4->isNull = true;
+// 	}
+// }
+
+// static void _parseIpv6(ipv6_t* ipv6, read_view_t* view)
+// {
+// 	uint8_t isIpv6Given = parse_u1be(view);
+// 	if (isIpv6Given == ITEM_INCLUDED_YES) {
+// 		ipv6->isNull = false;
+// 		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
+// 		view_parseBuffer(ipv6->ip, view, IPV6_SIZE);
+// 		TRACE("ipv6");
+// 		TRACE_BUFFER(ipv6->ip, IPV6_SIZE);
+// 	} else {
+// 		VALIDATE(isIpv6Given == ITEM_INCLUDED_NO, ERR_INVALID_DATA);
+// 		ipv6->isNull = true;
+// 	}
+// }
+
+// static void _parseDnsName(pool_relay_t* relay, read_view_t* view)
+// {
+// 	relay->dnsNameSize = view_remainingSize(view);
+// 	VALIDATE(relay->dnsNameSize <= DNS_NAME_SIZE_MAX, ERR_INVALID_DATA);
+// 	VALIDATE(str_isAllowedDnsName(VIEW_REMAINING_TO_TUPLE_BUF_SIZE(view)), ERR_INVALID_DATA);
+
+// 	STATIC_ASSERT(SIZEOF(relay->dnsName) == DNS_NAME_SIZE_MAX, "wrong dns name buffer size");
+// 	view_parseBuffer(relay->dnsName, view, relay->dnsNameSize);
+// }
+
+// /*
+// wire data:
+// 1B relay format
+
+// format 0 single_host_addr:
+// 1B + [2B port] + 1B + [4B ipv4] + 1B + [16B ipv6]
+
+// format 1 single_host_name:
+// 1B + [2B port] + [0-64B dns_name]
+
+// format 2 multi_host_name:
+// [0-64B dns_name]
+// */
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleRelayAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_RELAYS);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	pool_relay_t* relay = &accessSubcontext()->stateData.relay;
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		relay->format = parse_u1be(&view);
+// 		TRACE("Relay format %u", relay->format);
+// 		switch (relay->format) {
+
+// 		// validation differs from the CDDL spec
+// 		// the CDDL spec allows combinations of parameters that lead
+// 		// to meaningless relays that are ignored by nodes
+// 		// so we only allow meaningful relays
+
+// 		case RELAY_SINGLE_HOST_IP: {
+// 			_parsePort(&relay->port, &view);
+// 			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
+// 			_parseIpv4(&relay->ipv4, &view);
+// 			_parseIpv6(&relay->ipv6, &view);
+// 			VALIDATE(!relay->ipv4.isNull || !relay->ipv6.isNull, ERR_INVALID_DATA);
+// 			break;
+// 		}
+
+// 		case RELAY_SINGLE_HOST_NAME: {
+// 			_parsePort(&relay->port, &view);
+// 			VALIDATE(!relay->port.isNull, ERR_INVALID_DATA);
+// 			_parseDnsName(relay, &view);
+// 			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
+// 			break;
+// 		}
+
+// 		case RELAY_MULTIPLE_HOST_NAME: {
+// 			_parseDnsName(relay, &view);
+// 			VALIDATE(relay->dnsNameSize > 0, ERR_INVALID_DATA);
+// 			break;
+// 		}
+
+// 		default:
+// 			THROW(ERR_INVALID_DATA);
+// 		}
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationRelay(commonTxData->txSigningMode, relay);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	TRACE("Adding relay format %d to tx hash", (int) relay->format);
+// 	txHashBuilder_addPoolRegistrationCertificate_addRelay(&BODY_CTX->txHashBuilder, relay);
+
+// 	{
+// 		int respondStep = -1;
+// 		int displayStep = -1;
+// 		void (*uiFn)() = NULL;
+
+// 		switch (relay->format) {
+
+// 		case RELAY_SINGLE_HOST_IP: {
+// 			respondStep = HANDLE_RELAY_IP_STEP_RESPOND;
+// 			displayStep = HANDLE_RELAY_IP_STEP_DISPLAY_NUMBER;
+// 			uiFn = handleRelay_ip_ui_runStep;
+// 			break;
+// 		}
+
+// 		case RELAY_SINGLE_HOST_NAME:
+// 		case RELAY_MULTIPLE_HOST_NAME: {
+// 			respondStep = HANDLE_RELAY_DNS_STEP_RESPOND;
+// 			displayStep = HANDLE_RELAY_DNS_STEP_DISPLAY_NUMBER;
+// 			uiFn = handleRelay_dns_ui_runStep;
+// 			break;
+// 		}
+
+// 		default:
+// 			THROW(ERR_INVALID_DATA);
+// 		}
+
+// 		ASSERT(respondStep != -1);
+// 		ASSERT(displayStep != -1);
+// 		ASSERT(uiFn != NULL);
+
+// 		// select UI steps and call ui handler
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, respondStep);
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, displayStep);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+
+// 		uiFn();
+// 	}
+// }
+
+
+// // ============================== METADATA ==============================
+
+// enum {
+// 	HANDLE_NULL_METADATA_STEP_DISPLAY = 6900,
+// 	HANDLE_NULL_METADATA_STEP_RESPOND,
+// 	HANDLE_NULL_METADATA_STEP_INVALID,
+// };
+
+// static void handleNullMetadata_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleNullMetadata_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_NULL_METADATA_STEP_DISPLAY) {
+// 		ui_displayPaginatedText(
+// 		        "No metadata",
+// 		        "(anonymous pool)",
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_NULL_METADATA_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_NULL_METADATA_STEP_INVALID);
+// }
+
+// enum {
+// 	HANDLE_METADATA_STEP_DISPLAY_URL = 7000,
+// 	HANDLE_METADATA_STEP_DISPLAY_HASH,
+// 	HANDLE_METADATA_STEP_RESPOND,
+// 	HANDLE_METADATA_STEP_INVALID,
+// };
+
+// static void handleMetadata_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = handleMetadata_ui_runStep;
+
+// 	pool_metadata_t* md = &subctx->stateData.metadata;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_URL) {
+// 		char metadataUrlStr[1 + POOL_METADATA_URL_LENGTH_MAX] = {0};
+// 		explicit_bzero(metadataUrlStr, SIZEOF(metadataUrlStr));
+// 		ASSERT(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX);
+// 		memmove(metadataUrlStr, md->url, md->urlSize);
+// 		metadataUrlStr[md->urlSize] = '\0';
+// 		ASSERT(strlen(metadataUrlStr) == md->urlSize);
+
+// 		ui_displayPaginatedText(
+// 		        "Pool metadata url",
+// 		        metadataUrlStr,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_METADATA_STEP_DISPLAY_HASH) {
+// 		char metadataHashHex[1 + 2 * POOL_METADATA_HASH_LENGTH] = {0};
+// 		explicit_bzero(metadataHashHex, SIZEOF(metadataHashHex));
+// 		size_t len = str_formatMetadata(
+// 		                     md->hash, SIZEOF(md->hash),
+// 		                     metadataHashHex, SIZEOF(metadataHashHex)
+// 		             );
+// 		ASSERT(len + 1 == SIZEOF(metadataHashHex));
+
+// 		ui_displayPaginatedText(
+// 		        "Pool metadata hash",
+// 		        metadataHashHex,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_METADATA_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_METADATA_STEP_INVALID);
+// }
+
+// static void handleNullMetadata()
+// {
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationNoMetadata();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// add null metadata to certificate
+// 		TRACE("Adding null pool metadata to tx hash");
+// 		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(&BODY_CTX->txHashBuilder);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {accessSubcontext()->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_NULL_METADATA_STEP_DISPLAY);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_NULL_METADATA_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handleNullMetadata_ui_runStep();
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handlePoolMetadataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_METADATA);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	explicit_bzero(&subctx->stateData.metadata, SIZEOF(subctx->stateData.metadata));
+
+// 	{
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+
+// 		pool_metadata_t* md = &subctx->stateData.metadata;
+
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		{
+// 			// deal with null metadata
+// 			uint8_t includeMetadataByte = parse_u1be(&view);
+// 			int includeMetadata = signTx_parseIncluded(includeMetadataByte);
+
+// 			if (!includeMetadata) {
+// 				VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 				handleNullMetadata();
+// 				return;
+// 			}
+// 		}
+// 		{
+// 			STATIC_ASSERT(SIZEOF(md->hash) == POOL_METADATA_HASH_LENGTH, "wrong pool metadata buffer size");
+// 			view_parseBuffer(md->hash, &view, POOL_METADATA_HASH_LENGTH);
+// 		}
+// 		{
+// 			md->urlSize = view_remainingSize(&view);
+// 			VALIDATE(md->urlSize <= POOL_METADATA_URL_LENGTH_MAX, ERR_INVALID_DATA);
+// 			STATIC_ASSERT(SIZEOF(md->url) >= POOL_METADATA_URL_LENGTH_MAX, "wrong pool metada url size");
+// 			view_parseBuffer(md->url, &view, md->urlSize);
+
+// 			// whitespace not allowed
+// 			VALIDATE(str_isPrintableAsciiWithoutSpaces(md->url, md->urlSize), ERR_INVALID_DATA);
+// 		}
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationMetadata();
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// add metadata to tx
+// 		TRACE("Adding metadata hash to tx hash");
+// 		txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.metadata.url, subctx->stateData.metadata.urlSize,
+// 		        subctx->stateData.metadata.hash, SIZEOF(subctx->stateData.metadata.hash)
+// 		);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_METADATA_STEP_DISPLAY_URL);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_METADATA_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	handleMetadata_ui_runStep();
+// }
+
+// // ============================== CONFIRM ==============================
+
+// enum {
+// 	HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS = 7100,
+// 	HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS,
+// 	HANDLE_CONFIRM_STEP_FINAL_CONFIRM,
+// 	HANDLE_CONFIRM_STEP_RESPOND,
+// 	HANDLE_CONFIRM_STEP_INVALID,
+// };
+
+// static void signTxPoolRegistration_handleConfirm_ui_runStep()
+// {
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	TRACE_STACK_USAGE();
+// 	ui_callback_fn_t* this_fn = signTxPoolRegistration_handleConfirm_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	// we display potencially suspicious facts about the certificate
+// 	// that have not been explicitly shown to the user before:
+// 	// missing owners or relays
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS) {
+// 		if (subctx->numOwners == 0) {
+// 			ui_displayPaginatedText(
+// 			        "No",
+// 			        "pool owners",
+// 			        this_fn
+// 			);
+// 		} else {
+// 			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS);
+// 		}
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_NO_RELAYS) {
+// 		bool isOperator = commonTxData->txSigningMode == SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR;
+// 		if ((subctx->numRelays == 0) && isOperator) {
+// 			ui_displayPaginatedText(
+// 			        "No",
+// 			        "pool relays",
+// 			        this_fn
+// 			);
+// 		} else {
+// 			UI_STEP_JUMP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
+// 		}
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm stake",
+// 		        "pool registration?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
+// }
+
+// __noinline_due_to_stack__
+// static void signTxPoolRegistration_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	{
+// 		//sanity checks
+// 		CHECK_STATE(STAKE_POOL_REGISTRATION_CONFIRM);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	{
+// 		// no data to receive
+// 		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxStakePoolRegistrationConfirm(subctx->numOwners, subctx->numRelays);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_NO_OWNERS);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxPoolRegistration_handleConfirm_ui_runStep();
+// }
+
+
+// // ============================== main APDU handler ==============================
+
+// enum {
+// 	APDU_INSTRUCTION_INIT = 0x30,
+// 	APDU_INSTRUCTION_POOL_KEY = 0x31,
+// 	APDU_INSTRUCTION_VRF_KEY = 0x32,
+// 	APDU_INSTRUCTION_FINANCIALS = 0x33,
+// 	APDU_INSTRUCTION_REWARD_ACCOUNT = 0x34,
+// 	APDU_INSTRUCTION_OWNERS = 0x35,
+// 	APDU_INSTRUCTION_RELAYS = 0x36,
+// 	APDU_INSTRUCTION_METADATA = 0x37,
+// 	APDU_INSTRUCTION_CONFIRMATION = 0x38
+// };
+
+// bool signTxPoolRegistration_isValidInstruction(uint8_t p2)
+// {
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_INIT:
+// 	case APDU_INSTRUCTION_POOL_KEY:
+// 	case APDU_INSTRUCTION_VRF_KEY:
+// 	case APDU_INSTRUCTION_FINANCIALS:
+// 	case APDU_INSTRUCTION_REWARD_ACCOUNT:
+// 	case APDU_INSTRUCTION_OWNERS:
+// 	case APDU_INSTRUCTION_RELAYS:
+// 	case APDU_INSTRUCTION_METADATA:
+// 	case APDU_INSTRUCTION_CONFIRMATION:
+// 		return true;
+
+// 	default:
+// 		return false;
+// 	}
+// }
+
+// void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	TRACE_STACK_USAGE();
+// 	TRACE("p2 = 0x%x", p2);
+// 	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+
+// 	pool_registration_context_t* subctx = accessSubcontext();
+// 	explicit_bzero(&subctx->stateData, SIZEOF(subctx->stateData));
+
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_INIT:
+// 		signTxPoolRegistration_handleInitAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_POOL_KEY:
+// 		signTxPoolRegistration_handlePoolKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_VRF_KEY:
+// 		signTxPoolRegistration_handleVrfKeyAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_FINANCIALS:
+// 		signTxPoolRegistration_handlePoolFinancialsAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_REWARD_ACCOUNT:
+// 		signTxPoolRegistration_handleRewardAccountAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_OWNERS:
+// 		signTxPoolRegistration_handleOwnerAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_RELAYS:
+// 		signTxPoolRegistration_handleRelayAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_METADATA:
+// 		signTxPoolRegistration_handlePoolMetadataAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_CONFIRMATION:
+// 		signTxPoolRegistration_handleConfirmAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	default:
+// 		// this is not supposed to be called with invalid p2
+// 		ASSERT(false);
+// 	}
+// }
diff --git a/src/signTxPoolRegistration.h b/src/signTxPoolRegistration.h
index 21eb19c..7323d90 100644
--- a/src/signTxPoolRegistration.h
+++ b/src/signTxPoolRegistration.h
@@ -1,86 +1,86 @@
-#ifndef H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
-#define H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
-
-#include "common.h"
-#include "cardano.h"
-#include "txHashBuilder.h"
-
-#define POOL_MAX_OWNERS 1000
-#define POOL_MAX_RELAYS 1000
-
-// SIGN_STAGE_BODY_CERTIFICATES = 28
-// CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION = 3
-typedef enum {
-	STAKE_POOL_REGISTRATION_INIT = 2830,
-	STAKE_POOL_REGISTRATION_POOL_KEY = 2831,
-	STAKE_POOL_REGISTRATION_VRF_KEY = 2832,
-	STAKE_POOL_REGISTRATION_FINANCIALS = 2833,
-	STAKE_POOL_REGISTRATION_REWARD_ACCOUNT = 2834,
-	STAKE_POOL_REGISTRATION_OWNERS = 2835,
-	STAKE_POOL_REGISTRATION_RELAYS = 2836,
-	STAKE_POOL_REGISTRATION_METADATA = 2837,
-	STAKE_POOL_REGISTRATION_CONFIRM = 2838,
-	STAKE_POOL_REGISTRATION_FINISHED = 2839,
-} sign_tx_pool_registration_state_t;
-
-typedef struct {
-	key_reference_type_t keyReferenceType;
-	union {
-		bip44_path_t path;
-		uint8_t hash[POOL_KEY_HASH_LENGTH];
-	};
-} pool_id_t;
-
-typedef struct {
-	key_reference_type_t keyReferenceType;
-	union {
-		bip44_path_t path;
-		uint8_t keyHash[ADDRESS_KEY_HASH_LENGTH];
-	};
-} pool_owner_t;
-
-typedef struct {
-	uint8_t url[POOL_METADATA_URL_LENGTH_MAX];
-	size_t urlSize;
-	uint8_t hash[POOL_METADATA_HASH_LENGTH];
-} pool_metadata_t;
-
-
-typedef struct {
-	sign_tx_pool_registration_state_t state;
-
-	int ui_step;
-
-	uint16_t currentOwner;
-	uint16_t numOwnersGivenByPath;
-	uint16_t currentRelay;
-
-	uint16_t numOwners;
-	uint16_t numRelays;
-
-	// this holds data valid only through the processing of a single APDU
-	union {
-		pool_id_t poolId;
-		uint8_t vrfKeyHash[VRF_KEY_HASH_LENGTH];
-		struct {
-			uint64_t pledge;
-			uint64_t cost;
-			uint64_t marginNumerator;
-			uint64_t marginDenominator;
-		};
-		reward_account_t poolRewardAccount;
-		pool_owner_t owner;
-		pool_relay_t relay;
-		pool_metadata_t metadata;
-	} stateData;
-} pool_registration_context_t;
-
-
-void signTxPoolRegistration_init();
-
-bool signTxPoolRegistration_isValidInstruction(uint8_t p2);
-void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
-
-bool signTxPoolRegistration_isFinished();
-
-#endif // H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
+// #ifndef H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
+// #define H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
+
+// #include "common.h"
+// #include "cardano.h"
+// #include "txHashBuilder.h"
+
+// #define POOL_MAX_OWNERS 1000
+// #define POOL_MAX_RELAYS 1000
+
+// // SIGN_STAGE_BODY_CERTIFICATES = 28
+// // CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION = 3
+// typedef enum {
+// 	STAKE_POOL_REGISTRATION_INIT = 2830,
+// 	STAKE_POOL_REGISTRATION_POOL_KEY = 2831,
+// 	STAKE_POOL_REGISTRATION_VRF_KEY = 2832,
+// 	STAKE_POOL_REGISTRATION_FINANCIALS = 2833,
+// 	STAKE_POOL_REGISTRATION_REWARD_ACCOUNT = 2834,
+// 	STAKE_POOL_REGISTRATION_OWNERS = 2835,
+// 	STAKE_POOL_REGISTRATION_RELAYS = 2836,
+// 	STAKE_POOL_REGISTRATION_METADATA = 2837,
+// 	STAKE_POOL_REGISTRATION_CONFIRM = 2838,
+// 	STAKE_POOL_REGISTRATION_FINISHED = 2839,
+// } sign_tx_pool_registration_state_t;
+
+// typedef struct {
+// 	key_reference_type_t keyReferenceType;
+// 	union {
+// 		bip44_path_t path;
+// 		uint8_t hash[POOL_KEY_HASH_LENGTH];
+// 	};
+// } pool_id_t;
+
+// typedef struct {
+// 	key_reference_type_t keyReferenceType;
+// 	union {
+// 		bip44_path_t path;
+// 		uint8_t keyHash[ADDRESS_KEY_HASH_LENGTH];
+// 	};
+// } pool_owner_t;
+
+// typedef struct {
+// 	uint8_t url[POOL_METADATA_URL_LENGTH_MAX];
+// 	size_t urlSize;
+// 	uint8_t hash[POOL_METADATA_HASH_LENGTH];
+// } pool_metadata_t;
+
+
+// typedef struct {
+// 	sign_tx_pool_registration_state_t state;
+
+// 	int ui_step;
+
+// 	uint16_t currentOwner;
+// 	uint16_t numOwnersGivenByPath;
+// 	uint16_t currentRelay;
+
+// 	uint16_t numOwners;
+// 	uint16_t numRelays;
+
+// 	// this holds data valid only through the processing of a single APDU
+// 	union {
+// 		pool_id_t poolId;
+// 		uint8_t vrfKeyHash[VRF_KEY_HASH_LENGTH];
+// 		struct {
+// 			uint64_t pledge;
+// 			uint64_t cost;
+// 			uint64_t marginNumerator;
+// 			uint64_t marginDenominator;
+// 		};
+// 		reward_account_t poolRewardAccount;
+// 		pool_owner_t owner;
+// 		pool_relay_t relay;
+// 		pool_metadata_t metadata;
+// 	} stateData;
+// } pool_registration_context_t;
+
+
+// void signTxPoolRegistration_init();
+
+// bool signTxPoolRegistration_isValidInstruction(uint8_t p2);
+// void signTxPoolRegistration_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
+
+// bool signTxPoolRegistration_isFinished();
+
+// #endif // H_CARDANO_APP_SIGN_TX_POOL_REGISTRATION
diff --git a/src/state.h b/src/state.h
index 8549086..79504b8 100644
--- a/src/state.h
+++ b/src/state.h
@@ -6,7 +6,7 @@
 #include "deriveAddress.h"
 #include "deriveNativeScriptHash.h"
 #include "signTx.h"
-#include "signOpCert.h"
+// #include "signOpCert.h"
 
 
 typedef union {
@@ -15,7 +15,7 @@ typedef union {
 	ins_derive_address_context_t deriveAddressContext;
 	ins_derive_native_script_hash_context_t deriveNativeScriptHashContext;
 	ins_sign_tx_context_t signTxContext;
-	ins_sign_op_cert_context_t signOpCertContext;
+	// ins_sign_op_cert_context_t signOpCertContext;
 } instructionState_t;
 
 // Note(instructions are uint8_t but we have a special INS_NONE value
diff --git a/src/txHashBuilder.c b/src/txHashBuilder.c
index 9749fb5..2ee0548 100644
--- a/src/txHashBuilder.c
+++ b/src/txHashBuilder.c
@@ -460,8 +460,8 @@ void txHashBuilder_enterCertificates(tx_hash_builder_t* builder)
 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->remainingCertificates);
 	}
 
-	builder->poolCertificateData.remainingOwners = 0;
-	builder->poolCertificateData.remainingRelays = 0;
+	// builder->poolCertificateData.remainingOwners = 0;
+	// builder->poolCertificateData.remainingRelays = 0;
 
 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
 }
@@ -574,432 +574,432 @@ void txHashBuilder_addCertificate_delegation(
 	}
 }
 
-void txHashBuilder_addCertificate_poolRetirement(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize,
-        uint64_t epoch
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
-	ASSERT(builder->remainingCertificates > 0);
-	builder->remainingCertificates--;
-
-	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
-
-	// Array(3)[
-	//   Unsigned[4]
-	//   Bytes[poolKeyHash]
-	//   Unsigned[epoch]
-	// ]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 4);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
-			BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
-		}
-		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, epoch);
-	}
-}
-
-void txHashBuilder_poolRegistrationCertificate_enter(
-        tx_hash_builder_t* builder,
-        uint16_t numOwners, uint16_t numRelays
-)
-{
-	_TRACE("state = %d, remainingCertificates = %u", builder->state, builder->remainingCertificates);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
-	ASSERT(builder->remainingCertificates > 0);
-	builder->remainingCertificates--;
-
-	ASSERT(builder->poolCertificateData.remainingOwners == 0);
-	builder->poolCertificateData.remainingOwners = numOwners;
-	ASSERT(builder->poolCertificateData.remainingRelays == 0);
-	builder->poolCertificateData.remainingRelays = numRelays;
-
-	// Array(10)[
-	//   Unsigned[3]
-
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 10);
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 3);
-		}
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT;
-}
-
-void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT);
-
-	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
-
-	//   Bytes[pool_keyhash]          // also called operator in CDDL specs and pool id in user interfaces
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
-		BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH;
-}
-
-void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* vrfKeyHash, size_t vrfKeyHashSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH);
-
-	ASSERT(vrfKeyHashSize == VRF_KEY_HASH_LENGTH);
-
-	//   Bytes[vrf_keyhash]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, vrfKeyHashSize);
-		BUILDER_APPEND_DATA(vrfKeyHash, vrfKeyHashSize);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF;
-}
-
-void txHashBuilder_poolRegistrationCertificate_financials(
-        tx_hash_builder_t* builder,
-        uint64_t pledge, uint64_t cost,
-        uint64_t marginNumerator, uint64_t marginDenominator
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF);
-
-	//   Unsigned[pledge]
-	//   Unsigned[cost]
-	//   Tag(30) Array(2)[
-	//     Unsigned[marginDenominator]
-	//     Unsigned[marginNumerator]
-	//   ]
-	{
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, pledge);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, cost);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_TAG, 30);
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginNumerator);
-			}
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginDenominator);
-			}
-		}
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS;
-}
-
-void txHashBuilder_poolRegistrationCertificate_rewardAccount(
-        tx_hash_builder_t* builder,
-        uint8_t* rewardAccount, size_t rewardAccountSize
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS);
-
-	ASSERT(rewardAccountSize == REWARD_ACCOUNT_SIZE);
-
-	//   Bytes[rewardAccount]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, rewardAccountSize);
-		BUILDER_APPEND_DATA(rewardAccount, rewardAccountSize);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT);
-
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingOwners);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addOwner(
-        tx_hash_builder_t* builder,
-        const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
-)
-{
-	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
-	ASSERT(builder->poolCertificateData.remainingOwners > 0);
-	builder->poolCertificateData.remainingOwners--;
-
-	ASSERT(stakingKeyHashSize == ADDRESS_KEY_HASH_LENGTH);
-
-	// Bytes[poolKeyHash]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, stakingKeyHashSize);
-		BUILDER_APPEND_DATA(stakingKeyHash, stakingKeyHashSize);
-	}
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
-
-	// enter empty owners if none were received (and none were expected)
-	if (builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT) {
-		ASSERT(builder->poolCertificateData.remainingOwners == 0);
-		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
-	}
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
-	ASSERT(builder->poolCertificateData.remainingOwners == 0);
-
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingRelays);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS;
-}
-
-static void _relay_addPort(tx_hash_builder_t* builder, ipport_t* port)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	//   Unsigned[port] / Null
-	if (port->isNull) {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	} else {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, port->number);
-	}
-}
-
-static void _relay_addIpv4(tx_hash_builder_t* builder, ipv4_t* ipv4)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	//   Bytes[ipv4] / Null
-	if (ipv4->isNull) {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	} else {
-		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV4_SIZE);
-		BUILDER_APPEND_DATA(ipv4->ip, IPV4_SIZE);
-	}
-}
-
-static void _relay_addIpv6(tx_hash_builder_t* builder, const ipv6_t* ipv6)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	//   Bytes[ipv6] / Null
-	if (ipv6->isNull) {
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	} else {
-		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
-		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV6_SIZE);
-
-		// serialized as 4 big-endian uint32
-		// we need a local copy of the data to make the following pointer tricks work
-		// the copy is created by memmove instead of struct assignment to avoid compiler optimizing it away
-		uint8_t ipBuffer[IPV6_SIZE] = {0};
-		memmove(ipBuffer, ipv6->ip, SIZEOF(ipBuffer));
-		STATIC_ASSERT(SIZEOF(ipBuffer) == 16, "wrong ipv6 size");
-
-		uint32_t* as_uint32 = (uint32_t*) ipBuffer;
-		for (size_t i = 0; i < 4; i++) {
-			uint8_t chunk[4] = {0};
-			u4be_write(chunk, as_uint32[i]);
-			BUILDER_APPEND_DATA(chunk, 4);
-		}
-	}
-}
-
-static void _relay_addDnsName(tx_hash_builder_t* builder, pool_relay_t* relay)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-
-	ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
-
-	//   Text[dnsName]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, relay->dnsNameSize);
-		BUILDER_APPEND_DATA(relay->dnsName, relay->dnsNameSize);
-	}
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addRelay(
-        tx_hash_builder_t* builder,
-        pool_relay_t* relay
-)
-{
-	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
-	ASSERT(builder->poolCertificateData.remainingRelays > 0);
-	builder->poolCertificateData.remainingRelays--;
-
-	switch (relay->format) {
-	case RELAY_SINGLE_HOST_IP: {
-		// Array(4)[
-		//   Unsigned[0]
-		//   Unsigned[port] / Null
-		//   Bytes[ipv4] / Null
-		//   Bytes[ipv6] / Null
-		// ]
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 4);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 0);
-			}
-			_relay_addPort(builder, &relay->port);
-			_relay_addIpv4(builder, &relay->ipv4);
-			_relay_addIpv6(builder, &relay->ipv6);
-		}
-		break;
-	}
-	case RELAY_SINGLE_HOST_NAME: {
-		// Array(3)[
-		//   Unsigned[1]
-		//   Unsigned[port] / Null
-		//   Text[dnsName]
-		// ]
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 1);
-			}
-			_relay_addPort(builder, &relay->port);
-			_relay_addDnsName(builder, relay);
-		}
-		break;
-	}
-	case RELAY_MULTIPLE_HOST_NAME: {
-		// Array(2)[
-		//   Unsigned[2]
-		//   Text[dnsName]
-		// ]
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
-			{
-				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 2);
-			}
-			_relay_addDnsName(builder, relay);
-		}
-		break;
-	}
-	default:
-		ASSERT(false);
-	}
-}
-
-// enter empty owners or relays if none were received
-static void addPoolMetadata_updateState(tx_hash_builder_t* builder)
-{
-	switch (builder->state) {
-	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT:
-		// skipping owners is only possible if none were expected
-		ASSERT(builder->poolCertificateData.remainingOwners == 0);
-		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
-
-	// intentional fallthrough
-
-	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS:
-		// skipping relays is only possible if none were expected
-		ASSERT(builder->poolCertificateData.remainingRelays == 0);
-		txHashBuilder_addPoolRegistrationCertificate_enterRelays(builder);
-
-	// intentional fallthrough
-
-	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS:
-		// all relays should have been received
-		ASSERT(builder->poolCertificateData.remainingRelays == 0);
-		break; // we want to be here
-
-	default:
-		ASSERT(false);
-	}
-
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
-        tx_hash_builder_t* builder,
-        const uint8_t* url, size_t urlSize,
-        const uint8_t* metadataHash, size_t metadataHashSize
-)
-{
-	_TRACE("state = %d", builder->state);
-	ASSERT(metadataHashSize == POOL_METADATA_HASH_LENGTH);
-
-	// we allow this to be called immediately after pool params have been added
-	// if there are no owners or relays in the tx
-	addPoolMetadata_updateState(builder);
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
-
-	// Array(2)[
-	//   Tstr[url]
-	//   Bytes[metadataHash]
-	// ]
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, urlSize);
-			BUILDER_APPEND_DATA(url, urlSize);
-		}
-		{
-			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, metadataHashSize);
-			BUILDER_APPEND_DATA(metadataHash, metadataHashSize);
-		}
-	}
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
-}
-
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
-        tx_hash_builder_t* builder
-)
-{
-	_TRACE("state = %d", builder->state);
-
-	addPoolMetadata_updateState(builder);
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
-	{
-		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
-	}
-	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
-}
+// void txHashBuilder_addCertificate_poolRetirement(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize,
+//         uint64_t epoch
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
+// 	ASSERT(builder->remainingCertificates > 0);
+// 	builder->remainingCertificates--;
+
+// 	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
+
+// 	// Array(3)[
+// 	//   Unsigned[4]
+// 	//   Bytes[poolKeyHash]
+// 	//   Unsigned[epoch]
+// 	// ]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 4);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
+// 			BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
+// 		}
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, epoch);
+// 	}
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_enter(
+//         tx_hash_builder_t* builder,
+//         uint16_t numOwners, uint16_t numRelays
+// )
+// {
+// 	_TRACE("state = %d, remainingCertificates = %u", builder->state, builder->remainingCertificates);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES);
+// 	ASSERT(builder->remainingCertificates > 0);
+// 	builder->remainingCertificates--;
+
+// 	ASSERT(builder->poolCertificateData.remainingOwners == 0);
+// 	builder->poolCertificateData.remainingOwners = numOwners;
+// 	ASSERT(builder->poolCertificateData.remainingRelays == 0);
+// 	builder->poolCertificateData.remainingRelays = numRelays;
+
+// 	// Array(10)[
+// 	//   Unsigned[3]
+
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 10);
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 3);
+// 		}
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT);
+
+// 	ASSERT(poolKeyHashSize == POOL_KEY_HASH_LENGTH);
+
+// 	//   Bytes[pool_keyhash]          // also called operator in CDDL specs and pool id in user interfaces
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, poolKeyHashSize);
+// 		BUILDER_APPEND_DATA(poolKeyHash, poolKeyHashSize);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* vrfKeyHash, size_t vrfKeyHashSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH);
+
+// 	ASSERT(vrfKeyHashSize == VRF_KEY_HASH_LENGTH);
+
+// 	//   Bytes[vrf_keyhash]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, vrfKeyHashSize);
+// 		BUILDER_APPEND_DATA(vrfKeyHash, vrfKeyHashSize);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_financials(
+//         tx_hash_builder_t* builder,
+//         uint64_t pledge, uint64_t cost,
+//         uint64_t marginNumerator, uint64_t marginDenominator
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF);
+
+// 	//   Unsigned[pledge]
+// 	//   Unsigned[cost]
+// 	//   Tag(30) Array(2)[
+// 	//     Unsigned[marginDenominator]
+// 	//     Unsigned[marginNumerator]
+// 	//   ]
+// 	{
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, pledge);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, cost);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_TAG, 30);
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginNumerator);
+// 			}
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, marginDenominator);
+// 			}
+// 		}
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS;
+// }
+
+// void txHashBuilder_poolRegistrationCertificate_rewardAccount(
+//         tx_hash_builder_t* builder,
+//         uint8_t* rewardAccount, size_t rewardAccountSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS);
+
+// 	ASSERT(rewardAccountSize == REWARD_ACCOUNT_SIZE);
+
+// 	//   Bytes[rewardAccount]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, rewardAccountSize);
+// 		BUILDER_APPEND_DATA(rewardAccount, rewardAccountSize);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT);
+
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingOwners);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addOwner(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
+// )
+// {
+// 	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
+// 	ASSERT(builder->poolCertificateData.remainingOwners > 0);
+// 	builder->poolCertificateData.remainingOwners--;
+
+// 	ASSERT(stakingKeyHashSize == ADDRESS_KEY_HASH_LENGTH);
+
+// 	// Bytes[poolKeyHash]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, stakingKeyHashSize);
+// 		BUILDER_APPEND_DATA(stakingKeyHash, stakingKeyHashSize);
+// 	}
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d, remainingOwners = %u", builder->state, builder->poolCertificateData.remainingOwners);
+
+// 	// enter empty owners if none were received (and none were expected)
+// 	if (builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT) {
+// 		ASSERT(builder->poolCertificateData.remainingOwners == 0);
+// 		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
+// 	}
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS);
+// 	ASSERT(builder->poolCertificateData.remainingOwners == 0);
+
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, builder->poolCertificateData.remainingRelays);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS;
+// }
+
+// static void _relay_addPort(tx_hash_builder_t* builder, ipport_t* port)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	//   Unsigned[port] / Null
+// 	if (port->isNull) {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	} else {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, port->number);
+// 	}
+// }
+
+// static void _relay_addIpv4(tx_hash_builder_t* builder, ipv4_t* ipv4)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	//   Bytes[ipv4] / Null
+// 	if (ipv4->isNull) {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	} else {
+// 		STATIC_ASSERT(sizeof(ipv4->ip) == IPV4_SIZE, "wrong ipv4 size"); // SIZEOF does not work for 4-byte buffers
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV4_SIZE);
+// 		BUILDER_APPEND_DATA(ipv4->ip, IPV4_SIZE);
+// 	}
+// }
+
+// static void _relay_addIpv6(tx_hash_builder_t* builder, const ipv6_t* ipv6)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	//   Bytes[ipv6] / Null
+// 	if (ipv6->isNull) {
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	} else {
+// 		STATIC_ASSERT(SIZEOF(ipv6->ip) == IPV6_SIZE, "wrong ipv6 size");
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, IPV6_SIZE);
+
+// 		// serialized as 4 big-endian uint32
+// 		// we need a local copy of the data to make the following pointer tricks work
+// 		// the copy is created by memmove instead of struct assignment to avoid compiler optimizing it away
+// 		uint8_t ipBuffer[IPV6_SIZE] = {0};
+// 		memmove(ipBuffer, ipv6->ip, SIZEOF(ipBuffer));
+// 		STATIC_ASSERT(SIZEOF(ipBuffer) == 16, "wrong ipv6 size");
+
+// 		uint32_t* as_uint32 = (uint32_t*) ipBuffer;
+// 		for (size_t i = 0; i < 4; i++) {
+// 			uint8_t chunk[4] = {0};
+// 			u4be_write(chunk, as_uint32[i]);
+// 			BUILDER_APPEND_DATA(chunk, 4);
+// 		}
+// 	}
+// }
+
+// static void _relay_addDnsName(tx_hash_builder_t* builder, pool_relay_t* relay)
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+
+// 	ASSERT(relay->dnsNameSize <= DNS_NAME_SIZE_MAX);
+
+// 	//   Text[dnsName]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, relay->dnsNameSize);
+// 		BUILDER_APPEND_DATA(relay->dnsName, relay->dnsNameSize);
+// 	}
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addRelay(
+//         tx_hash_builder_t* builder,
+//         pool_relay_t* relay
+// )
+// {
+// 	_TRACE("state = %d, remainingRelays = %u", builder->state, builder->poolCertificateData.remainingRelays);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS);
+// 	ASSERT(builder->poolCertificateData.remainingRelays > 0);
+// 	builder->poolCertificateData.remainingRelays--;
+
+// 	switch (relay->format) {
+// 	case RELAY_SINGLE_HOST_IP: {
+// 		// Array(4)[
+// 		//   Unsigned[0]
+// 		//   Unsigned[port] / Null
+// 		//   Bytes[ipv4] / Null
+// 		//   Bytes[ipv6] / Null
+// 		// ]
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 4);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 0);
+// 			}
+// 			_relay_addPort(builder, &relay->port);
+// 			_relay_addIpv4(builder, &relay->ipv4);
+// 			_relay_addIpv6(builder, &relay->ipv6);
+// 		}
+// 		break;
+// 	}
+// 	case RELAY_SINGLE_HOST_NAME: {
+// 		// Array(3)[
+// 		//   Unsigned[1]
+// 		//   Unsigned[port] / Null
+// 		//   Text[dnsName]
+// 		// ]
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 3);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 1);
+// 			}
+// 			_relay_addPort(builder, &relay->port);
+// 			_relay_addDnsName(builder, relay);
+// 		}
+// 		break;
+// 	}
+// 	case RELAY_MULTIPLE_HOST_NAME: {
+// 		// Array(2)[
+// 		//   Unsigned[2]
+// 		//   Text[dnsName]
+// 		// ]
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
+// 			{
+// 				BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, 2);
+// 			}
+// 			_relay_addDnsName(builder, relay);
+// 		}
+// 		break;
+// 	}
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
+
+// // enter empty owners or relays if none were received
+// static void addPoolMetadata_updateState(tx_hash_builder_t* builder)
+// {
+// 	switch (builder->state) {
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT:
+// 		// skipping owners is only possible if none were expected
+// 		ASSERT(builder->poolCertificateData.remainingOwners == 0);
+// 		txHashBuilder_addPoolRegistrationCertificate_enterOwners(builder);
+
+// 	// intentional fallthrough
+
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS:
+// 		// skipping relays is only possible if none were expected
+// 		ASSERT(builder->poolCertificateData.remainingRelays == 0);
+// 		txHashBuilder_addPoolRegistrationCertificate_enterRelays(builder);
+
+// 	// intentional fallthrough
+
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS:
+// 		// all relays should have been received
+// 		ASSERT(builder->poolCertificateData.remainingRelays == 0);
+// 		break; // we want to be here
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* url, size_t urlSize,
+//         const uint8_t* metadataHash, size_t metadataHashSize
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+// 	ASSERT(metadataHashSize == POOL_METADATA_HASH_LENGTH);
+
+// 	// we allow this to be called immediately after pool params have been added
+// 	// if there are no owners or relays in the tx
+// 	addPoolMetadata_updateState(builder);
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
+
+// 	// Array(2)[
+// 	//   Tstr[url]
+// 	//   Bytes[metadataHash]
+// 	// ]
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_ARRAY, 2);
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_TEXT, urlSize);
+// 			BUILDER_APPEND_DATA(url, urlSize);
+// 		}
+// 		{
+// 			BUILDER_APPEND_CBOR(CBOR_TYPE_BYTES, metadataHashSize);
+// 			BUILDER_APPEND_DATA(metadataHash, metadataHashSize);
+// 		}
+// 	}
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
+// }
+
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
+//         tx_hash_builder_t* builder
+// )
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	addPoolMetadata_updateState(builder);
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA);
+// 	{
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_NULL, 0);
+// 	}
+// 	builder->state = TX_HASH_BUILDER_IN_CERTIFICATES;
+// }
 
 static void txHashBuilder_assertCanLeaveCertificates(tx_hash_builder_t* builder)
 {
diff --git a/src/txHashBuilder.h b/src/txHashBuilder.h
index 7420c97..6d95f20 100644
--- a/src/txHashBuilder.h
+++ b/src/txHashBuilder.h
@@ -42,14 +42,14 @@ typedef enum {
 	TX_HASH_BUILDER_IN_FEE = 400,
 	TX_HASH_BUILDER_IN_TTL = 500,
 	TX_HASH_BUILDER_IN_CERTIFICATES = 600,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT = 610,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH = 611,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF = 612,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS = 613,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT = 614,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS = 615,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS = 616,
-	TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA = 617,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_INIT = 610,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_KEY_HASH = 611,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_VRF = 612,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_FINANCIALS = 613,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_REWARD_ACCOUNT = 614,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_OWNERS = 615,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_RELAYS = 616,
+	// TX_HASH_BUILDER_IN_CERTIFICATES_POOL_METADATA = 617,
 	TX_HASH_BUILDER_IN_WITHDRAWALS = 700,
 	TX_HASH_BUILDER_IN_AUX_DATA = 800,
 	TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START = 900,
@@ -79,10 +79,10 @@ typedef struct {
 	bool includeNetworkId;
 
 	union {
-		struct {
-			uint16_t remainingOwners;
-			uint16_t remainingRelays;
-		} poolCertificateData;
+		// struct {
+		// 	uint16_t remainingOwners;
+		// 	uint16_t remainingRelays;
+		// } poolCertificateData;
 
 		struct {
 			uint16_t remainingAssetGroups;
@@ -159,51 +159,51 @@ void txHashBuilder_addCertificate_delegation(
         const uint8_t* stakingKeyHash, size_t stakingKeyHashSize,
         const uint8_t* poolKeyHash, size_t poolKeyHashSize
 );
-void txHashBuilder_addCertificate_poolRetirement(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize,
-        uint64_t epoch
-);
+// void txHashBuilder_addCertificate_poolRetirement(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize,
+//         uint64_t epoch
+// );
 
-void txHashBuilder_poolRegistrationCertificate_enter(
-        tx_hash_builder_t* builder,
-        uint16_t numOwners, uint16_t numRelays
-);
-void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* poolKeyHash, size_t poolKeyHashSize
-);
-void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
-        tx_hash_builder_t* builder,
-        uint8_t* vrfKeyHash, size_t vrfKeyHashSize
-);
-void txHashBuilder_poolRegistrationCertificate_financials(
-        tx_hash_builder_t* builder,
-        uint64_t pledge, uint64_t cost,
-        uint64_t marginNumerator, uint64_t marginDenominator
-);
-void txHashBuilder_poolRegistrationCertificate_rewardAccount(
-        tx_hash_builder_t* builder,
-        uint8_t* rewardAccount, size_t rewardAccountSize
-);
-void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder);
-void txHashBuilder_addPoolRegistrationCertificate_addOwner(
-        tx_hash_builder_t* builder,
-        const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
-);
-void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder);
-void txHashBuilder_addPoolRegistrationCertificate_addRelay(
-        tx_hash_builder_t* builder,
-        pool_relay_t* relay
-);
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
-        tx_hash_builder_t* builder,
-        const uint8_t* url, size_t urlSize,
-        const uint8_t* metadataHash, size_t metadataHashSize
-);
-void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
-        tx_hash_builder_t* builder
-);
+// void txHashBuilder_poolRegistrationCertificate_enter(
+//         tx_hash_builder_t* builder,
+//         uint16_t numOwners, uint16_t numRelays
+// );
+// void txHashBuilder_poolRegistrationCertificate_poolKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* poolKeyHash, size_t poolKeyHashSize
+// );
+// void txHashBuilder_poolRegistrationCertificate_vrfKeyHash(
+//         tx_hash_builder_t* builder,
+//         uint8_t* vrfKeyHash, size_t vrfKeyHashSize
+// );
+// void txHashBuilder_poolRegistrationCertificate_financials(
+//         tx_hash_builder_t* builder,
+//         uint64_t pledge, uint64_t cost,
+//         uint64_t marginNumerator, uint64_t marginDenominator
+// );
+// void txHashBuilder_poolRegistrationCertificate_rewardAccount(
+//         tx_hash_builder_t* builder,
+//         uint8_t* rewardAccount, size_t rewardAccountSize
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_enterOwners(tx_hash_builder_t* builder);
+// void txHashBuilder_addPoolRegistrationCertificate_addOwner(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* stakingKeyHash, size_t stakingKeyHashSize
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_enterRelays(tx_hash_builder_t* builder);
+// void txHashBuilder_addPoolRegistrationCertificate_addRelay(
+//         tx_hash_builder_t* builder,
+//         pool_relay_t* relay
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* url, size_t urlSize,
+//         const uint8_t* metadataHash, size_t metadataHashSize
+// );
+// void txHashBuilder_addPoolRegistrationCertificate_addPoolMetadata_null(
+//         tx_hash_builder_t* builder
+// );
 
 void txHashBuilder_enterWithdrawals(tx_hash_builder_t* builder);
 void txHashBuilder_addWithdrawal(
diff --git a/src/uiScreens.c b/src/uiScreens.c
index 0374819..fc7421e 100644
--- a/src/uiScreens.c
+++ b/src/uiScreens.c
@@ -5,7 +5,7 @@
 #include "ipUtils.h"
 #include "textUtils.h"
 #include "signTx.h"
-#include "signTxPoolRegistration.h"
+// #include "signTxPoolRegistration.h"
 #include "tokens.h"
 
 
@@ -162,10 +162,10 @@ void ui_displayGetPublicKeyPathScreen(
 )
 {
 	switch (bip44_classifyPath(path)) {
-	case PATH_POOL_COLD_KEY: {
-		ui_displayPathScreen("Export cold public key", path, callback);
-		return;
-	}
+	// case PATH_POOL_COLD_KEY: {
+	// 	ui_displayPathScreen("Export cold public key", path, callback);
+	// 	return;
+	// }
 
 	case PATH_ORDINARY_ACCOUNT: {
 		_ui_displayAccountWithDescriptionScreen("Export public key", path, true, callback);
@@ -643,195 +643,195 @@ void ui_displayNetworkParamsScreen(
 	);
 }
 
-void ui_displayPoolMarginScreen(
-        uint64_t marginNumerator, uint64_t marginDenominator,
-        ui_callback_fn_t callback
-)
-{
-	ASSERT(marginDenominator != 0);
-	ASSERT(marginNumerator <= marginDenominator);
-	ASSERT(marginDenominator <= MARGIN_DENOMINATOR_MAX);
-
-	char marginStr[20] = {0};
-	explicit_bzero(marginStr, SIZEOF(marginStr));
-
-	{
-		// marginPercentage is a multiple of 1/100th of 1%, i.e. the fractional part of the percentage has two digits
-		// adding marginDenominator / 2 to have a rounded result
-		uint64_t marginPercentage = (10000 * marginNumerator + (marginDenominator / 2)) / marginDenominator;
-		ASSERT(marginPercentage <= 10000);
-
-		const unsigned int percentage = (unsigned int) marginPercentage;
-
-		STATIC_ASSERT(sizeof(percentage) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(percentage), "signed type for %u");
-		snprintf(marginStr, SIZEOF(marginStr), "%u.%u %%", percentage / 100, percentage % 100);
-		ASSERT(strlen(marginStr) + 1 < SIZEOF(marginStr));
-	}
-
-	TRACE("%s", marginStr);
-
-	ui_displayPaginatedText(
-	        "Profit margin",
-	        marginStr,
-	        callback
-	);
-}
-
-void ui_displayPoolOwnerScreen(
-        const pool_owner_t* owner,
-        uint32_t ownerIndex,
-        uint8_t networkId,
-        ui_callback_fn_t callback
-)
-{
-	{
-		ASSERT(isValidNetworkId(networkId));
-		ASSERT(ownerIndex < POOL_MAX_OWNERS);
-	}
-	{
-		uint8_t rewardAddress[REWARD_ACCOUNT_SIZE] = {0};
-
-		switch (owner->keyReferenceType) {
-		case KEY_REFERENCE_PATH: {
-			ASSERT(bip44_isOrdinaryStakingKeyPath(&owner->path));
-
-			constructRewardAddressFromKeyPath(
-			        &owner->path, networkId, rewardAddress, SIZEOF(rewardAddress)
-			);
-			break;
-		}
-		case KEY_REFERENCE_HASH: {
-			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
-
-			constructRewardAddressFromHash(
-			        networkId, REWARD_HASH_SOURCE_KEY,
-			        owner->keyHash, SIZEOF(owner->keyHash),
-			        rewardAddress, SIZEOF(rewardAddress)
-			);
-			break;
-		}
-		default:
-			ASSERT(false);
-		}
-
-		char firstLine[20] = {0};
-		explicit_bzero(firstLine, SIZEOF(firstLine));
-		STATIC_ASSERT(sizeof(ownerIndex + 1) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(ownerIndex + 1), "signed type for %u");
-		// indexed from 0 as discuss with IOHK on Slack
-		snprintf(firstLine, SIZEOF(firstLine), "Owner #%u", ownerIndex);
-		// make sure all the information is displayed to the user
-		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
-
-		_displayRewardAccountWithDescriptionScreen(
-		        owner->keyReferenceType,
-		        &owner->path,
-		        rewardAddress,
-		        firstLine,
-		        callback
-		);
-	}
-}
-
-// displays pool relay index
-void ui_displayPoolRelayScreen(
-        const pool_relay_t* relay MARK_UNUSED,
-        size_t relayIndex,
-        ui_callback_fn_t callback
-)
-{
-	char firstLine[20] = {0};
-	explicit_bzero(firstLine, SIZEOF(firstLine));
-	{
-		STATIC_ASSERT(sizeof(relayIndex + 1) <= sizeof(unsigned), "oversized type for %u");
-		STATIC_ASSERT(!IS_SIGNED(relayIndex + 1), "signed type for %u");
-		// indexed from 0 as discussed with IOHK on Slack
-		snprintf(firstLine, SIZEOF(firstLine), "Relay #%u", relayIndex);
-		// make sure all the information is displayed to the user
-		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
-	}
-
-	ui_displayPaginatedText(
-	        firstLine,
-	        "",
-	        callback
-	);
-}
-
-void ui_displayIpv4Screen(
-        const ipv4_t* ipv4,
-        ui_callback_fn_t callback
-)
-{
-	char ipStr[IPV4_STR_SIZE_MAX + 1] = {0};
-	explicit_bzero(ipStr, SIZEOF(ipStr));
-
-	if (ipv4->isNull) {
-		snprintf(ipStr, SIZEOF(ipStr), "(none)");
-	} else {
-		inet_ntop4(ipv4->ip, ipStr, SIZEOF(ipStr));
-	}
-
-	// make sure all the information is displayed to the user
-	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
-
-	ui_displayPaginatedText(
-	        "IPv4 address",
-	        ipStr,
-	        callback
-	);
-}
-
-void ui_displayIpv6Screen(
-        const ipv6_t* ipv6,
-        ui_callback_fn_t callback
-)
-{
-	char ipStr[IPV6_STR_SIZE_MAX + 1] = {0};
-	explicit_bzero(ipStr, SIZEOF(ipStr));
-
-	if (ipv6->isNull) {
-		snprintf(ipStr, SIZEOF(ipStr), "(none)");
-	} else {
-		inet_ntop6(ipv6->ip, ipStr, SIZEOF(ipStr));
-	}
-
-	// make sure all the information is displayed to the user
-	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
-
-	ui_displayPaginatedText(
-	        "IPv6 address",
-	        ipStr,
-	        callback
-	);
-}
-
-void ui_displayIpPortScreen(
-        const ipport_t* port,
-        ui_callback_fn_t callback
-)
-{
-	char portStr[1 + (sizeof "65536")] = {0};
-	explicit_bzero(portStr, SIZEOF(portStr));
-
-	if (port->isNull) {
-		snprintf(portStr, SIZEOF(portStr), "(none)");
-	} else {
-		STATIC_ASSERT(sizeof(port->number) <= sizeof(unsigned), "oversized variable for %u");
-		STATIC_ASSERT(!IS_SIGNED(port->number), "signed type for %u");
-		snprintf(portStr, SIZEOF(portStr), "%u", port->number);
-	}
-
-	// make sure all the information is displayed to the user
-	ASSERT(strlen(portStr) + 1 < SIZEOF(portStr));
-
-	ui_displayPaginatedText(
-	        "Port",
-	        portStr,
-	        callback
-	);
-}
+// void ui_displayPoolMarginScreen(
+//         uint64_t marginNumerator, uint64_t marginDenominator,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	ASSERT(marginDenominator != 0);
+// 	ASSERT(marginNumerator <= marginDenominator);
+// 	ASSERT(marginDenominator <= MARGIN_DENOMINATOR_MAX);
+
+// 	char marginStr[20] = {0};
+// 	explicit_bzero(marginStr, SIZEOF(marginStr));
+
+// 	{
+// 		// marginPercentage is a multiple of 1/100th of 1%, i.e. the fractional part of the percentage has two digits
+// 		// adding marginDenominator / 2 to have a rounded result
+// 		uint64_t marginPercentage = (10000 * marginNumerator + (marginDenominator / 2)) / marginDenominator;
+// 		ASSERT(marginPercentage <= 10000);
+
+// 		const unsigned int percentage = (unsigned int) marginPercentage;
+
+// 		STATIC_ASSERT(sizeof(percentage) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(percentage), "signed type for %u");
+// 		snprintf(marginStr, SIZEOF(marginStr), "%u.%u %%", percentage / 100, percentage % 100);
+// 		ASSERT(strlen(marginStr) + 1 < SIZEOF(marginStr));
+// 	}
+
+// 	TRACE("%s", marginStr);
+
+// 	ui_displayPaginatedText(
+// 	        "Profit margin",
+// 	        marginStr,
+// 	        callback
+// 	);
+// }
+
+// void ui_displayPoolOwnerScreen(
+//         const pool_owner_t* owner,
+//         uint32_t ownerIndex,
+//         uint8_t networkId,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	{
+// 		ASSERT(isValidNetworkId(networkId));
+// 		ASSERT(ownerIndex < POOL_MAX_OWNERS);
+// 	}
+// 	{
+// 		uint8_t rewardAddress[REWARD_ACCOUNT_SIZE] = {0};
+
+// 		switch (owner->keyReferenceType) {
+// 		case KEY_REFERENCE_PATH: {
+// 			ASSERT(bip44_isOrdinaryStakingKeyPath(&owner->path));
+
+// 			constructRewardAddressFromKeyPath(
+// 			        &owner->path, networkId, rewardAddress, SIZEOF(rewardAddress)
+// 			);
+// 			break;
+// 		}
+// 		case KEY_REFERENCE_HASH: {
+// 			STATIC_ASSERT(SIZEOF(owner->keyHash) == ADDRESS_KEY_HASH_LENGTH, "wrong owner.keyHash size");
+
+// 			constructRewardAddressFromHash(
+// 			        networkId, REWARD_HASH_SOURCE_KEY,
+// 			        owner->keyHash, SIZEOF(owner->keyHash),
+// 			        rewardAddress, SIZEOF(rewardAddress)
+// 			);
+// 			break;
+// 		}
+// 		default:
+// 			ASSERT(false);
+// 		}
+
+// 		char firstLine[20] = {0};
+// 		explicit_bzero(firstLine, SIZEOF(firstLine));
+// 		STATIC_ASSERT(sizeof(ownerIndex + 1) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(ownerIndex + 1), "signed type for %u");
+// 		// indexed from 0 as discuss with IOHK on Slack
+// 		snprintf(firstLine, SIZEOF(firstLine), "Owner #%u", ownerIndex);
+// 		// make sure all the information is displayed to the user
+// 		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
+
+// 		_displayRewardAccountWithDescriptionScreen(
+// 		        owner->keyReferenceType,
+// 		        &owner->path,
+// 		        rewardAddress,
+// 		        firstLine,
+// 		        callback
+// 		);
+// 	}
+// }
+
+// // displays pool relay index
+// void ui_displayPoolRelayScreen(
+//         const pool_relay_t* relay MARK_UNUSED,
+//         size_t relayIndex,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char firstLine[20] = {0};
+// 	explicit_bzero(firstLine, SIZEOF(firstLine));
+// 	{
+// 		STATIC_ASSERT(sizeof(relayIndex + 1) <= sizeof(unsigned), "oversized type for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(relayIndex + 1), "signed type for %u");
+// 		// indexed from 0 as discussed with IOHK on Slack
+// 		snprintf(firstLine, SIZEOF(firstLine), "Relay #%u", relayIndex);
+// 		// make sure all the information is displayed to the user
+// 		ASSERT(strlen(firstLine) + 1 < SIZEOF(firstLine));
+// 	}
+
+// 	ui_displayPaginatedText(
+// 	        firstLine,
+// 	        "",
+// 	        callback
+// 	);
+// }
+
+// void ui_displayIpv4Screen(
+//         const ipv4_t* ipv4,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char ipStr[IPV4_STR_SIZE_MAX + 1] = {0};
+// 	explicit_bzero(ipStr, SIZEOF(ipStr));
+
+// 	if (ipv4->isNull) {
+// 		snprintf(ipStr, SIZEOF(ipStr), "(none)");
+// 	} else {
+// 		inet_ntop4(ipv4->ip, ipStr, SIZEOF(ipStr));
+// 	}
+
+// 	// make sure all the information is displayed to the user
+// 	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
+
+// 	ui_displayPaginatedText(
+// 	        "IPv4 address",
+// 	        ipStr,
+// 	        callback
+// 	);
+// }
+
+// void ui_displayIpv6Screen(
+//         const ipv6_t* ipv6,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char ipStr[IPV6_STR_SIZE_MAX + 1] = {0};
+// 	explicit_bzero(ipStr, SIZEOF(ipStr));
+
+// 	if (ipv6->isNull) {
+// 		snprintf(ipStr, SIZEOF(ipStr), "(none)");
+// 	} else {
+// 		inet_ntop6(ipv6->ip, ipStr, SIZEOF(ipStr));
+// 	}
+
+// 	// make sure all the information is displayed to the user
+// 	ASSERT(strlen(ipStr) + 1 < SIZEOF(ipStr));
+
+// 	ui_displayPaginatedText(
+// 	        "IPv6 address",
+// 	        ipStr,
+// 	        callback
+// 	);
+// }
+
+// void ui_displayIpPortScreen(
+//         const ipport_t* port,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char portStr[1 + (sizeof "65536")] = {0};
+// 	explicit_bzero(portStr, SIZEOF(portStr));
+
+// 	if (port->isNull) {
+// 		snprintf(portStr, SIZEOF(portStr), "(none)");
+// 	} else {
+// 		STATIC_ASSERT(sizeof(port->number) <= sizeof(unsigned), "oversized variable for %u");
+// 		STATIC_ASSERT(!IS_SIGNED(port->number), "signed type for %u");
+// 		snprintf(portStr, SIZEOF(portStr), "%u", port->number);
+// 	}
+
+// 	// make sure all the information is displayed to the user
+// 	ASSERT(strlen(portStr) + 1 < SIZEOF(portStr));
+
+// 	ui_displayPaginatedText(
+// 	        "Port",
+// 	        portStr,
+// 	        callback
+// 	);
+// }
 
 void ui_displayInputScreen(
         const char* screenHeader,
diff --git a/src/uiScreens.h b/src/uiScreens.h
index 2c23afe..f3544fe 100644
--- a/src/uiScreens.h
+++ b/src/uiScreens.h
@@ -5,7 +5,7 @@
 #include "addressUtilsShelley.h"
 #include "signTx.h"
 #include "signTxOutput.h"
-#include "signTxPoolRegistration.h"
+// #include "signTxPoolRegistration.h"
 
 __noinline_due_to_stack__
 void ui_displayBech32Screen(
@@ -133,38 +133,38 @@ void ui_displayPoolMarginScreen(
         ui_callback_fn_t callback
 );
 
-__noinline_due_to_stack__
-void ui_displayPoolOwnerScreen(
-        const pool_owner_t* owner,
-        uint32_t ownerIndex,
-        uint8_t networkId,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayPoolRelayScreen(
-        const pool_relay_t* relay,
-        size_t relayIndex,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayIpv4Screen(
-        const ipv4_t* ipv4,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayIpv6Screen(
-        const ipv6_t* ipv6,
-        ui_callback_fn_t callback
-);
-
-__noinline_due_to_stack__
-void ui_displayIpPortScreen(
-        const ipport_t* port,
-        ui_callback_fn_t callback
-);
+// __noinline_due_to_stack__
+// void ui_displayPoolOwnerScreen(
+//         const pool_owner_t* owner,
+//         uint32_t ownerIndex,
+//         uint8_t networkId,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayPoolRelayScreen(
+//         const pool_relay_t* relay,
+//         size_t relayIndex,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayIpv4Screen(
+//         const ipv4_t* ipv4,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayIpv6Screen(
+//         const ipv6_t* ipv6,
+//         ui_callback_fn_t callback
+// );
+
+// __noinline_due_to_stack__
+// void ui_displayIpPortScreen(
+//         const ipport_t* port,
+//         ui_callback_fn_t callback
+// );
 
 __noinline_due_to_stack__
 void ui_displayInputScreen(
