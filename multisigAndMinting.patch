diff --git a/src/bip44.c b/src/bip44.c
index 8099ac0..d098855 100644
--- a/src/bip44.c
+++ b/src/bip44.c
@@ -12,7 +12,7 @@ static const uint32_t MAX_REASONABLE_ACCOUNT = 100;
 static const uint32_t MAX_REASONABLE_ADDRESS = 1000000;
 
 static const uint32_t MAX_REASONABLE_COLD_KEY_INDEX = 1000000;
-static const uint32_t MAX_REASONABLE_MINT_POLICY_INDEX = 1000000;
+// static const uint32_t MAX_REASONABLE_MINT_POLICY_INDEX = 1000000;
 
 
 size_t bip44_parseFromWire(
@@ -80,26 +80,26 @@ bool bip44_hasOrdinaryWalletKeyPrefix(const bip44_path_t* pathSpec)
 }
 
 // /1854'/1815'
-bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
-	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MULTISIG | HARDENED_BIP32));
-	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
-	return true;
-#undef CHECK
-}
+// bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
+// 	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MULTISIG | HARDENED_BIP32));
+// 	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
+// 	return true;
+// #undef CHECK
+// }
 
 // /1855'/1815'
-bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
-	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MINT | HARDENED_BIP32));
-	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
-	return true;
-#undef CHECK
-}
+// bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length > BIP44_I_COIN_TYPE);
+// 	CHECK(pathSpec->path[BIP44_I_PURPOSE] == (PURPOSE_MINT | HARDENED_BIP32));
+// 	CHECK(pathSpec->path[BIP44_I_COIN_TYPE] == (ADA_COIN_TYPE | HARDENED_BIP32));
+// 	return true;
+// #undef CHECK
+// }
 
 // /1853'/1815'
 bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec)
@@ -125,11 +125,11 @@ uint32_t bip44_getAccount(const bip44_path_t* pathSpec)
 	return pathSpec->path[BIP44_I_ACCOUNT];
 }
 
-uint32_t bip44_getMintPolicy(const bip44_path_t* pathSpec)
-{
-	ASSERT(pathSpec->length > BIP44_I_MINT_POLICY);
-	return pathSpec->path[BIP44_I_MINT_POLICY];
-}
+// uint32_t bip44_getMintPolicy(const bip44_path_t* pathSpec)
+// {
+// 	ASSERT(pathSpec->length > BIP44_I_MINT_POLICY);
+// 	return pathSpec->path[BIP44_I_MINT_POLICY];
+// }
 
 uint32_t bip44_getColdKeyIndex(const bip44_path_t* pathSpec)
 {
@@ -145,14 +145,14 @@ bool bip44_hasReasonableAccount(const bip44_path_t* pathSpec)
 	return unharden(account) <= MAX_REASONABLE_ACCOUNT;
 }
 
-bool bip44_hasReasonableMintPolicy(const bip44_path_t* pathSpec)
-{
-	if (!bip44_isMintKeyPath(pathSpec)) return false;
-	uint32_t mintPolicyIndex = bip44_getMintPolicy(pathSpec);
+// bool bip44_hasReasonableMintPolicy(const bip44_path_t* pathSpec)
+// {
+// 	if (!bip44_isMintKeyPath(pathSpec)) return false;
+// 	uint32_t mintPolicyIndex = bip44_getMintPolicy(pathSpec);
 
-	if (!isHardened(mintPolicyIndex)) return false;
-	return unharden(mintPolicyIndex) <= MAX_REASONABLE_MINT_POLICY_INDEX;
-}
+// 	if (!isHardened(mintPolicyIndex)) return false;
+// 	return unharden(mintPolicyIndex) <= MAX_REASONABLE_MINT_POLICY_INDEX;
+// }
 
 bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec)
 {
@@ -212,12 +212,12 @@ bool bip44_isOrdinarySpendingKeyPath(const bip44_path_t* pathSpec)
 	       bip44_containsAddress(pathSpec);
 }
 
-bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec)
-{
-	return bip44_hasMultisigWalletKeyPrefix(pathSpec) &&
-	       bip44_hasValidChainTypeForAddress(pathSpec) &&
-	       bip44_containsAddress(pathSpec);
-}
+// bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec)
+// {
+// 	return bip44_hasMultisigWalletKeyPrefix(pathSpec) &&
+// 	       bip44_hasValidChainTypeForAddress(pathSpec) &&
+// 	       bip44_containsAddress(pathSpec);
+// }
 
 // staking keys (one per account, should end with /2/0 after account)
 bool bip44_isOrdinaryStakingKeyPath(const bip44_path_t* pathSpec)
@@ -233,27 +233,27 @@ bool bip44_isOrdinaryStakingKeyPath(const bip44_path_t* pathSpec)
 }
 
 // multisig staking keys
-bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec)
-{
-	if (!bip44_containsAddress(pathSpec)) return false;
-	if (bip44_containsMoreThanAddress(pathSpec)) return false;
-	if (!bip44_hasMultisigWalletKeyPrefix(pathSpec)) return false;
-
-	const uint32_t chainType = bip44_getChainTypeValue(pathSpec);
-	if (chainType != CARDANO_CHAIN_STAKING_KEY) return false;
-
-	return true;
-}
-
-bool bip44_isMintKeyPath(const bip44_path_t* pathSpec)
-{
-#define CHECK(cond) if (!(cond)) return false
-	CHECK(pathSpec->length == BIP44_I_MINT_POLICY + 1);
-	CHECK(bip44_hasMintKeyPrefix(pathSpec));
-	CHECK(pathSpec->path[BIP44_I_MINT_POLICY] >= HARDENED_BIP32);
-	return true;
-#undef CHECK
-}
+// bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec)
+// {
+// 	if (!bip44_containsAddress(pathSpec)) return false;
+// 	if (bip44_containsMoreThanAddress(pathSpec)) return false;
+// 	if (!bip44_hasMultisigWalletKeyPrefix(pathSpec)) return false;
+
+// 	const uint32_t chainType = bip44_getChainTypeValue(pathSpec);
+// 	if (chainType != CARDANO_CHAIN_STAKING_KEY) return false;
+
+// 	return true;
+// }
+
+// bool bip44_isMintKeyPath(const bip44_path_t* pathSpec)
+// {
+// #define CHECK(cond) if (!(cond)) return false
+// 	CHECK(pathSpec->length == BIP44_I_MINT_POLICY + 1);
+// 	CHECK(bip44_hasMintKeyPrefix(pathSpec));
+// 	CHECK(pathSpec->path[BIP44_I_MINT_POLICY] >= HARDENED_BIP32);
+// 	return true;
+// #undef CHECK
+// }
 
 bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec)
 {
@@ -362,46 +362,46 @@ static bip44_path_type_t bip44_classifyOrdinaryWalletPath(const bip44_path_t* pa
 	}
 }
 
-static bip44_path_type_t bip44_classifyMultisigWalletPath(const bip44_path_t* pathSpec)
-{
-	ASSERT(bip44_hasMultisigWalletKeyPrefix(pathSpec));
-
-	// account must be hardened
-	if (!bip44_containsAccount(pathSpec)) {
-		return PATH_INVALID;
-	}
-	if (!isHardened(bip44_getAccount(pathSpec))) {
-		return PATH_INVALID;
-	}
-
-	switch (pathSpec->length) {
-	case 3: {
-		return PATH_MULTISIG_ACCOUNT;
-	}
-	case 5: {
-		const uint8_t chainType = bip44_getChainTypeValue(pathSpec);
-		switch (chainType) {
-
-		case CARDANO_CHAIN_EXTERNAL:
-			if (isHardened(bip44_getAddressValue(pathSpec))) {
-				// address index must not be hardened (CIP 1854)
-				return PATH_INVALID;
-			}
-			return PATH_MULTISIG_SPENDING_KEY;
-
-		case CARDANO_CHAIN_STAKING_KEY:
-			return bip44_isMultisigStakingKeyPath(pathSpec) ?
-			       PATH_MULTISIG_STAKING_KEY :
-			       PATH_INVALID;
-
-		default:
-			return PATH_INVALID;
-		}
-	}
-	default:
-		return PATH_INVALID;
-	}
-}
+// static bip44_path_type_t bip44_classifyMultisigWalletPath(const bip44_path_t* pathSpec)
+// {
+// 	ASSERT(bip44_hasMultisigWalletKeyPrefix(pathSpec));
+
+// 	// account must be hardened
+// 	if (!bip44_containsAccount(pathSpec)) {
+// 		return PATH_INVALID;
+// 	}
+// 	if (!isHardened(bip44_getAccount(pathSpec))) {
+// 		return PATH_INVALID;
+// 	}
+
+// 	switch (pathSpec->length) {
+// 	case 3: {
+// 		return PATH_MULTISIG_ACCOUNT;
+// 	}
+// 	case 5: {
+// 		const uint8_t chainType = bip44_getChainTypeValue(pathSpec);
+// 		switch (chainType) {
+
+// 		case CARDANO_CHAIN_EXTERNAL:
+// 			if (isHardened(bip44_getAddressValue(pathSpec))) {
+// 				// address index must not be hardened (CIP 1854)
+// 				return PATH_INVALID;
+// 			}
+// 			return PATH_MULTISIG_SPENDING_KEY;
+
+// 		case CARDANO_CHAIN_STAKING_KEY:
+// 			return bip44_isMultisigStakingKeyPath(pathSpec) ?
+// 			       PATH_MULTISIG_STAKING_KEY :
+// 			       PATH_INVALID;
+
+// 		default:
+// 			return PATH_INVALID;
+// 		}
+// 	}
+// 	default:
+// 		return PATH_INVALID;
+// 	}
+// }
 
 bip44_path_type_t bip44_classifyPath(const bip44_path_t* pathSpec)
 {
@@ -409,17 +409,17 @@ bip44_path_type_t bip44_classifyPath(const bip44_path_t* pathSpec)
 		return bip44_classifyOrdinaryWalletPath(pathSpec);
 	}
 
-	if (bip44_hasMultisigWalletKeyPrefix(pathSpec)) {
-		return bip44_classifyMultisigWalletPath(pathSpec);
-	}
+	// if (bip44_hasMultisigWalletKeyPrefix(pathSpec)) {
+	// 	return bip44_classifyMultisigWalletPath(pathSpec);
+	// }
 
-	if (bip44_hasMintKeyPrefix(pathSpec)) {
-		if (bip44_isMintKeyPath(pathSpec)) {
-			return PATH_MINT_KEY;
-		} else {
-			return PATH_INVALID;
-		}
-	}
+	// if (bip44_hasMintKeyPrefix(pathSpec)) {
+	// 	if (bip44_isMintKeyPath(pathSpec)) {
+	// 		return PATH_MINT_KEY;
+	// 	} else {
+	// 		return PATH_INVALID;
+	// 	}
+	// }
 
 	if (bip44_hasPoolColdKeyPrefix(pathSpec)) {
 		if (bip44_isPoolColdKeyPath(pathSpec)) {
@@ -437,21 +437,21 @@ bool bip44_isPathReasonable(const bip44_path_t* pathSpec)
 	switch (bip44_classifyPath(pathSpec)) {
 
 	case PATH_ORDINARY_ACCOUNT:
-	case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_ACCOUNT:
 		return bip44_hasReasonableAccount(pathSpec);
 
 	case PATH_ORDINARY_SPENDING_KEY:
-	case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_SPENDING_KEY:
 		return bip44_hasReasonableAccount(pathSpec) && bip44_hasReasonableAddress(pathSpec);
 
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
 		// we are checking the 5th item too (to avoid breaking this code
 		// if more than 1 staking key per account is allowed in the future)
 		return bip44_hasReasonableAccount(pathSpec) && bip44_hasReasonableAddress(pathSpec);
 
-	case PATH_MINT_KEY:
-		return bip44_hasReasonableMintPolicy(pathSpec);
+	// case PATH_MINT_KEY:
+	// 	return bip44_hasReasonableMintPolicy(pathSpec);
 
 	case PATH_POOL_COLD_KEY:
 		return bip44_hasReasonablePoolColdKeyIndex(pathSpec);
diff --git a/src/bip44.h b/src/bip44.h
index daff51f..86910b5 100644
--- a/src/bip44.h
+++ b/src/bip44.h
@@ -16,9 +16,9 @@ typedef struct {
 
 static const uint32_t PURPOSE_BYRON = 44;
 static const uint32_t PURPOSE_SHELLEY = 1852;
-static const uint32_t PURPOSE_MULTISIG = 1854;
+// static const uint32_t PURPOSE_MULTISIG = 1854;
 
-static const uint32_t PURPOSE_MINT = 1855;
+// static const uint32_t PURPOSE_MINT = 1855;
 
 static const uint32_t PURPOSE_POOL_COLD_KEY = 1853;
 
@@ -45,7 +45,7 @@ enum {
 	BIP44_I_REST = 5,
 
 	// mint keys https://cips.cardano.org/cips/cip1855/
-	BIP44_I_MINT_POLICY = 2,
+	// BIP44_I_MINT_POLICY = 2,
 
 	// pool cold keys https://cips.cardano.org/cips/cip1853/
 	BIP44_I_POOL_COLD_KEY_USECASE = 2,
@@ -56,8 +56,8 @@ enum {
 bool bip44_hasByronPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasShelleyPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasOrdinaryWalletKeyPrefix(const bip44_path_t* pathSpec);
-bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec);
-bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec);
+// bool bip44_hasMultisigWalletKeyPrefix(const bip44_path_t* pathSpec);
+// bool bip44_hasMintKeyPrefix(const bip44_path_t* pathSpec);
 bool bip44_hasPoolColdKeyPrefix(const bip44_path_t* pathSpec);
 
 bool bip44_containsAccount(const bip44_path_t* pathSpec);
@@ -68,15 +68,15 @@ bool bip44_containsChainType(const bip44_path_t* pathSpec);
 
 bool bip44_containsAddress(const bip44_path_t* pathSpec);
 bool bip44_isOrdinarySpendingKeyPath(const bip44_path_t* pathSpec);
-bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_isMultisigSpendingKeyPath(const bip44_path_t* pathSpec);
 bool bip44_hasReasonableAddress(const bip44_path_t* pathSpec);
 
 bool bip44_isOrdinaryStakingKeyPath(const bip44_path_t* pathSpec);
-bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_isMultisigStakingKeyPath(const bip44_path_t* pathSpec);
 
 bool bip44_containsMoreThanAddress(const bip44_path_t* pathSpec);
 
-bool bip44_isMintKeyPath(const bip44_path_t* pathSpec);
+// bool bip44_isMintKeyPath(const bip44_path_t* pathSpec);
 
 bool bip44_isPoolColdKeyPath(const bip44_path_t* pathSpec);
 bool bip44_hasReasonablePoolColdKeyIndex(const bip44_path_t* pathSpec);
@@ -90,18 +90,18 @@ size_t bip44_printToStr(const bip44_path_t*, char* out, size_t outSize);
 typedef enum {
 	// hd wallet account
 	PATH_ORDINARY_ACCOUNT,
-	PATH_MULTISIG_ACCOUNT,
+	// PATH_MULTISIG_ACCOUNT,
 
 	// hd wallet address (payment part in shelley)
 	PATH_ORDINARY_SPENDING_KEY,
-	PATH_MULTISIG_SPENDING_KEY,
+	// PATH_MULTISIG_SPENDING_KEY,
 
 	// hd wallet reward adress, withdrawal witness, pool owner
 	PATH_ORDINARY_STAKING_KEY,
-	PATH_MULTISIG_STAKING_KEY,
+	// PATH_MULTISIG_STAKING_KEY,
 
 	// native token minting/burning
-	PATH_MINT_KEY,
+	// PATH_MINT_KEY,
 
 	// pool cold key in pool registrations and retirements
 	PATH_POOL_COLD_KEY,
diff --git a/src/securityPolicy.c b/src/securityPolicy.c
index 1be5402..d84fcac 100644
--- a/src/securityPolicy.c
+++ b/src/securityPolicy.c
@@ -80,11 +80,11 @@ security_policy_t policyForDerivePrivateKey(const bip44_path_t* path)
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
 
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
 
-	case PATH_MINT_KEY:
+	// case PATH_MINT_KEY:
 
 	case PATH_POOL_COLD_KEY:
 
@@ -127,10 +127,10 @@ security_policy_t policyForGetExtendedPublicKey(const bip44_path_t* pathSpec)
 
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-	case PATH_MINT_KEY:
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MINT_KEY:
 	case PATH_POOL_COLD_KEY:
 		WARN_UNLESS(bip44_isPathReasonable(pathSpec));
 		// ask for permission
@@ -153,10 +153,10 @@ security_policy_t policyForGetExtendedPublicKeyBulkExport(const bip44_path_t* pa
 	case PATH_ORDINARY_ACCOUNT:
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-	case PATH_MINT_KEY:
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MINT_KEY:
 		WARN_UNLESS(bip44_isPathReasonable(pathSpec));
 		// we do not show these paths since there may be many of them
 		ALLOW();
@@ -340,7 +340,7 @@ security_policy_t policyForSignTxInit(
 		break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		// collaterals are allowed only in PLUTUS_TX
 		DENY_IF(numCollaterals > 0);
 		break;
@@ -388,7 +388,7 @@ security_policy_t policyForSignTxInput(sign_tx_signingmode_t txSigningMode)
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		// inputs are not interesting for the user (transferred funds are shown in the outputs)
 		ALLOW();
 		break;
@@ -440,7 +440,7 @@ security_policy_t policyForSignTxOutputAddressBytes(
 		// no Plutus elements for pool registration, only allow in other modes
 		DENY_UNLESS(
 		        txSigningMode == SIGN_TX_SIGNINGMODE_ORDINARY_TX ||
-		        txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
+		        // txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
 		        txSigningMode == SIGN_TX_SIGNINGMODE_PLUTUS_TX
 		);
 	}
@@ -454,7 +454,7 @@ security_policy_t policyForSignTxOutputAddressBytes(
 		break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		// utxo on a Plutus script address without datum hash is unspendable
@@ -522,7 +522,7 @@ security_policy_t policyForSignTxOutputAddressParams(
 		// no Plutus elements for pool registration, only allow in other modes
 		DENY_UNLESS(
 		        txSigningMode == SIGN_TX_SIGNINGMODE_ORDINARY_TX ||
-		        txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
+		        // txSigningMode == SIGN_TX_SIGNINGMODE_MULTISIG_TX ||
 		        txSigningMode == SIGN_TX_SIGNINGMODE_PLUTUS_TX
 		);
 	}
@@ -542,14 +542,14 @@ security_policy_t policyForSignTxOutputAddressParams(
 		break;
 	}
 
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX: {
-		// for simplicity, all outputs should be given as external addresses;
-		// generally, more than one party is needed to sign
-		// spending from a multisig address, so we do not expect
-		// there will be 1852 outputs (that would be considered change)
-		DENY();
-		break;
-	}
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX: {
+	// 	// for simplicity, all outputs should be given as external addresses;
+	// 	// generally, more than one party is needed to sign
+	// 	// spending from a multisig address, so we do not expect
+	// 	// there will be 1852 outputs (that would be considered change)
+	// 	DENY();
+	// 	break;
+	// }
 
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX: {
 		// the output could affect script validation so it must not be entirely hidden
@@ -639,7 +639,7 @@ security_policy_t policyForSignTxFee(
 
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		// always show the fee if it is paid by the signer
 		SHOW();
@@ -680,13 +680,13 @@ security_policy_t policyForSignTxCertificate(
 		ALLOW();
 		break;
 
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-		// pool registration is allowed only in POOL_REGISTRATION signging modes
-		DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
-		// pool retirement is impossible with multisig keys
-		DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
-		ALLOW();
-		break;
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// 	// pool registration is allowed only in POOL_REGISTRATION signging modes
+	// 	DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_REGISTRATION);
+	// 	// pool retirement is impossible with multisig keys
+	// 	DENY_IF(certificateType == CERTIFICATE_TYPE_STAKE_POOL_RETIREMENT);
+	// 	ALLOW();
+	// 	break;
 
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
@@ -729,9 +729,9 @@ security_policy_t policyForSignTxCertificateStaking(
 			PROMPT();
 			break;
 
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -748,9 +748,9 @@ security_policy_t policyForSignTxCertificateStaking(
 			break;
 
 		case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -828,7 +828,7 @@ security_policy_t policyForSignTxStakePoolRegistrationInit(
 		break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		DENY();
 		break;
@@ -998,10 +998,10 @@ security_policy_t policyForSignTxWithdrawal(
 			ALLOW();
 			break;
 
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			// script hash is expected for multisig txs
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	// script hash is expected for multisig txs
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -1026,10 +1026,10 @@ security_policy_t policyForSignTxWithdrawal(
 			DENY();
 			break;
 
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-			// script hash is expected for multisig txs
-			DENY();
-			break;
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// 	// script hash is expected for multisig txs
+		// 	DENY();
+		// 	break;
 
 		default:
 			// in POOL_REGISTRATION signing modes, this certificate should have already been
@@ -1040,7 +1040,7 @@ security_policy_t policyForSignTxWithdrawal(
 
 	case STAKE_CREDENTIAL_SCRIPT_HASH:
 		switch (txSigningMode) {
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 			SHOW_IF(app_mode_expert());
 			ALLOW();
@@ -1088,12 +1088,12 @@ static inline security_policy_t _ordinaryWitnessPolicy(const bip44_path_t* path,
 		SHOW();
 		break;
 
-	case PATH_MINT_KEY:
-		DENY_UNLESS(mintPresent);
-		// maybe not necessary, but let the user know which mint key is he using (eg. in case
-		// the minting policy contains multiple of his keys but with different rules)
-		SHOW();
-		break;
+	// case PATH_MINT_KEY:
+	// 	DENY_UNLESS(mintPresent);
+	// 	// maybe not necessary, but let the user know which mint key is he using (eg. in case
+	// 	// the minting policy contains multiple of his keys but with different rules)
+	// 	SHOW();
+	// 	break;
 
 	default:
 		// multisig keys forbidden
@@ -1102,31 +1102,31 @@ static inline security_policy_t _ordinaryWitnessPolicy(const bip44_path_t* path,
 	}
 }
 
-static inline security_policy_t _multisigWitnessPolicy(const bip44_path_t* path, bool mintPresent)
-{
-	switch (bip44_classifyPath(path)) {
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-		// multisig key paths are allowed, but hiding them would make impossible for the user to
-		// distinguish what funds are being spent (multisig UTXOs sharing a signer are not
-		// necessarily interchangeable, because they may be governed by a different script)
-		WARN_UNLESS(bip44_isPathReasonable(path));
-		SHOW();
-		break;
-
-	case PATH_MINT_KEY:
-		DENY_UNLESS(mintPresent);
-		// maybe not necessary, but let the user know which mint key is he using (eg. in case
-		// the minting policy contains multiple of his keys but with different rules)
-		SHOW();
-		break;
-
-	default:
-		// ordinary and pool cold keys forbidden
-		DENY();
-		break;
-	}
-}
+// static inline security_policy_t _multisigWitnessPolicy(const bip44_path_t* path, bool mintPresent)
+// {
+// 	switch (bip44_classifyPath(path)) {
+// 	case PATH_MULTISIG_SPENDING_KEY:
+// 	case PATH_MULTISIG_STAKING_KEY:
+// 		// multisig key paths are allowed, but hiding them would make impossible for the user to
+// 		// distinguish what funds are being spent (multisig UTXOs sharing a signer are not
+// 		// necessarily interchangeable, because they may be governed by a different script)
+// 		WARN_UNLESS(bip44_isPathReasonable(path));
+// 		SHOW();
+// 		break;
+
+// 	case PATH_MINT_KEY:
+// 		DENY_UNLESS(mintPresent);
+// 		// maybe not necessary, but let the user know which mint key is he using (eg. in case
+// 		// the minting policy contains multiple of his keys but with different rules)
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		// ordinary and pool cold keys forbidden
+// 		DENY();
+// 		break;
+// 	}
+// }
 
 static inline security_policy_t _plutusWitnessPolicy(const bip44_path_t* path, bool mintPresent)
 {
@@ -1134,20 +1134,20 @@ static inline security_policy_t _plutusWitnessPolicy(const bip44_path_t* path, b
 	// in PLUTUS_TX, we allow signing with any path, but it must be shown
 	case PATH_ORDINARY_SPENDING_KEY:
 	case PATH_ORDINARY_STAKING_KEY:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
 		WARN_UNLESS(bip44_isPathReasonable(path));
 		SHOW();
 		break;
 
-	case PATH_MINT_KEY:
-		// mint witness without mint in the tx: somewhat suspicious,
-		// no known usecase, but a mint path could be e.g. in required signers
-		SHOW_UNLESS(mintPresent);
-		// maybe not necessary, but let the user know which mint key is he using (e.g. in case
-		// the minting policy contains multiple of his keys but with different rules)
-		SHOW();
-		break;
+	// case PATH_MINT_KEY:
+	// 	// mint witness without mint in the tx: somewhat suspicious,
+	// 	// no known usecase, but a mint path could be e.g. in required signers
+	// 	SHOW_UNLESS(mintPresent);
+	// 	// maybe not necessary, but let the user know which mint key is he using (e.g. in case
+	// 	// the minting policy contains multiple of his keys but with different rules)
+	// 	SHOW();
+	// 	break;
 
 	case PATH_POOL_COLD_KEY:
 	default:
@@ -1212,8 +1212,8 @@ security_policy_t policyForSignTxWitness(
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 		return _ordinaryWitnessPolicy(witnessPath, mintPresent);
 
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-		return _multisigWitnessPolicy(witnessPath, mintPresent);
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// 	return _multisigWitnessPolicy(witnessPath, mintPresent);
 
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		return _plutusWitnessPolicy(witnessPath, mintPresent);
@@ -1262,50 +1262,50 @@ security_policy_t policyForSignTxValidityIntervalStart()
 }
 
 // For transaction mint field
-security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode)
-{
-	switch (txSigningMode) {
-	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
-	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
-		SHOW();
-		break;
-
-	default:
-		// in POOL_REGISTRATION signing modes, non-empty mint field
-		// should have already been reported as invalid
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
-
-// For final mint confirmation
-security_policy_t policyForSignTxMintConfirm(security_policy_t mintInitPolicy)
-{
-	switch (mintInitPolicy) {
-	case POLICY_ALLOW_WITHOUT_PROMPT:
-		ALLOW();
-		break;
-
-	case POLICY_SHOW_BEFORE_RESPONSE:
-		// all minted coins were shown, show a final cofirmation prompt as well
-		PROMPT();
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	DENY(); // should not be reached
-}
+// security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode)
+// {
+// 	switch (txSigningMode) {
+// 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
+// 	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+// 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
+// 		SHOW();
+// 		break;
+
+// 	default:
+// 		// in POOL_REGISTRATION signing modes, non-empty mint field
+// 		// should have already been reported as invalid
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
+
+// // For final mint confirmation
+// security_policy_t policyForSignTxMintConfirm(security_policy_t mintInitPolicy)
+// {
+// 	switch (mintInitPolicy) {
+// 	case POLICY_ALLOW_WITHOUT_PROMPT:
+// 		ALLOW();
+// 		break;
+
+// 	case POLICY_SHOW_BEFORE_RESPONSE:
+// 		// all minted coins were shown, show a final cofirmation prompt as well
+// 		PROMPT();
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	DENY(); // should not be reached
+// }
 
 // For transaction script data hash
 security_policy_t policyForSignTxScriptDataHash(const sign_tx_signingmode_t txSigningMode)
 {
 	switch (txSigningMode) {
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 		SHOW_IF(app_mode_expert());
 		ALLOW();
@@ -1337,7 +1337,7 @@ security_policy_t policyForSignTxCollateral(const sign_tx_signingmode_t txSignin
 		break;
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
 	case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
 		// collaterals allowed only if Plutus script is to be executed
@@ -1356,7 +1356,7 @@ static bool required_signers_allowed(const sign_tx_signingmode_t txSigningMode)
 	switch (txSigningMode) {
 	case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		return true;
 
 	default:
@@ -1372,13 +1372,13 @@ static bool is_required_signer_allowed(bip44_path_t *path)
 	case PATH_ORDINARY_STAKING_KEY:
 		return bip44_hasShelleyPrefix(path);
 
-	case PATH_MULTISIG_ACCOUNT:
-	case PATH_MULTISIG_SPENDING_KEY:
-	case PATH_MULTISIG_STAKING_KEY:
-		return true;
+	// case PATH_MULTISIG_ACCOUNT:
+	// case PATH_MULTISIG_SPENDING_KEY:
+	// case PATH_MULTISIG_STAKING_KEY:
+	// 	return true;
 
-	case PATH_MINT_KEY:
-		return true;
+	// case PATH_MINT_KEY:
+	// 	return true;
 
 	default:
 		return false;
diff --git a/src/securityPolicy.h b/src/securityPolicy.h
index 48cba45..756794c 100644
--- a/src/securityPolicy.h
+++ b/src/securityPolicy.h
@@ -122,8 +122,8 @@ security_policy_t policyForSignTxAuxData(aux_data_type_t auxDataType);
 
 security_policy_t policyForSignTxValidityIntervalStart();
 
-security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode);
-security_policy_t policyForSignTxMintConfirm(security_policy_t outputPolicy);
+// security_policy_t policyForSignTxMintInit(const sign_tx_signingmode_t txSigningMode);
+// security_policy_t policyForSignTxMintConfirm(security_policy_t outputPolicy);
 
 security_policy_t policyForSignTxScriptDataHash(const sign_tx_signingmode_t txSigningMode);
 
diff --git a/src/signTx.c b/src/signTx.c
index ec23d83..519d90f 100644
--- a/src/signTx.c
+++ b/src/signTx.c
@@ -187,23 +187,23 @@ static inline void advanceStage()
 			ASSERT(BODY_CTX->validityIntervalStartReceived);
 		}
 		ctx->stage = SIGN_STAGE_BODY_MINT;
-		if (ctx->includeMint) {
-			txHashBuilder_enterMint(&BODY_CTX->txHashBuilder);
-			signTxMint_init();
-			// wait for mint APDU
-			break;
-		}
+		// if (ctx->includeMint) {
+		// 	txHashBuilder_enterMint(&BODY_CTX->txHashBuilder);
+		// 	signTxMint_init();
+		// 	// wait for mint APDU
+		// 	break;
+		// }
 
 	// intentional fallthrough
 
-	case SIGN_STAGE_BODY_MINT:
-		if (ctx->includeMint) {
-			ASSERT(BODY_CTX->mintReceived);
-		}
-		ctx->stage = SIGN_STAGE_BODY_SCRIPT_DATA_HASH;
-		if (ctx->includeScriptDataHash) {
-			break;
-		}
+	// case SIGN_STAGE_BODY_MINT:
+	// 	if (ctx->includeMint) {
+	// 		ASSERT(BODY_CTX->mintReceived);
+	// 	}
+	// 	ctx->stage = SIGN_STAGE_BODY_SCRIPT_DATA_HASH;
+	// 	if (ctx->includeScriptDataHash) {
+	// 		break;
+	// 	}
 
 	// intentional fallthrough
 
@@ -341,13 +341,13 @@ static inline void checkForFinishedSubmachines()
 		}
 		break;
 
-	case SIGN_STAGE_BODY_MINT_SUBMACHINE:
-		if (signTxMint_isFinished()) {
-			TRACE();
-			ctx->stage = SIGN_STAGE_BODY_MINT;
-			BODY_CTX->mintReceived = true;
-			advanceStage();
-		}
+	// case SIGN_STAGE_BODY_MINT_SUBMACHINE:
+	// 	if (signTxMint_isFinished()) {
+	// 		TRACE();
+	// 		ctx->stage = SIGN_STAGE_BODY_MINT;
+	// 		BODY_CTX->mintReceived = true;
+	// 		advanceStage();
+	// 	}
 	default:
 		break; // nothing to do otherwise
 	}
@@ -523,8 +523,8 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 		ctx->includeValidityIntervalStart = signTx_parseIncluded(wireHeader->includeValidityIntervalStart);
 		TRACE("Include validity interval start %d", ctx->includeValidityIntervalStart);
 
-		ctx->includeMint = signTx_parseIncluded(wireHeader->includeMint);
-		TRACE("Include mint %d", ctx->includeMint);
+		// ctx->includeMint = signTx_parseIncluded(wireHeader->includeMint);
+		// TRACE("Include mint %d", ctx->includeMint);
 
 		ctx->includeScriptDataHash = signTx_parseIncluded(wireHeader->includeScriptDataHash);
 		TRACE("Include script data hash %d", ctx->includeScriptDataHash);
@@ -538,7 +538,7 @@ static void signTx_handleInitAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wi
 		case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
 		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OWNER:
 		case SIGN_TX_SIGNINGMODE_POOL_REGISTRATION_OPERATOR:
-		case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+		// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		case SIGN_TX_SIGNINGMODE_PLUTUS_TX:
 			// these signing modes are allowed
 			break;
@@ -1740,24 +1740,24 @@ static void signTx_handleValidityIntervalStartAPDU(uint8_t p2, uint8_t* wireData
 
 // ============================== MINT ==============================
 
-static void signTx_handleMintAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		TRACE("p2 = %d", p2);
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-	}
+// static void signTx_handleMintAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		TRACE("p2 = %d", p2);
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 	}
 
-	if (ctx->stage == SIGN_STAGE_BODY_MINT) {
-		ctx->stage = SIGN_STAGE_BODY_MINT_SUBMACHINE;
-	}
+// 	if (ctx->stage == SIGN_STAGE_BODY_MINT) {
+// 		ctx->stage = SIGN_STAGE_BODY_MINT_SUBMACHINE;
+// 	}
 
-	CHECK_STAGE(SIGN_STAGE_BODY_MINT_SUBMACHINE);
+// 	CHECK_STAGE(SIGN_STAGE_BODY_MINT_SUBMACHINE);
 
-	// all mint handling is delegated to a state sub-machine
-	VALIDATE(signTxMint_isValidInstruction(p2), ERR_INVALID_DATA);
-	signTxMint_handleAPDU(p2, wireDataBuffer, wireDataSize);
-}
+// 	// all mint handling is delegated to a state sub-machine
+// 	VALIDATE(signTxMint_isValidInstruction(p2), ERR_INVALID_DATA);
+// 	signTxMint_handleAPDU(p2, wireDataBuffer, wireDataSize);
+// }
 
 // ========================= SCRIPT DATA HASH ==========================
 
@@ -2084,7 +2084,7 @@ static bool _shouldDisplayTxId(sign_tx_signingmode_t signingMode)
 	switch(signingMode) {
 
 	case SIGN_TX_SIGNINGMODE_ORDINARY_TX:
-	case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
+	// case SIGN_TX_SIGNINGMODE_MULTISIG_TX:
 		if (ctx->shouldDisplayTxid && app_mode_expert())
 			return true;
 		return false;
@@ -2293,7 +2293,7 @@ static subhandler_fn_t* lookup_subhandler(uint8_t p1)
 		CASE(0x06, signTx_handleCertificateAPDU);
 		CASE(0x07, signTx_handleWithdrawalAPDU);
 		CASE(0x09, signTx_handleValidityIntervalStartAPDU);
-		CASE(0x0b, signTx_handleMintAPDU);
+		// CASE(0x0b, signTx_handleMintAPDU);
 		CASE(0x0c, signTx_handleScriptDataHashAPDU);
 		CASE(0x0d, signTx_handleCollateralAPDU);
 		CASE(0x0e, signTx_handleRequiredSignerAPDU);
diff --git a/src/signTx.h b/src/signTx.h
index 255a070..1c293a5 100644
--- a/src/signTx.h
+++ b/src/signTx.h
@@ -7,7 +7,7 @@
 #include "txHashBuilder.h"
 #include "bip44.h"
 #include "addressUtilsShelley.h"
-#include "signTxMint.h"
+// #include "signTxMint.h"
 #include "signTxOutput.h"
 #include "signTxPoolRegistration.h"
 #include "signTxCatalystRegistration.h"
@@ -164,7 +164,7 @@ typedef struct {
 	union {
 		pool_registration_context_t pool_registration_subctx;
 		output_context_t output_subctx;
-		mint_context_t mint_subctx;
+		// mint_context_t mint_subctx;
 	} stageContext;
 } ins_sign_tx_body_context_t;
 
diff --git a/src/signTxMint.c b/src/signTxMint.c
index dcacf7a..1b42afb 100644
--- a/src/signTxMint.c
+++ b/src/signTxMint.c
@@ -1,468 +1,468 @@
-#include "signTxMint.h"
-#include "signTxUtils.h"
-#include "state.h"
-#include "uiHelpers.h"
-#include "utils.h"
-#include "uiScreens.h"
-#include "textUtils.h"
-#include "securityPolicy.h"
-#include "tokens.h"
-
-static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
-
-static mint_context_t* accessSubcontext()
-{
-	return &BODY_CTX->stageContext.mint_subctx;
-}
-
-static inline void CHECK_STATE(sign_tx_mint_state_t expected)
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("Mint submachine state: current %d, expected %d", subctx->state, expected);
-	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
-}
-
-static inline void advanceState()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("Advancing mint state from: %d", subctx->state);
-
-	switch (subctx->state) {
-
-	case STATE_MINT_TOP_LEVEL_DATA:
-		ASSERT(subctx->numAssetGroups > 0);
-		ASSERT(subctx->currentAssetGroup == 0);
-		subctx->state = STATE_MINT_ASSET_GROUP;
-		break;
-
-	case STATE_MINT_ASSET_GROUP:
-		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
-
-		// we are going to receive token amounts for this group
-		ASSERT(subctx->numTokens > 0);
-		ASSERT(subctx->currentToken == 0);
-
-		subctx->state = STATE_MINT_TOKEN;
-		break;
-
-	case STATE_MINT_TOKEN:
-		// we are done with the current token group
-		ASSERT(subctx->currentToken == subctx->numTokens);
-		subctx->currentToken = 0;
-		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
-		subctx->currentAssetGroup++;
-
-		if (subctx->currentAssetGroup == subctx->numAssetGroups) {
-			// the whole token bundle has been received
-			subctx->state = STATE_MINT_CONFIRM;
-		} else {
-			subctx->state = STATE_MINT_ASSET_GROUP;
-		}
-		break;
-
-	case STATE_MINT_CONFIRM:
-		subctx->state = STATE_MINT_FINISHED;
-		break;
-
-	default:
-		ASSERT(false);
-	}
-
-	TRACE("Advancing mint state to: %d", subctx->state);
-}
-
-enum {
-	HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY = 9200,
-	HANDLE_MINT_TOP_LEVEL_DATA_RESPOND,
-	HANDLE_MINT_TOP_LEVEL_DATA_INVALID,
-};
-
-__noinline_due_to_stack__
-static void signTxMint_handleTopLevelData_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-
-	ui_callback_fn_t* this_fn = signTxMint_handleTopLevelData_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY) {
-		char secondLine[50] = {0};
-		explicit_bzero(secondLine, SIZEOF(secondLine));
-		STATIC_ASSERT(!IS_SIGNED(subctx->numAssetGroups), "signed type for %u");
-		snprintf(secondLine, SIZEOF(secondLine), "%u asset groups", subctx->numAssetGroups);
-		ASSERT(strlen(secondLine) + 1 < SIZEOF(secondLine));
-
-		ui_displayPaginatedText(
-		        "Mint",
-		        secondLine,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_MINT_TOP_LEVEL_DATA_INVALID);
-}
-
-static void signTxMint_handleTopLevelDataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// safety checks
-		CHECK_STATE(STATE_MINT_TOP_LEVEL_DATA);
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	TRACE_BUFFER(wireDataBuffer, wireDataSize);
-	mint_context_t* subctx = accessSubcontext();
-	{
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		uint32_t numAssetGroups = parse_u4be(&view);
-		TRACE("num asset groups %u", numAssetGroups);
-		VALIDATE(numAssetGroups <= OUTPUT_ASSET_GROUPS_MAX, ERR_INVALID_DATA);
-		VALIDATE(numAssetGroups > 0, ERR_INVALID_DATA);
-
-		STATIC_ASSERT(OUTPUT_ASSET_GROUPS_MAX <= UINT16_MAX, "wrong max token groups");
-		ASSERT_TYPE(subctx->numAssetGroups, uint16_t);
-		subctx->numAssetGroups = (uint16_t) numAssetGroups;
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-	subctx->mintSecurityPolicy = policyForSignTxMintInit(commonTxData->txSigningMode);
-	ENSURE_NOT_DENIED(subctx->mintSecurityPolicy);
-
-	txHashBuilder_addMint_topLevelData(&BODY_CTX->txHashBuilder, subctx->numAssetGroups);
-
-	subctx->ui_step = HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY;
-	signTxMint_handleTopLevelData_ui_runStep();
-}
-
-enum {
-	HANDLE_ASSET_GROUP_STEP_DISPLAY = 9300,
-	HANDLE_ASSET_GROUP_STEP_RESPOND,
-	HANDLE_ASSET_GROUP_STEP_INVALID,
-};
-
-static void signTxMint_handleAssetGroup_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-
-	ui_callback_fn_t* this_fn = signTxMint_handleAssetGroup_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_ASSET_GROUP_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_ASSET_GROUP_STEP_INVALID);
-}
-
-static void signTxMint_handleAssetGroupAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// sanity checks
-		CHECK_STATE(STATE_MINT_ASSET_GROUP);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	mint_context_t* subctx = accessSubcontext();
-	{
-		token_group_t* tokenGroup = &subctx->stateData.tokenGroup;
-
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		uint8_t candidatePolicyId[MINTING_POLICY_ID_SIZE] = {0};
-		view_parseBuffer(candidatePolicyId, &view, MINTING_POLICY_ID_SIZE);
-
-		if (subctx->currentAssetGroup > 0) {
-			// compare with previous value before overwriting it
-			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
-			                 tokenGroup->policyId, MINTING_POLICY_ID_SIZE,
-			                 candidatePolicyId, MINTING_POLICY_ID_SIZE
-			         ), ERR_INVALID_DATA);
-		}
-
-		STATIC_ASSERT(SIZEOF(tokenGroup->policyId) >= MINTING_POLICY_ID_SIZE, "wrong policyId length");
-		memmove(tokenGroup->policyId, candidatePolicyId, MINTING_POLICY_ID_SIZE);
-
-		uint32_t numTokens = parse_u4be(&view);
-		VALIDATE(numTokens <= OUTPUT_TOKENS_IN_GROUP_MAX, ERR_INVALID_DATA);
-		VALIDATE(numTokens > 0, ERR_INVALID_DATA);
-		STATIC_ASSERT(OUTPUT_TOKENS_IN_GROUP_MAX <= UINT16_MAX, "wrong max token amounts in a group");
-		ASSERT_TYPE(subctx->numTokens, uint16_t);
-		subctx->numTokens = (uint16_t) numTokens;
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	{
-		// add tokengroup to tx
-		TRACE("Adding token group hash to tx hash");
-		txHashBuilder_addMint_tokenGroup(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.tokenGroup.policyId, MINTING_POLICY_ID_SIZE,
-		        subctx->numTokens
-		);
-		TRACE();
-	}
-
-	subctx->ui_step = HANDLE_ASSET_GROUP_STEP_RESPOND;
-	signTxMint_handleAssetGroup_ui_runStep();
-}
-
-enum {
-	HANDLE_TOKEN_STEP_DISPLAY_NAME = 9400,
-	HANDLE_TOKEN_STEP_DISPLAY_AMOUNT,
-	HANDLE_TOKEN_STEP_RESPOND,
-	HANDLE_TOKEN_STEP_INVALID,
-};
-
-
-static void signTxMint_handleToken_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	ui_callback_fn_t* this_fn = signTxMint_handleToken_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_NAME) {
-		ui_displayAssetFingerprintScreen(
-		        &subctx->stateData.tokenGroup,
-		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_AMOUNT) {
-		ui_displayTokenAmountMintScreen(
-		        &subctx->stateData.tokenGroup,
-		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
-		        subctx->stateData.token.amount,
-		        this_fn
-		);
-	}
-	UI_STEP(HANDLE_TOKEN_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-
-		ASSERT(subctx->currentToken < subctx->numTokens);
-		subctx->currentToken++;
-
-		if (subctx->currentToken == subctx->numTokens) {
-			advanceState();
-		}
-	}
-	UI_STEP_END(HANDLE_TOKEN_STEP_INVALID);
-}
-
-static void signTxMint_handleTokenAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	{
-		// sanity checks
-		CHECK_STATE(STATE_MINT_TOKEN);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-	mint_context_t* subctx = accessSubcontext();
-	{
-		mint_token_amount_t* token = &subctx->stateData.token;
-
-		// parse data
-		TRACE_BUFFER(wireDataBuffer, wireDataSize);
-		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
-
-		const size_t candidateAssetNameSize = parse_u4be(&view);
-		VALIDATE(candidateAssetNameSize <= ASSET_NAME_SIZE_MAX, ERR_INVALID_DATA);
-		uint8_t candidateAssetNameBytes[ASSET_NAME_SIZE_MAX] = {0};
-		view_parseBuffer(candidateAssetNameBytes, &view, candidateAssetNameSize);
-
-		if (subctx->currentToken > 0) {
-			// compare with previous value before overwriting it
-			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
-			                 token->assetNameBytes, token->assetNameSize,
-			                 candidateAssetNameBytes, candidateAssetNameSize
-			         ), ERR_INVALID_DATA);
-		}
-
-		token->assetNameSize = candidateAssetNameSize;
-		STATIC_ASSERT(SIZEOF(token->assetNameBytes) >= ASSET_NAME_SIZE_MAX, "wrong asset name buffer size");
-		memmove(token->assetNameBytes, candidateAssetNameBytes, candidateAssetNameSize);
-
-		token->amount = parse_int64be(&view);
-		TRACE_INT64(token->amount);
-
-		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
-	}
-
-	{
-		// select UI step
-		switch (subctx->mintSecurityPolicy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_TOKEN_STEP_DISPLAY_NAME);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_TOKEN_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	{
-		// add tokengroup to tx
-		TRACE("Adding token group hash to tx hash");
-		txHashBuilder_addMint_token(
-		        &BODY_CTX->txHashBuilder,
-		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
-		        subctx->stateData.token.amount
-		);
-		TRACE();
-	}
-
-	signTxMint_handleToken_ui_runStep();
-}
-
-enum {
-	HANDLE_CONFIRM_STEP_FINAL_CONFIRM = 9500,
-	HANDLE_CONFIRM_STEP_RESPOND,
-	HANDLE_CONFIRM_STEP_INVALID,
-};
-
-static void signTxMint_handleConfirm_ui_runStep()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("UI step %d", subctx->ui_step);
-	ui_callback_fn_t* this_fn = signTxMint_handleConfirm_ui_runStep;
-
-	UI_STEP_BEGIN(subctx->ui_step, this_fn);
-
-	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
-		ui_displayPrompt(
-		        "Confirm",
-		        "mint?",
-		        this_fn,
-		        respond_with_user_reject
-		);
-	}
-	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
-		respondSuccessEmptyMsg();
-		advanceState();
-	}
-	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
-}
-
-static void signTxMint_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
-{
-	{
-		//sanity checks
-		CHECK_STATE(STATE_MINT_CONFIRM);
-
-		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-	}
-
-	{
-		// no data to receive
-		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
-	}
-
-	mint_context_t* subctx = accessSubcontext();
-	security_policy_t policy = policyForSignTxMintConfirm(subctx->mintSecurityPolicy);
-	TRACE("Policy: %d", (int) policy);
-	ENSURE_NOT_DENIED(policy);
-
-	{
-		// select UI step
-		switch (policy) {
-#define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
-			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
-			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
-#undef   CASE
-		default:
-			THROW(ERR_NOT_IMPLEMENTED);
-		}
-	}
-
-	signTxMint_handleConfirm_ui_runStep();
-}
-
-enum {
-	APDU_INSTRUCTION_TOP_LEVEL_DATA = 0x30,
-	APDU_INSTRUCTION_ASSET_GROUP = 0x31,
-	APDU_INSTRUCTION_TOKEN = 0x32,
-	APDU_INSTRUCTION_CONFIRM = 0x33,
-};
-
-bool signTxMint_isValidInstruction(uint8_t p2)
-{
-	switch (p2) {
-	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
-	case APDU_INSTRUCTION_ASSET_GROUP:
-	case APDU_INSTRUCTION_TOKEN:
-	case APDU_INSTRUCTION_CONFIRM:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-void signTxMint_init()
-{
-	{
-		explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
-	}
-
-	accessSubcontext()->state = STATE_MINT_TOP_LEVEL_DATA;
-}
-
-void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
-{
-	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
-
-	switch (p2) {
-	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
-		signTxMint_handleTopLevelDataAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_ASSET_GROUP:
-		signTxMint_handleAssetGroupAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_TOKEN:
-		signTxMint_handleTokenAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	case APDU_INSTRUCTION_CONFIRM:
-		signTxMint_handleConfirmAPDU(wireDataBuffer, wireDataSize);
-		break;
-
-	default:
-		// this is not supposed to be called with invalid p2
-		ASSERT(false);
-	}
-}
-
-bool signTxMint_isFinished()
-{
-	mint_context_t* subctx = accessSubcontext();
-	TRACE("Mint submachine state: %d", subctx->state);
-	// we are also asserting that the state is valid
-	switch (subctx->state) {
-	case STATE_MINT_FINISHED:
-		return true;
-
-	case STATE_MINT_TOP_LEVEL_DATA:
-	case STATE_MINT_ASSET_GROUP:
-	case STATE_MINT_TOKEN:
-	case STATE_MINT_CONFIRM:
-		return false;
-
-	default:
-		ASSERT(false);
-	}
-}
+// #include "signTxMint.h"
+// #include "signTxUtils.h"
+// #include "state.h"
+// #include "uiHelpers.h"
+// #include "utils.h"
+// #include "uiScreens.h"
+// #include "textUtils.h"
+// #include "securityPolicy.h"
+// #include "tokens.h"
+
+// static common_tx_data_t* commonTxData = &(instructionState.signTxContext.commonTxData);
+
+// static mint_context_t* accessSubcontext()
+// {
+// 	return &BODY_CTX->stageContext.mint_subctx;
+// }
+
+// static inline void CHECK_STATE(sign_tx_mint_state_t expected)
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("Mint submachine state: current %d, expected %d", subctx->state, expected);
+// 	VALIDATE(subctx->state == expected, ERR_INVALID_STATE);
+// }
+
+// static inline void advanceState()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("Advancing mint state from: %d", subctx->state);
+
+// 	switch (subctx->state) {
+
+// 	case STATE_MINT_TOP_LEVEL_DATA:
+// 		ASSERT(subctx->numAssetGroups > 0);
+// 		ASSERT(subctx->currentAssetGroup == 0);
+// 		subctx->state = STATE_MINT_ASSET_GROUP;
+// 		break;
+
+// 	case STATE_MINT_ASSET_GROUP:
+// 		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
+
+// 		// we are going to receive token amounts for this group
+// 		ASSERT(subctx->numTokens > 0);
+// 		ASSERT(subctx->currentToken == 0);
+
+// 		subctx->state = STATE_MINT_TOKEN;
+// 		break;
+
+// 	case STATE_MINT_TOKEN:
+// 		// we are done with the current token group
+// 		ASSERT(subctx->currentToken == subctx->numTokens);
+// 		subctx->currentToken = 0;
+// 		ASSERT(subctx->currentAssetGroup < subctx->numAssetGroups);
+// 		subctx->currentAssetGroup++;
+
+// 		if (subctx->currentAssetGroup == subctx->numAssetGroups) {
+// 			// the whole token bundle has been received
+// 			subctx->state = STATE_MINT_CONFIRM;
+// 		} else {
+// 			subctx->state = STATE_MINT_ASSET_GROUP;
+// 		}
+// 		break;
+
+// 	case STATE_MINT_CONFIRM:
+// 		subctx->state = STATE_MINT_FINISHED;
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+
+// 	TRACE("Advancing mint state to: %d", subctx->state);
+// }
+
+// enum {
+// 	HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY = 9200,
+// 	HANDLE_MINT_TOP_LEVEL_DATA_RESPOND,
+// 	HANDLE_MINT_TOP_LEVEL_DATA_INVALID,
+// };
+
+// __noinline_due_to_stack__
+// static void signTxMint_handleTopLevelData_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+
+// 	ui_callback_fn_t* this_fn = signTxMint_handleTopLevelData_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY) {
+// 		char secondLine[50] = {0};
+// 		explicit_bzero(secondLine, SIZEOF(secondLine));
+// 		STATIC_ASSERT(!IS_SIGNED(subctx->numAssetGroups), "signed type for %u");
+// 		snprintf(secondLine, SIZEOF(secondLine), "%u asset groups", subctx->numAssetGroups);
+// 		ASSERT(strlen(secondLine) + 1 < SIZEOF(secondLine));
+
+// 		ui_displayPaginatedText(
+// 		        "Mint",
+// 		        secondLine,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_MINT_TOP_LEVEL_DATA_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_MINT_TOP_LEVEL_DATA_INVALID);
+// }
+
+// static void signTxMint_handleTopLevelDataAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// safety checks
+// 		CHECK_STATE(STATE_MINT_TOP_LEVEL_DATA);
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 	mint_context_t* subctx = accessSubcontext();
+// 	{
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		uint32_t numAssetGroups = parse_u4be(&view);
+// 		TRACE("num asset groups %u", numAssetGroups);
+// 		VALIDATE(numAssetGroups <= OUTPUT_ASSET_GROUPS_MAX, ERR_INVALID_DATA);
+// 		VALIDATE(numAssetGroups > 0, ERR_INVALID_DATA);
+
+// 		STATIC_ASSERT(OUTPUT_ASSET_GROUPS_MAX <= UINT16_MAX, "wrong max token groups");
+// 		ASSERT_TYPE(subctx->numAssetGroups, uint16_t);
+// 		subctx->numAssetGroups = (uint16_t) numAssetGroups;
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+// 	subctx->mintSecurityPolicy = policyForSignTxMintInit(commonTxData->txSigningMode);
+// 	ENSURE_NOT_DENIED(subctx->mintSecurityPolicy);
+
+// 	txHashBuilder_addMint_topLevelData(&BODY_CTX->txHashBuilder, subctx->numAssetGroups);
+
+// 	subctx->ui_step = HANDLE_MINT_TOP_LEVEL_DATA_DISPLAY;
+// 	signTxMint_handleTopLevelData_ui_runStep();
+// }
+
+// enum {
+// 	HANDLE_ASSET_GROUP_STEP_DISPLAY = 9300,
+// 	HANDLE_ASSET_GROUP_STEP_RESPOND,
+// 	HANDLE_ASSET_GROUP_STEP_INVALID,
+// };
+
+// static void signTxMint_handleAssetGroup_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+
+// 	ui_callback_fn_t* this_fn = signTxMint_handleAssetGroup_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_ASSET_GROUP_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_ASSET_GROUP_STEP_INVALID);
+// }
+
+// static void signTxMint_handleAssetGroupAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_MINT_ASSET_GROUP);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	mint_context_t* subctx = accessSubcontext();
+// 	{
+// 		token_group_t* tokenGroup = &subctx->stateData.tokenGroup;
+
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		uint8_t candidatePolicyId[MINTING_POLICY_ID_SIZE] = {0};
+// 		view_parseBuffer(candidatePolicyId, &view, MINTING_POLICY_ID_SIZE);
+
+// 		if (subctx->currentAssetGroup > 0) {
+// 			// compare with previous value before overwriting it
+// 			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
+// 			                 tokenGroup->policyId, MINTING_POLICY_ID_SIZE,
+// 			                 candidatePolicyId, MINTING_POLICY_ID_SIZE
+// 			         ), ERR_INVALID_DATA);
+// 		}
+
+// 		STATIC_ASSERT(SIZEOF(tokenGroup->policyId) >= MINTING_POLICY_ID_SIZE, "wrong policyId length");
+// 		memmove(tokenGroup->policyId, candidatePolicyId, MINTING_POLICY_ID_SIZE);
+
+// 		uint32_t numTokens = parse_u4be(&view);
+// 		VALIDATE(numTokens <= OUTPUT_TOKENS_IN_GROUP_MAX, ERR_INVALID_DATA);
+// 		VALIDATE(numTokens > 0, ERR_INVALID_DATA);
+// 		STATIC_ASSERT(OUTPUT_TOKENS_IN_GROUP_MAX <= UINT16_MAX, "wrong max token amounts in a group");
+// 		ASSERT_TYPE(subctx->numTokens, uint16_t);
+// 		subctx->numTokens = (uint16_t) numTokens;
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	{
+// 		// add tokengroup to tx
+// 		TRACE("Adding token group hash to tx hash");
+// 		txHashBuilder_addMint_tokenGroup(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.tokenGroup.policyId, MINTING_POLICY_ID_SIZE,
+// 		        subctx->numTokens
+// 		);
+// 		TRACE();
+// 	}
+
+// 	subctx->ui_step = HANDLE_ASSET_GROUP_STEP_RESPOND;
+// 	signTxMint_handleAssetGroup_ui_runStep();
+// }
+
+// enum {
+// 	HANDLE_TOKEN_STEP_DISPLAY_NAME = 9400,
+// 	HANDLE_TOKEN_STEP_DISPLAY_AMOUNT,
+// 	HANDLE_TOKEN_STEP_RESPOND,
+// 	HANDLE_TOKEN_STEP_INVALID,
+// };
+
+
+// static void signTxMint_handleToken_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	ui_callback_fn_t* this_fn = signTxMint_handleToken_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_NAME) {
+// 		ui_displayAssetFingerprintScreen(
+// 		        &subctx->stateData.tokenGroup,
+// 		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_TOKEN_STEP_DISPLAY_AMOUNT) {
+// 		ui_displayTokenAmountMintScreen(
+// 		        &subctx->stateData.tokenGroup,
+// 		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
+// 		        subctx->stateData.token.amount,
+// 		        this_fn
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_TOKEN_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+
+// 		ASSERT(subctx->currentToken < subctx->numTokens);
+// 		subctx->currentToken++;
+
+// 		if (subctx->currentToken == subctx->numTokens) {
+// 			advanceState();
+// 		}
+// 	}
+// 	UI_STEP_END(HANDLE_TOKEN_STEP_INVALID);
+// }
+
+// static void signTxMint_handleTokenAPDU(uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	{
+// 		// sanity checks
+// 		CHECK_STATE(STATE_MINT_TOKEN);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+// 	mint_context_t* subctx = accessSubcontext();
+// 	{
+// 		mint_token_amount_t* token = &subctx->stateData.token;
+
+// 		// parse data
+// 		TRACE_BUFFER(wireDataBuffer, wireDataSize);
+// 		read_view_t view = make_read_view(wireDataBuffer, wireDataBuffer + wireDataSize);
+
+// 		const size_t candidateAssetNameSize = parse_u4be(&view);
+// 		VALIDATE(candidateAssetNameSize <= ASSET_NAME_SIZE_MAX, ERR_INVALID_DATA);
+// 		uint8_t candidateAssetNameBytes[ASSET_NAME_SIZE_MAX] = {0};
+// 		view_parseBuffer(candidateAssetNameBytes, &view, candidateAssetNameSize);
+
+// 		if (subctx->currentToken > 0) {
+// 			// compare with previous value before overwriting it
+// 			VALIDATE(cbor_mapKeyFulfillsCanonicalOrdering(
+// 			                 token->assetNameBytes, token->assetNameSize,
+// 			                 candidateAssetNameBytes, candidateAssetNameSize
+// 			         ), ERR_INVALID_DATA);
+// 		}
+
+// 		token->assetNameSize = candidateAssetNameSize;
+// 		STATIC_ASSERT(SIZEOF(token->assetNameBytes) >= ASSET_NAME_SIZE_MAX, "wrong asset name buffer size");
+// 		memmove(token->assetNameBytes, candidateAssetNameBytes, candidateAssetNameSize);
+
+// 		token->amount = parse_int64be(&view);
+// 		TRACE_INT64(token->amount);
+
+// 		VALIDATE(view_remainingSize(&view) == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	{
+// 		// select UI step
+// 		switch (subctx->mintSecurityPolicy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_SHOW_BEFORE_RESPONSE, HANDLE_TOKEN_STEP_DISPLAY_NAME);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_TOKEN_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	{
+// 		// add tokengroup to tx
+// 		TRACE("Adding token group hash to tx hash");
+// 		txHashBuilder_addMint_token(
+// 		        &BODY_CTX->txHashBuilder,
+// 		        subctx->stateData.token.assetNameBytes, subctx->stateData.token.assetNameSize,
+// 		        subctx->stateData.token.amount
+// 		);
+// 		TRACE();
+// 	}
+
+// 	signTxMint_handleToken_ui_runStep();
+// }
+
+// enum {
+// 	HANDLE_CONFIRM_STEP_FINAL_CONFIRM = 9500,
+// 	HANDLE_CONFIRM_STEP_RESPOND,
+// 	HANDLE_CONFIRM_STEP_INVALID,
+// };
+
+// static void signTxMint_handleConfirm_ui_runStep()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("UI step %d", subctx->ui_step);
+// 	ui_callback_fn_t* this_fn = signTxMint_handleConfirm_ui_runStep;
+
+// 	UI_STEP_BEGIN(subctx->ui_step, this_fn);
+
+// 	UI_STEP(HANDLE_CONFIRM_STEP_FINAL_CONFIRM) {
+// 		ui_displayPrompt(
+// 		        "Confirm",
+// 		        "mint?",
+// 		        this_fn,
+// 		        respond_with_user_reject
+// 		);
+// 	}
+// 	UI_STEP(HANDLE_CONFIRM_STEP_RESPOND) {
+// 		respondSuccessEmptyMsg();
+// 		advanceState();
+// 	}
+// 	UI_STEP_END(HANDLE_CONFIRM_STEP_INVALID);
+// }
+
+// static void signTxMint_handleConfirmAPDU(uint8_t* wireDataBuffer MARK_UNUSED, size_t wireDataSize)
+// {
+// 	{
+// 		//sanity checks
+// 		CHECK_STATE(STATE_MINT_CONFIRM);
+
+// 		ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+// 	}
+
+// 	{
+// 		// no data to receive
+// 		VALIDATE(wireDataSize == 0, ERR_INVALID_DATA);
+// 	}
+
+// 	mint_context_t* subctx = accessSubcontext();
+// 	security_policy_t policy = policyForSignTxMintConfirm(subctx->mintSecurityPolicy);
+// 	TRACE("Policy: %d", (int) policy);
+// 	ENSURE_NOT_DENIED(policy);
+
+// 	{
+// 		// select UI step
+// 		switch (policy) {
+// #define  CASE(POLICY, UI_STEP) case POLICY: {subctx->ui_step=UI_STEP; break;}
+// 			CASE(POLICY_PROMPT_BEFORE_RESPONSE, HANDLE_CONFIRM_STEP_FINAL_CONFIRM);
+// 			CASE(POLICY_ALLOW_WITHOUT_PROMPT, HANDLE_CONFIRM_STEP_RESPOND);
+// #undef   CASE
+// 		default:
+// 			THROW(ERR_NOT_IMPLEMENTED);
+// 		}
+// 	}
+
+// 	signTxMint_handleConfirm_ui_runStep();
+// }
+
+// enum {
+// 	APDU_INSTRUCTION_TOP_LEVEL_DATA = 0x30,
+// 	APDU_INSTRUCTION_ASSET_GROUP = 0x31,
+// 	APDU_INSTRUCTION_TOKEN = 0x32,
+// 	APDU_INSTRUCTION_CONFIRM = 0x33,
+// };
+
+// bool signTxMint_isValidInstruction(uint8_t p2)
+// {
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
+// 	case APDU_INSTRUCTION_ASSET_GROUP:
+// 	case APDU_INSTRUCTION_TOKEN:
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		return true;
+
+// 	default:
+// 		return false;
+// 	}
+// }
+
+// void signTxMint_init()
+// {
+// 	{
+// 		explicit_bzero(&BODY_CTX->stageContext, SIZEOF(BODY_CTX->stageContext));
+// 	}
+
+// 	accessSubcontext()->state = STATE_MINT_TOP_LEVEL_DATA;
+// }
+
+// void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize)
+// {
+// 	ASSERT(wireDataSize < BUFFER_SIZE_PARANOIA);
+
+// 	switch (p2) {
+// 	case APDU_INSTRUCTION_TOP_LEVEL_DATA:
+// 		signTxMint_handleTopLevelDataAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_ASSET_GROUP:
+// 		signTxMint_handleAssetGroupAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_TOKEN:
+// 		signTxMint_handleTokenAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	case APDU_INSTRUCTION_CONFIRM:
+// 		signTxMint_handleConfirmAPDU(wireDataBuffer, wireDataSize);
+// 		break;
+
+// 	default:
+// 		// this is not supposed to be called with invalid p2
+// 		ASSERT(false);
+// 	}
+// }
+
+// bool signTxMint_isFinished()
+// {
+// 	mint_context_t* subctx = accessSubcontext();
+// 	TRACE("Mint submachine state: %d", subctx->state);
+// 	// we are also asserting that the state is valid
+// 	switch (subctx->state) {
+// 	case STATE_MINT_FINISHED:
+// 		return true;
+
+// 	case STATE_MINT_TOP_LEVEL_DATA:
+// 	case STATE_MINT_ASSET_GROUP:
+// 	case STATE_MINT_TOKEN:
+// 	case STATE_MINT_CONFIRM:
+// 		return false;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
diff --git a/src/signTxMint.h b/src/signTxMint.h
index d1dc56f..b5f03e2 100644
--- a/src/signTxMint.h
+++ b/src/signTxMint.h
@@ -1,58 +1,58 @@
-#ifndef H_CARDANO_APP_SIGN_TX_MINT
-#define H_CARDANO_APP_SIGN_TX_MINT
+// #ifndef H_CARDANO_APP_SIGN_TX_MINT
+// #define H_CARDANO_APP_SIGN_TX_MINT
 
-#include "common.h"
-#include "cardano.h"
-#include "addressUtilsShelley.h"
-#include "securityPolicyType.h"
+// #include "common.h"
+// #include "cardano.h"
+// #include "addressUtilsShelley.h"
+// #include "securityPolicyType.h"
 
-#define ASSET_GROUPS_MAX 1000
-#define TOKENS_IN_GROUP_MAX 1000
+// #define ASSET_GROUPS_MAX 1000
+// #define TOKENS_IN_GROUP_MAX 1000
 
-// SIGN_STAGE_BODY_OUTPUTS = 25
-typedef enum {
-	STATE_MINT_TOP_LEVEL_DATA = 2510,
-	STATE_MINT_ASSET_GROUP = 2511,
-	STATE_MINT_TOKEN = 2512,
-	STATE_MINT_CONFIRM = 2513,
-	STATE_MINT_FINISHED = 2514
-} sign_tx_mint_state_t;
+// // SIGN_STAGE_BODY_OUTPUTS = 25
+// typedef enum {
+// 	STATE_MINT_TOP_LEVEL_DATA = 2510,
+// 	STATE_MINT_ASSET_GROUP = 2511,
+// 	STATE_MINT_TOKEN = 2512,
+// 	STATE_MINT_CONFIRM = 2513,
+// 	STATE_MINT_FINISHED = 2514
+// } sign_tx_mint_state_t;
 
-typedef struct {
-	uint8_t assetNameBytes[ASSET_NAME_SIZE_MAX];
-	size_t assetNameSize;
-	int64_t amount;
-} mint_token_amount_t;
+// typedef struct {
+// 	uint8_t assetNameBytes[ASSET_NAME_SIZE_MAX];
+// 	size_t assetNameSize;
+// 	int64_t amount;
+// } mint_token_amount_t;
 
 
-typedef struct {
-	sign_tx_mint_state_t state;
+// typedef struct {
+// 	sign_tx_mint_state_t state;
 
-	int ui_step;
+// 	int ui_step;
 
-	uint16_t numAssetGroups;
-	uint16_t currentAssetGroup;
-	uint16_t numTokens;
-	uint16_t currentToken;
+// 	uint16_t numAssetGroups;
+// 	uint16_t currentAssetGroup;
+// 	uint16_t numTokens;
+// 	uint16_t currentToken;
 
-	// this affects whether amounts and tokens are shown
-	security_policy_t mintSecurityPolicy;
+// 	// this affects whether amounts and tokens are shown
+// 	security_policy_t mintSecurityPolicy;
 
-	union {
-		struct {
-			token_group_t tokenGroup;
-			mint_token_amount_t token;
-		};
-	} stateData;
+// 	union {
+// 		struct {
+// 			token_group_t tokenGroup;
+// 			mint_token_amount_t token;
+// 		};
+// 	} stateData;
 
-} mint_context_t;
+// } mint_context_t;
 
 
-bool signTxMint_isValidInstruction(uint8_t p2);
+// bool signTxMint_isValidInstruction(uint8_t p2);
 
-void signTxMint_init();
-void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
+// void signTxMint_init();
+// void signTxMint_handleAPDU(uint8_t p2, uint8_t* wireDataBuffer, size_t wireDataSize);
 
-bool signTxMint_isFinished();
+// bool signTxMint_isFinished();
 
-#endif // H_CARDANO_APP_SIGN_TX_MINT
+// #endif // H_CARDANO_APP_SIGN_TX_MINT
diff --git a/src/txHashBuilder.c b/src/txHashBuilder.c
index 9749fb5..e0f117a 100644
--- a/src/txHashBuilder.c
+++ b/src/txHashBuilder.c
@@ -112,8 +112,8 @@ void txHashBuilder_init(
 		builder->includeValidityIntervalStart = includeValidityIntervalStart;
 		if (includeValidityIntervalStart) numItems++;
 
-		builder->includeMint = includeMint;
-		if (includeMint) numItems++;
+		// builder->includeMint = includeMint;
+		// if (includeMint) numItems++;
 
 		builder->includeScriptDataHash = includeScriptDataHash;
 		if (includeScriptDataHash) numItems++;
@@ -1160,89 +1160,89 @@ static void txHashBuilder_assertCanLeaveValidityIntervalStart(tx_hash_builder_t*
 	}
 }
 
-void txHashBuilder_enterMint(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %d", builder->state);
-
-	txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
-	ASSERT(builder->includeMint);
-
-	{
-		// Enter mint
-		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, TX_BODY_KEY_MINT);
-	}
-	builder->state = TX_HASH_BUILDER_IN_MINT;
-}
-
-void txHashBuilder_addMint_topLevelData(
-        tx_hash_builder_t* builder, uint16_t numAssetGroups
-)
-{
-	_TRACE("state = %u", builder->state);
-
-	ASSERT(builder->state == TX_HASH_BUILDER_IN_MINT);
-
-	builder->multiassetData.remainingAssetGroups = numAssetGroups;
-	// Map(numAssetGroups)[
-	//   { * policy_id => { * asset_name => uint } }
-	// ]
-	BUILDER_APPEND_CBOR(CBOR_TYPE_MAP, numAssetGroups);
-	ASSERT(numAssetGroups > 0);
-	builder->state = TX_HASH_BUILDER_IN_MINT_ASSET_GROUP;
-}
-
-void txHashBuilder_addMint_tokenGroup(
-        tx_hash_builder_t* builder,
-        const uint8_t* policyIdBuffer, size_t policyIdSize,
-        uint16_t numTokens
-)
-{
-	ASSERT(policyIdSize == MINTING_POLICY_ID_SIZE);
-
-	addTokenGroup(builder, policyIdBuffer, policyIdSize, numTokens,
-	              TX_HASH_BUILDER_IN_MINT_ASSET_GROUP, TX_HASH_BUILDER_IN_MINT_TOKEN);
-}
-
-void txHashBuilder_addMint_token(
-        tx_hash_builder_t* builder,
-        const uint8_t* assetNameBuffer, size_t assetNameSize,
-        int64_t amount
-)
-{
-	ASSERT(assetNameSize <= ASSET_NAME_SIZE_MAX);
-
-	addToken(builder, assetNameBuffer, assetNameSize, amount,
-	         TX_HASH_BUILDER_IN_MINT_TOKEN,
-	         TX_HASH_BUILDER_IN_MINT_ASSET_GROUP,
-	         TX_HASH_BUILDER_IN_MINT,
-	         amount < 0 ? CBOR_TYPE_NEGATIVE : CBOR_TYPE_UNSIGNED);
-}
-
-static void txHashBuilder_assertCanLeaveMint(tx_hash_builder_t* builder)
-{
-	_TRACE("state = %u, remainingMintAssetGroups = %u, remainingMintTokens = %u",
-	       builder->state, builder->multiassetData.remainingAssetGroups, builder->multiassetData.remainingTokens);
-
-	switch (builder->state) {
-	case TX_HASH_BUILDER_IN_MINT:
-		ASSERT(builder->multiassetData.remainingAssetGroups == 0);
-		ASSERT(builder->multiassetData.remainingTokens == 0);
-		break;
-
-	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
-	case TX_HASH_BUILDER_IN_AUX_DATA:
-	case TX_HASH_BUILDER_IN_WITHDRAWALS:
-	case TX_HASH_BUILDER_IN_CERTIFICATES:
-	case TX_HASH_BUILDER_IN_TTL:
-	case TX_HASH_BUILDER_IN_FEE:
-		txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
-		ASSERT(!builder->includeMint);
-		break;
-
-	default:
-		ASSERT(false);
-	}
-}
+// void txHashBuilder_enterMint(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %d", builder->state);
+
+// 	txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
+// 	ASSERT(builder->includeMint);
+
+// 	{
+// 		// Enter mint
+// 		BUILDER_APPEND_CBOR(CBOR_TYPE_UNSIGNED, TX_BODY_KEY_MINT);
+// 	}
+// 	builder->state = TX_HASH_BUILDER_IN_MINT;
+// }
+
+// void txHashBuilder_addMint_topLevelData(
+//         tx_hash_builder_t* builder, uint16_t numAssetGroups
+// )
+// {
+// 	_TRACE("state = %u", builder->state);
+
+// 	ASSERT(builder->state == TX_HASH_BUILDER_IN_MINT);
+
+// 	builder->multiassetData.remainingAssetGroups = numAssetGroups;
+// 	// Map(numAssetGroups)[
+// 	//   { * policy_id => { * asset_name => uint } }
+// 	// ]
+// 	BUILDER_APPEND_CBOR(CBOR_TYPE_MAP, numAssetGroups);
+// 	ASSERT(numAssetGroups > 0);
+// 	builder->state = TX_HASH_BUILDER_IN_MINT_ASSET_GROUP;
+// }
+
+// void txHashBuilder_addMint_tokenGroup(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* policyIdBuffer, size_t policyIdSize,
+//         uint16_t numTokens
+// )
+// {
+// 	ASSERT(policyIdSize == MINTING_POLICY_ID_SIZE);
+
+// 	addTokenGroup(builder, policyIdBuffer, policyIdSize, numTokens,
+// 	              TX_HASH_BUILDER_IN_MINT_ASSET_GROUP, TX_HASH_BUILDER_IN_MINT_TOKEN);
+// }
+
+// void txHashBuilder_addMint_token(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* assetNameBuffer, size_t assetNameSize,
+//         int64_t amount
+// )
+// {
+// 	ASSERT(assetNameSize <= ASSET_NAME_SIZE_MAX);
+
+// 	addToken(builder, assetNameBuffer, assetNameSize, amount,
+// 	         TX_HASH_BUILDER_IN_MINT_TOKEN,
+// 	         TX_HASH_BUILDER_IN_MINT_ASSET_GROUP,
+// 	         TX_HASH_BUILDER_IN_MINT,
+// 	         amount < 0 ? CBOR_TYPE_NEGATIVE : CBOR_TYPE_UNSIGNED);
+// }
+
+// static void txHashBuilder_assertCanLeaveMint(tx_hash_builder_t* builder)
+// {
+// 	_TRACE("state = %u, remainingMintAssetGroups = %u, remainingMintTokens = %u",
+// 	       builder->state, builder->multiassetData.remainingAssetGroups, builder->multiassetData.remainingTokens);
+
+// 	switch (builder->state) {
+// 	// case TX_HASH_BUILDER_IN_MINT:
+// 	// 	ASSERT(builder->multiassetData.remainingAssetGroups == 0);
+// 	// 	ASSERT(builder->multiassetData.remainingTokens == 0);
+// 	// 	break;
+
+// 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
+// 	case TX_HASH_BUILDER_IN_AUX_DATA:
+// 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
+// 	case TX_HASH_BUILDER_IN_CERTIFICATES:
+// 	case TX_HASH_BUILDER_IN_TTL:
+// 	case TX_HASH_BUILDER_IN_FEE:
+// 		txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
+// 		ASSERT(!builder->includeMint);
+// 		break;
+
+// 	default:
+// 		ASSERT(false);
+// 	}
+// }
 
 void txHashBuilder_addScriptDataHash(
         tx_hash_builder_t* builder,
@@ -1252,7 +1252,7 @@ void txHashBuilder_addScriptDataHash(
 	_TRACE("state = %d", builder->state);
 
 	ASSERT(scriptHashDataSize == SCRIPT_DATA_HASH_LENGTH);
-	txHashBuilder_assertCanLeaveMint(builder);
+	txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
 	ASSERT(builder->includeScriptDataHash);
 
 	{
@@ -1271,14 +1271,14 @@ static void txHashBuilder_assertCanLeaveScriptDataHash(tx_hash_builder_t* builde
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
 		break;
 
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
 	case TX_HASH_BUILDER_IN_CERTIFICATES:
 	case TX_HASH_BUILDER_IN_TTL:
 	case TX_HASH_BUILDER_IN_FEE:
-		txHashBuilder_assertCanLeaveMint(builder);
+		txHashBuilder_assertCanLeaveValidityIntervalStart(builder);
 		ASSERT(!builder->includeScriptDataHash);
 		break;
 
@@ -1342,7 +1342,7 @@ static void txHashBuilder_assertCanLeaveCollaterals(tx_hash_builder_t* builder)
 		break;
 
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
@@ -1408,7 +1408,7 @@ static void txHashBuilder_assertCanLeaveRequiredSigners(tx_hash_builder_t* build
 
 	case TX_HASH_BUILDER_IN_COLLATERALS:
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
@@ -1450,7 +1450,7 @@ static void txHashBuilder_assertCanLeaveNetworkId(tx_hash_builder_t* builder)
 	case TX_HASH_BUILDER_IN_REQUIRED_SIGNERS:
 	case TX_HASH_BUILDER_IN_COLLATERALS:
 	case TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH:
-	case TX_HASH_BUILDER_IN_MINT:
+	// case TX_HASH_BUILDER_IN_MINT:
 	case TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START:
 	case TX_HASH_BUILDER_IN_AUX_DATA:
 	case TX_HASH_BUILDER_IN_WITHDRAWALS:
diff --git a/src/txHashBuilder.h b/src/txHashBuilder.h
index 7420c97..c2621dd 100644
--- a/src/txHashBuilder.h
+++ b/src/txHashBuilder.h
@@ -14,7 +14,7 @@ enum {
 	// TX_BODY_KEY_UPDATE = 6, // not used
 	TX_BODY_KEY_AUX_DATA = 7,
 	TX_BODY_KEY_VALIDITY_INTERVAL_START = 8,
-	TX_BODY_KEY_MINT = 9,
+	// TX_BODY_KEY_MINT = 9,
 	TX_BODY_KEY_SCRIPT_HASH_DATA = 11,
 	TX_BODY_KEY_COLLATERALS = 13,
 	TX_BODY_KEY_REQUIRED_SIGNERS = 14,
@@ -53,10 +53,10 @@ typedef enum {
 	TX_HASH_BUILDER_IN_WITHDRAWALS = 700,
 	TX_HASH_BUILDER_IN_AUX_DATA = 800,
 	TX_HASH_BUILDER_IN_VALIDITY_INTERVAL_START = 900,
-	TX_HASH_BUILDER_IN_MINT = 1000,
-	TX_HASH_BUILDER_IN_MINT_TOP_LEVEL_DATA = 1010,
-	TX_HASH_BUILDER_IN_MINT_ASSET_GROUP = 1011,
-	TX_HASH_BUILDER_IN_MINT_TOKEN = 1012,
+	// TX_HASH_BUILDER_IN_MINT = 1000,
+	// TX_HASH_BUILDER_IN_MINT_TOP_LEVEL_DATA = 1010,
+	// TX_HASH_BUILDER_IN_MINT_ASSET_GROUP = 1011,
+	// TX_HASH_BUILDER_IN_MINT_TOKEN = 1012,
 	TX_HASH_BUILDER_IN_SCRIPT_DATA_HASH = 1100,
 	TX_HASH_BUILDER_IN_COLLATERALS = 1200,
 	TX_HASH_BUILDER_IN_REQUIRED_SIGNERS = 1300,
@@ -222,20 +222,20 @@ void txHashBuilder_addValidityIntervalStart(
         uint64_t validityIntervalStart
 );
 
-void txHashBuilder_enterMint(tx_hash_builder_t* builder);
-void txHashBuilder_addMint_topLevelData(
-        tx_hash_builder_t* builder, uint16_t numAssetGroups
-);
-void txHashBuilder_addMint_tokenGroup(
-        tx_hash_builder_t* builder,
-        const uint8_t* policyIdBuffer, size_t policyIdSize,
-        uint16_t numTokens
-);
-void txHashBuilder_addMint_token(
-        tx_hash_builder_t* builder,
-        const uint8_t* assetNameBuffer, size_t assetNameSize,
-        int64_t amount
-);
+// void txHashBuilder_enterMint(tx_hash_builder_t* builder);
+// void txHashBuilder_addMint_topLevelData(
+//         tx_hash_builder_t* builder, uint16_t numAssetGroups
+// );
+// void txHashBuilder_addMint_tokenGroup(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* policyIdBuffer, size_t policyIdSize,
+//         uint16_t numTokens
+// );
+// void txHashBuilder_addMint_token(
+//         tx_hash_builder_t* builder,
+//         const uint8_t* assetNameBuffer, size_t assetNameSize,
+//         int64_t amount
+// );
 
 void txHashBuilder_addScriptDataHash(
         tx_hash_builder_t* builder,
diff --git a/src/uiScreens.c b/src/uiScreens.c
index 0374819..68a1d69 100644
--- a/src/uiScreens.c
+++ b/src/uiScreens.c
@@ -526,28 +526,28 @@ void ui_displayTokenAmountOutputScreen(
 	);
 }
 
-void ui_displayTokenAmountMintScreen(
-        const token_group_t* tokenGroup,
-        const uint8_t* assetNameBytes, size_t assetNameSize,
-        int64_t tokenAmount,
-        ui_callback_fn_t callback
-)
-{
-	char tokenAmountStr[70] = {0};
-	explicit_bzero(tokenAmountStr, SIZEOF(tokenAmountStr));
-	str_formatTokenAmountMint(
-	        tokenGroup,
-	        assetNameBytes, assetNameSize,
-	        tokenAmount,
-	        tokenAmountStr, SIZEOF(tokenAmountStr)
-	);
-
-	ui_displayPaginatedText(
-	        "Token amount",
-	        tokenAmountStr,
-	        callback
-	);
-}
+// void ui_displayTokenAmountMintScreen(
+//         const token_group_t* tokenGroup,
+//         const uint8_t* assetNameBytes, size_t assetNameSize,
+//         int64_t tokenAmount,
+//         ui_callback_fn_t callback
+// )
+// {
+// 	char tokenAmountStr[70] = {0};
+// 	explicit_bzero(tokenAmountStr, SIZEOF(tokenAmountStr));
+// 	str_formatTokenAmountMint(
+// 	        tokenGroup,
+// 	        assetNameBytes, assetNameSize,
+// 	        tokenAmount,
+// 	        tokenAmountStr, SIZEOF(tokenAmountStr)
+// 	);
+
+// 	ui_displayPaginatedText(
+// 	        "Token amount",
+// 	        tokenAmountStr,
+// 	        callback
+// 	);
+// }
 
 void ui_displayUint64Screen(
         const char* firstLine,
diff --git a/src/uiScreens.h b/src/uiScreens.h
index 2c23afe..c636a7b 100644
--- a/src/uiScreens.h
+++ b/src/uiScreens.h
@@ -89,13 +89,13 @@ void ui_displayTokenAmountOutputScreen(
         ui_callback_fn_t callback
 );
 
-__noinline_due_to_stack__
-void ui_displayTokenAmountMintScreen(
-        const token_group_t* tokenGroup,
-        const uint8_t* assetNameBytes, size_t assetNameSize,
-        int64_t tokenAmount,
-        ui_callback_fn_t callback
-);
+// __noinline_due_to_stack__
+// void ui_displayTokenAmountMintScreen(
+//         const token_group_t* tokenGroup,
+//         const uint8_t* assetNameBytes, size_t assetNameSize,
+//         int64_t tokenAmount,
+//         ui_callback_fn_t callback
+// );
 
 __noinline_due_to_stack__
 void ui_displayUint64Screen(
